<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【webpack】一步步的看webpack-10</title>
      <link href="/2020/06/29/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-10/"/>
      <url>/2020/06/29/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-10/</url>
      
        <content type="html"><![CDATA[<p>我们在打包或者开发过程中经常要区分开发环境和生产环境，webpack给我们提供了<strong>webpack-merge</strong>插件，可以通过这种方式去区分环境</p><a id="more"></a><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><strong>webpack.common.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"> <span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"> <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"> <span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"> <span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> copyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> TerserJSPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   entry: &#123;</span><br><span class="line">     app: <span class="string">'./src/index.js'</span></span><br><span class="line">   &#125;,</span><br><span class="line">   optimization: &#123;</span><br><span class="line">    minimizer: [<span class="keyword">new</span> TerserJSPlugin(&#123;&#125;), <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)],</span><br><span class="line">  &#125;,</span><br><span class="line">   plugins: [</span><br><span class="line">     <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">     <span class="keyword">new</span> copyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123; <span class="attr">from</span>: <span class="string">'doc'</span>, <span class="attr">to</span>: <span class="string">'./'</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">     <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">       title: <span class="string">'Production'</span>,</span><br><span class="line">       <span class="comment">//压缩html</span></span><br><span class="line">       minify:&#123;</span><br><span class="line">          removeAttributeQuotes:<span class="literal">true</span>, <span class="comment">//去掉双引号</span></span><br><span class="line">          collapseWhitespace:<span class="literal">true</span> <span class="comment">//这成一行</span></span><br><span class="line">       &#125;,</span><br><span class="line">       hash: <span class="literal">true</span></span><br><span class="line">     &#125;),</span><br><span class="line">     <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].css'</span>,</span><br><span class="line">      chunkFilename: <span class="string">'[id].css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">      $: <span class="string">"jquery"</span>,</span><br><span class="line">      jQuery: <span class="string">"jquery"</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'2020 by zzp'</span>)</span><br><span class="line">   ],</span><br><span class="line">   output: &#123;</span><br><span class="line">     filename: <span class="string">'[name].bundle.[hash:8].js'</span>,</span><br><span class="line">     path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          use: [ MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span> ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">           test:<span class="regexp">/\.(png|jpg|gif)/</span> ,</span><br><span class="line">           use:[&#123;</span><br><span class="line">               loader:<span class="string">'url-loader'</span>,</span><br><span class="line">               options:&#123;</span><br><span class="line">                outputPath: <span class="string">'images'</span>,</span><br><span class="line">                name: <span class="string">'[name].[ext]'</span>,</span><br><span class="line">                limit:<span class="number">500</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//   test: /\.js$/,</span></span><br><span class="line">        <span class="comment">//   exclude: /node_modules/,</span></span><br><span class="line">        <span class="comment">//   use:&#123;</span></span><br><span class="line">        <span class="comment">//       loader: 'eslint-loader',</span></span><br><span class="line">        <span class="comment">//       options:&#123;</span></span><br><span class="line">        <span class="comment">//         emitWarning: true,</span></span><br><span class="line">        <span class="comment">//         enforce: 'pre' //前置，在之前先运行，post是后面的意思</span></span><br><span class="line">        <span class="comment">//       &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;,</span></span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">          include: path.resolve(__dirname,<span class="string">'src'</span>),</span><br><span class="line">          use:[</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">              <span class="comment">// exclude: /(node_modules|bower_components)/,</span></span><br><span class="line">              options:&#123;</span><br><span class="line">                presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">                plugins: [<span class="string">'@babel/plugin-proposal-class-properties'</span>,<span class="string">'@babel/plugin-transform-runtime'</span>]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve:&#123;</span><br><span class="line">      modules: [path.resolve(<span class="string">'node_modules'</span>)], <span class="comment">//查找目录，可以写多个，比如第三方插件，自定义的目录</span></span><br><span class="line">      <span class="comment">// alias:&#123;</span></span><br><span class="line">      <span class="comment">//   bootstrap:"bootstrap/dist/css/bootstrap.min.css" //别名</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">      extensions: [<span class="string">'.css'</span>,<span class="string">'.js'</span>, <span class="string">'.json'</span>,<span class="string">'.vue'</span>],<span class="comment">//配置了以后引入模块可以省略后缀，默认按照数组顺序查找</span></span><br><span class="line">      mainFields:[<span class="string">'style'</span>,<span class="string">'main'</span>]   <span class="comment">//先去找bootstrap中的style，然后再去找main，可以看node_modules中的bootsratp package.json文件</span></span><br><span class="line">    &#125;,</span><br><span class="line">    performance: &#123;</span><br><span class="line">      hints: <span class="string">"warning"</span>, <span class="comment">// 枚举</span></span><br><span class="line">      maxAssetSize: <span class="number">30000000</span>, <span class="comment">// 整数类型（以字节为单位）</span></span><br><span class="line">      maxEntrypointSize: <span class="number">50000000</span>, <span class="comment">// 整数类型（以字节为单位）</span></span><br><span class="line">      assetFilter: <span class="function"><span class="keyword">function</span>(<span class="params">assetFilename</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 提供资源文件名的断言函数</span></span><br><span class="line">      <span class="keyword">return</span> assetFilename.endsWith(<span class="string">'.css'</span>) || assetFilename.endsWith(<span class="string">'.js'</span>);</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p><strong>webpack.dev.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy:&#123;</span><br><span class="line">       <span class="string">'/api'</span>:<span class="string">'http://localhost:3000'</span> <span class="comment">//代理，在访问/api开头路径时候都代理到后面的地址进行访问</span></span><br><span class="line">    &#125;,</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    progress: <span class="literal">true</span> <span class="comment">//启动进度</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>webpack.prod.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">   <span class="keyword">new</span> UglifyJSPlugin(&#123;</span><br><span class="line">    sourceMap: <span class="literal">true</span></span><br><span class="line">   &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>打包指定package.json<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "node_modules/.bin/webpack --config webpack.prod.js",</span><br><span class="line">    "start": "webpack-dev-server --open",</span><br><span class="line">    "dev": "webpack-dev-server --open --config webpack.dev.js"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ul><h3 id="简单方式DefinePlugin"><a href="#简单方式DefinePlugin" class="headerlink" title="简单方式DefinePlugin"></a>简单方式<strong>DefinePlugin</strong></h3><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">  PRODUCTION: <span class="built_in">JSON</span>.stringify(<span class="literal">true</span>), </span><br><span class="line">  VERSION: <span class="built_in">JSON</span>.stringify(<span class="string">"5fa3b9"</span>),</span><br><span class="line">  BROWSER_SUPPORTS_HTML5: <span class="literal">true</span>,</span><br><span class="line">  TWO: <span class="string">"1+1"</span>,</span><br><span class="line">  <span class="string">"typeof window"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"object"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意！！因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【webpack】一步步的看webpack-8</title>
      <link href="/2020/06/29/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-8/"/>
      <url>/2020/06/29/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-8/</url>
      
        <content type="html"><![CDATA[<p>在开发过程中，我们往往会请求后端接口，这时候就会存在跨域的问题，那webpack如何在开发时解决跨域的问题呢？</p><a id="more"></a><h3 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h3><p><strong>webpack.dev.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://localhost:3000'</span>, <span class="comment">//将api开头的代理到该地址访问</span></span><br><span class="line">        pathRewrite: &#123;<span class="string">'^/api'</span> : <span class="string">''</span>&#125; <span class="comment">//在路径中将api开头去掉</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://webpack.docschina.org/configuration/dev-server/" target="_blank" rel="noopener">更多devServer配置</a></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【webpack】一步步的看webpack-9</title>
      <link href="/2020/06/29/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-9/"/>
      <url>/2020/06/29/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-9/</url>
      
        <content type="html"><![CDATA[<p>很多时候我们引入的时候需要输入一长串的路径，或者引入第三方模块的时候不方便，这时候<strong>Resolve</strong>配置就可以解决这个事情啦</p><a id="more"></a><p><strong>webpack.dev.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolve:&#123;</span><br><span class="line">      modules: [path.resolve(<span class="string">'node_modules'</span>)], <span class="comment">//查找目录，可以写多个，比如第三方插件，自定义的目录</span></span><br><span class="line">      <span class="comment">// alias:&#123;</span></span><br><span class="line">      <span class="comment">//   bootstrap:"bootstrap/dist/css/bootstrap.min.css" //别名</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">      extensions: [<span class="string">'.css'</span>,<span class="string">'.js'</span>, <span class="string">'.json'</span>,<span class="string">'.vue'</span>],<span class="comment">//配置了以后引入模块可以省略后缀，默认按照数组顺序查找</span></span><br><span class="line">      mainFields:[<span class="string">'style'</span>,<span class="string">'main'</span>]   <span class="comment">//先去找bootstrap中的style，然后再去找main，可以看node_modules中的bootsratp package.json文件</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面配置好我们就可以随心所欲的在需要的模块<code>import &#39;bootstrap&#39;</code> 引入模块啦，这里和<code>ProvidePlugin</code>不一样哦，这个插件是全局变量，都不需要<code>import</code>的，所以根据实际情况进行去选择</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【webpack】一步步的看webpack-10</title>
      <link href="/2020/06/29/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack%E7%BB%93%E5%B0%BE/"/>
      <url>/2020/06/29/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack%E7%BB%93%E5%B0%BE/</url>
      
        <content type="html"><![CDATA[<p>好啦，webpack4大部分的功能概念都在里面咯，剩下的就自己深入摸索吧，比如自定义插件，性能优化之类更深入的东西</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【webpack】一步步的看webpack-7</title>
      <link href="/2020/06/28/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-7/"/>
      <url>/2020/06/28/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-7/</url>
      
        <content type="html"><![CDATA[<p>当我们需要使用jquery第三方插件的时候使用到”$”这种全局变量该怎么办呢，webpack给我们准备了全局变量配置的概念，我们来看一下把</p><a id="more"></a><h3 id="每个模块都加一个，简单哦"><a href="#每个模块都加一个，简单哦" class="headerlink" title="每个模块都加一个，简单哦"></a>每个模块都加一个，简单哦</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line">plugins: [</span><br><span class="line">   <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">       $: <span class="string">"jquery"</span>,</span><br><span class="line">       jQuery: <span class="string">"jquery"</span></span><br><span class="line">       &#125;)</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure><p>这样我们就可以在每个模块里面直接使用<code>$</code>啦</p><h3 id="还有一个笨办法，就是使用expose-loader"><a href="#还有一个笨办法，就是使用expose-loader" class="headerlink" title="还有一个笨办法，就是使用expose-loader"></a>还有一个笨办法，就是使用<code>expose-loader</code></h3>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【webpack】一步步的看webpack-6</title>
      <link href="/2020/06/27/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-6/"/>
      <url>/2020/06/27/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-6/</url>
      
        <content type="html"><![CDATA[<p>在我们开发过程中每次都需要打包而且js报错的话我们也无法跟踪具体的错误在哪个js，只能定位到打包压缩后的js文件，这样让我们开发很麻烦，下面就主要说一下在开发中如何进行调试，以及<br>如何动态热加载文件</p><a id="more"></a><h3 id="使用source-map"><a href="#使用source-map" class="headerlink" title="使用source map"></a>使用source map</h3><ul><li>当 webpack 打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会简单地指向到 bundle.js。这并通常没有太多帮助，因为你可能需要准确地知道错误来自于哪个源文件。<br>为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。<br>source map 有很多不同的选项可用，请务必仔细阅读它们，以便可以根据需要进行配置。<br>对于本指南，我们使用 inline-source-map 选项，这有助于解释说明我们的目的（仅解释说明，不要用于生产环境）：</li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">  <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      app: <span class="string">'./src/index.js'</span>,</span><br><span class="line">      print: <span class="string">'./src/print.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: <span class="string">'Development'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>加入devtool后，我们就可以在浏览器f12查看console中看到具体的代码打包之前源代码具体错误在第几行咯</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>每次要编译代码时，手动运行 <code>npm run build</code> 就会变得很麻烦。</p><p>webpack 中有几个不同的选项，可以帮助你在代码发生变化后自动编译代码：</p><ul><li>webpack’s Watch Mode</li><li>webpack-dev-server</li><li>webpack-dev-middleware<br>多数场景中，你可能需要使用 webpack-dev-server，但是不妨探讨一下以上的所有选项。</li></ul><p>我们挑一个大众使用最多的方式webpack-dev-server<br><code>webpack-dev-server</code>为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。让我们设置以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">yarn add -D webpack-dev-server</span><br></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"> <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"> <span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   entry: &#123;</span><br><span class="line">     app: <span class="string">'./src/index.js'</span>,</span><br><span class="line">     print: <span class="string">'./src/print.js'</span></span><br><span class="line">   &#125;,</span><br><span class="line">   devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">   plugins: [</span><br><span class="line">     <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">     <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">       title: <span class="string">'Development'</span></span><br><span class="line">     &#125;)</span><br><span class="line">   ],</span><br><span class="line">   output: &#123;</span><br><span class="line">     filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">     path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>以上配置告知 webpack-dev-server，在 localhost:8080 下建立服务，将 dist 目录下的文件，作为可访问文件。</p><p>让我们添加一个 script 脚本，可以直接运行开发服务器(dev server)：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"development"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"webpack.config.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="attr">"watch"</span>: <span class="string">"webpack --watch"</span>,</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"webpack-dev-server --open"</span>,   <span class="comment">//添加启动,--open为自动打开默认浏览器</span></span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"clean-webpack-plugin"</span>: <span class="string">"^0.1.16"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^0.28.4"</span>,</span><br><span class="line">    <span class="attr">"csv-loader"</span>: <span class="string">"^2.1.1"</span>,</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^0.11.2"</span>,</span><br><span class="line">    <span class="attr">"html-webpack-plugin"</span>: <span class="string">"^2.29.0"</span>,</span><br><span class="line">    <span class="attr">"style-loader"</span>: <span class="string">"^0.18.2"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"xml-loader"</span>: <span class="string">"^1.2.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以在命令行中运行 <code>npm start</code>，就会看到浏览器自动加载页面。如果现在修改和保存任意源文件，web 服务器就会自动重新加载编译后的代码。试一下！</p><h3 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h3><ul><li>模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：<ul><li>保留在完全重新加载页面时丢失的应用程序状态。</li><li>只更新变更内容，以节省宝贵的开发时间。</li><li>调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。<br><a href="https://www.jianshu.com/p/95f5f51e6fc7" target="_blank" rel="noopener">了解实现原理</a></li></ul></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">  <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"> <span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      app: <span class="string">'./src/index.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'inline-source-map'</span>,</span><br><span class="line">    devServer: &#123; <span class="comment">//这里是最主要的哦</span></span><br><span class="line">      contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">      hot: <span class="literal">true</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: <span class="string">'Hot Module Replacement'</span></span><br><span class="line">      &#125;),</span><br><span class="line">     <span class="keyword">new</span> webpack.NamedModulesPlugin(), <span class="comment">//告诉我们哪个模块热更新了</span></span><br><span class="line">     <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()  <span class="comment">//热替换插件</span></span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>你可以通过命令来修改 webpack-dev-server 的配置：webpack-dev-server –hotOnly。</p></blockquote><p>注意，我们还添加了 <a href="https://www.webpackjs.com/plugins/named-modules-plugin/" target="_blank" rel="noopener">NamedModulesPlugin</a>，以便更容易查看要修补(patch)的依赖。在起步阶段，我们将通过在命令行中运行 npm start 来启动并运行 dev server。</p><p>现在，我们来修改 index.js 文件，以便当 print.js 内部发生变更时可以告诉 webpack 接受更新的模块。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【webpack】一步步的看webpack-5</title>
      <link href="/2020/06/27/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-5/"/>
      <url>/2020/06/27/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-5/</url>
      
        <content type="html"><![CDATA[<p>在webpack进行打包输出的时候，我们每次都要写一个index.html去引入生成的js文件，这里介绍个插件<strong>HtmlWebpackPlugin</strong>，可以打包的时候帮助我们生成html文件自动引入</p><a id="more"></a><h3 id="设定HtmlWebpackPlugin"><a href="#设定HtmlWebpackPlugin" class="headerlink" title="设定HtmlWebpackPlugin"></a>设定HtmlWebpackPlugin</h3><ul><li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br><span class="line">&#x2F;&#x2F;或yarn</span><br><span class="line">yarn add -D html-webpack-plugin</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   entry: &#123;</span><br><span class="line">     app: <span class="string">'./src/index.js'</span>,</span><br><span class="line">     print: <span class="string">'./src/print.js'</span></span><br><span class="line">   &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'Output Management'</span>,</span><br><span class="line">      filename: <span class="string">'app.html'</span>, <span class="comment">//不指定默认index</span></span><br><span class="line">      <span class="comment">//压缩生成的html</span></span><br><span class="line">      chunks:[<span class="string">'app'</span>]   <span class="comment">//不指定则会将所有入口文件引入到index.html中</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'Output Management'</span>,</span><br><span class="line">      filename: <span class="string">'print.html'</span>,</span><br><span class="line">      <span class="comment">//压缩生成的html</span></span><br><span class="line">      chunks:[<span class="string">'app'</span>,<span class="string">'print'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">   output: &#123;</span><br><span class="line">     filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">     path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在我们构建之前，你应该了解，虽然在 dist/ 文件夹我们已经有 index.html 这个文件，然而 HtmlWebpackPlugin 还是会默认生成 index.html 文件。这就是说，它会用新生成的 index.html 文件，把我们的原来的替换<br>如果你在代码编辑器中将 index.html 打开，你就会看到 HtmlWebpackPlugin 创建了一个全新的文件，所有的 bundle 会自动添加到 html 中。<br>如果你想要了解更多 HtmlWebpackPlugin 插件提供的全部功能和选项，那么你就应该多多熟悉 <a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">HtmlWebpackPlugin</a> 仓库。</p></blockquote><h3 id="清理-dist文件夹clean-webpack-plugin"><a href="#清理-dist文件夹clean-webpack-plugin" class="headerlink" title="清理/dist文件夹clean-webpack-plugin"></a>清理/dist文件夹<strong>clean-webpack-plugin</strong></h3><ul><li>你可能已经注意到，由于过去的指南和代码示例遗留下来，导致我们的 /dist 文件夹相当杂乱。webpack 会生成文件，然后将这些文件放置在 /dist 文件夹中，但是 webpack 无法追踪到哪些文件是实际在项目中用到的。<br>通常，在每次构建前清理 /dist 文件夹，是比较推荐的做法，因此只会生成用到的文件。让我们完成这个需求。<br><a href="https://www.npmjs.com/package/clean-webpack-plugin" target="_blank" rel="noopener">clean-webpack-plugin</a> 是一个比较普及的管理插件，让我们安装和配置下。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install clean-webpack-plugin --save-dev</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">yarn add -D clean-webpack-plugin</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">  <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      app: <span class="string">'./src/index.js'</span>,</span><br><span class="line">      print: <span class="string">'./src/print.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">     <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        title: <span class="string">'Output Management'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>现在执行 npm run build，再检查 /dist 文件夹。如果一切顺利，你现在应该不会再看到旧的文件，只有构建后生成的文件！</p><h3 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h3><ul><li>你可能会感兴趣，webpack及其插件似乎“知道”应该哪些文件生成。答案是，通过 manifest，webpack 能够对「你的模块映射到输出 bundle 的过程」保持追踪。如果你对通过其他方式来管理 webpack 的输出更感兴趣，那么首先了解 manifest 是个好的开始。<br>通过使用 <a href="https://github.com/danethurber/webpack-manifest-plugin" target="_blank" rel="noopener">WebpackManifestPlugin</a>，可以直接将数据提取到一个 json 文件，以供使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【webpack】一步步的看webpack-4</title>
      <link href="/2020/06/27/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-4/"/>
      <url>/2020/06/27/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-4/</url>
      
        <content type="html"><![CDATA[<p>前面讲了webpack里面大部分的概念，这篇主要说一下loader</p><a id="more"></a><h3 id="加载css"><a href="#加载css" class="headerlink" title="加载css"></a>加载css</h3><ul><li>为了从 JavaScript 模块中 import 一个 CSS 文件，你需要在 module 配置中 安装并添加 style-loader 和 css-loader：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader css-loader</span><br><span class="line">&#x2F;&#x2F;或者使用yarn</span><br><span class="line">yarn add -D style-loader css-loader</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"> <span class="built_in">module</span>: &#123;</span><br><span class="line">   rules: [</span><br><span class="line">     &#123;</span><br><span class="line">       test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">       use: [</span><br><span class="line">         <span class="string">'style-loader'</span>,</span><br><span class="line">         <span class="string">'css-loader'</span></span><br><span class="line">       ]</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>style-loader：它是把css插入到head的标签中</li><li>css-loader：接续@import这种语法</li><li>use:按照配置的数组顺序执行</li></ul><blockquote><p>webpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。在这种情况下，以 .css 结尾的全部文件，都将被提供给 style-loader 和 css-loader。<br>这使你可以在依赖于此样式的文件中 import ‘./style.css’。现在，当该模块运行时，含有 CSS 字符串的 <code>&lt;style&gt;</code> 标签，将被插入到 html 文件的 <code>&lt;head&gt;</code> 中。</p></blockquote><p>我们尝试一下，通过在项目中添加一个新的 style.css 文件，并将其导入到我们的 index.js 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">|- package.json</span><br><span class="line">|- webpack.config.js</span><br><span class="line">|- &#x2F;dist</span><br><span class="line">  |- bundle.js</span><br><span class="line">  |- index.html</span><br><span class="line">|- &#x2F;src</span><br><span class="line"> |- style.css</span><br><span class="line">  |- index.js</span><br><span class="line">|- &#x2F;node_modules</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// lodash 是由当前 script 脚本 import 导入进来的</span></span><br><span class="line">   element.innerHTML = _.join([<span class="string">'Hello'</span>, <span class="string">'webpack'</span>], <span class="string">' '</span>);</span><br><span class="line">  element.classList.add(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> element;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">document</span>.body.appendChild(component());</span><br></pre></td></tr></table></figure><p>再次在浏览器中打开 index.html，你应该看到 Hello webpack 现在的样式是红色。要查看 webpack 做了什么，请检查页面（不要查看页面源代码，因为它不会显示结果），并查看页面的 head 标签。它应该包含我们在 index.js 中导入的 style 块元素。</p><blockquote><p>请注意，在多数情况下，你也可以进行 <a href="https://www.webpackjs.com/plugins/extract-text-webpack-plugin/" target="_blank" rel="noopener">CSS 分离</a>-将css在js代码中抽取出来，具体的下面会讲到，以便在生产环境中节省加载时间。最重要的是，现有的 loader 可以支持任何你可以想到的 CSS 处理器风格 - postcss, sass 和 less 等。</p></blockquote><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><ul><li><p>在学习Webapck过程中你可能遇到的第一个坑就是CSS中的图片处理。很多webpack新手都在图片的坑中无法自拔（有的小伙伴在开发环境中是可以找到图片的，但是一打包后就找不到图片了，有的小伙伴是不知道如何正确引入html或者css中的图片，导致程序出错），我们将用三节课时间搞彻底走出webpack图片的坑。</p></li><li><p><strong>file-loader</strong>、<strong>url-loader</strong></p></li><li><p>安装file-loader和url-loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br><span class="line">&#x2F;&#x2F;或者yarn</span><br><span class="line">yarn add -D file-loader url-loader</span><br></pre></td></tr></table></figure><p>安装好后我们需要对两个loader进行基本的了解，学习尽量做到知其然知其所以然。</p></li><li><p><strong>file-loader</strong>：解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。</p></li><li><p><strong>url-loader</strong>：如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。</p></li><li><p>配置url-loader<br>我们安装好后，就可以使用这个loader了，记得在loader使用时不需要用require引入，在plugins才需要使用require引入。</p></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块：例如解读CSS,图片如何转换，压缩</span></span><br><span class="line">   <span class="built_in">module</span>:&#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">             test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">             use: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ]</span><br><span class="line">           &#125;,&#123;</span><br><span class="line">              test:<span class="regexp">/\.(png|jpg|gif)/</span> ,</span><br><span class="line">              use:[&#123;</span><br><span class="line">                  loader:<span class="string">'url-loader'</span>,</span><br><span class="line">                  options:&#123;</span><br><span class="line">                      limit:<span class="number">200</span>*<span class="number">1024</span>,  <span class="comment">//byte,200k大小图片内压缩为dataUrl</span></span><br><span class="line">                      outputPath: <span class="string">'img/'</span> <span class="comment">//打包图片指定路径</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;]</span><br><span class="line">           &#125;</span><br><span class="line">         ]</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">webpack-demo</span><br><span class="line">|- package.json</span><br><span class="line">|- webpack.config.js</span><br><span class="line">|- &#x2F;dist</span><br><span class="line">  |- bundle.js</span><br><span class="line">  |- index.html</span><br><span class="line">|- &#x2F;src</span><br><span class="line"> |- icon.png</span><br><span class="line">  |- style.css</span><br><span class="line">  |- index.js</span><br><span class="line">|- &#x2F;node_modules</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"> <span class="keyword">import</span> <span class="string">'./style.css'</span>;</span><br><span class="line"><span class="keyword">import</span> Icon <span class="keyword">from</span> <span class="string">'./icon.png'</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Lodash，现在由此脚本导入</span></span><br><span class="line">   element.innerHTML = _.join([<span class="string">'Hello'</span>, <span class="string">'webpack'</span>], <span class="string">' '</span>);</span><br><span class="line">   element.classList.add(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将图像添加到我们现有的 div。</span></span><br><span class="line">  <span class="keyword">var</span> myIcon = <span class="keyword">new</span> Image();</span><br><span class="line">  myIcon.src = Icon;</span><br><span class="line"></span><br><span class="line">  element.appendChild(myIcon);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> element;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">document</span>.body.appendChild(component());</span><br></pre></td></tr></table></figure><p>style.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hello</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line"> <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'./icon.png'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>test:/.(png|jpg|gif)/是匹配图片文件后缀名称。</li><li>use：是指定使用的loader和loader的配置参数。是按照配置的顺序执行</li><li>limit：是把小于500000B的文件打成Base64的格式，写入JS。<br>写好后就可以使用webpack进行打包了，这回你会发现打包很顺利的完成了。具体的Base64的格式，你可以查看视频中的样子。<h4 id="为什么只使用了url-loader"><a href="#为什么只使用了url-loader" class="headerlink" title="为什么只使用了url-loader"></a>为什么只使用了url-loader</h4></li></ul><p>有的小伙伴会发现我们并没有在webpack.config.js中使用file-loader，但是依然打包成功了。我们需要了解file-loader和url-loader的关系。url-loader和file-loader是什么关系呢？简答地说，url-loader封装了file-loader。url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader。通过上面的介绍，我们可以看到，url-loader工作分两种情况：</p><p>1.文件大小小于limit参数，url-loader将会把文件转为DataURL（Base64格式）；</p><p>2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。</p><p>也就是说，其实我们只安装一个url-loader就可以了。但是为了以后的操作方便，我们这里就顺便安装上file-loader。</p><h3 id="加载字体"><a href="#加载字体" class="headerlink" title="加载字体"></a>加载字体</h3><p>那么，像字体这样的其他资源如何处理呢？file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。这就是说，我们可以将它们用于任何类型的文件，包括字体。让我们更新 webpack.config.js 来处理字体文件：</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">'style-loader'</span>,</span><br><span class="line">            <span class="string">'css-loader'</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">'file-loader'</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">           <span class="string">'file-loader'</span></span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><ul><li>此外，可以加载的有用资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 import Data from ‘./data.json’ 默认将正常运行。要导入 CSV、TSV 和 XML，你可以使用 csv-loader 和 xml-loader。让我们处理这三类文件：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev csv-loader xml-loader</span><br><span class="line">//或</span><br><span class="line">yarn add -D csv-loader xml-loader</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">   output: &#123;</span><br><span class="line">     filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">     path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="built_in">module</span>: &#123;</span><br><span class="line">     rules: [</span><br><span class="line">       &#123;</span><br><span class="line">         test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">           <span class="string">'style-loader'</span>,</span><br><span class="line">           <span class="string">'css-loader'</span></span><br><span class="line">         ]</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">           <span class="string">'file-loader'</span></span><br><span class="line">         ]</span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">         test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">         use: [</span><br><span class="line">           <span class="string">'file-loader'</span></span><br><span class="line">         ]</span><br><span class="line">       &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(csv|tsv)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'csv-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.xml$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'xml-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">     ]</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="css分离与图片路径处理"><a href="#css分离与图片路径处理" class="headerlink" title="css分离与图片路径处理"></a>css分离与图片路径处理</h3><ul><li>有些简单的交互页面中，你的JavasScript页面代码会非常少，而大部分代码都在CSS中，这时候项目组长会要求把CSS单独提取出来，方便以后更改。遇到这个需求你不要惊慌，已经有大神为我们准备好了对象的插件（plugin）。</li></ul><p><strong>extract-text-webpack-plugin</strong></p><ul><li>这个插件就可以完美的解决我们提取CSS的需求，但是webpack官方其实并不建议这样，他们认为CSS就应该打包到JavasScript当中以减少http的请求数。但现实中的需求往往不是我们前端能控制的，有些需求是我们不能控制的，分离CSS就是这样一个既合理由不合理的需求。</li></ul><p><strong>mini-css-extract-plugin</strong></p><ul><li>webpack4有一个新插件,同上面的类似，webpack4不用<strong>extract-text-webpack-plugin</strong>这个插件了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br><span class="line">&#x2F;&#x2F;或者yarn</span><br><span class="line">yarn add -D mini-css-extract-plugin</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="comment">// Options similar to the same options in webpackOptions.output</span></span><br><span class="line">      <span class="comment">// both options are optional</span></span><br><span class="line">      filename: <span class="string">'[name].css'</span>,</span><br><span class="line">      chunkFilename: <span class="string">'[id].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://www.npmjs.com/package/mini-css-extract-plugin" target="_blank" rel="noopener">更多使用方式</a></p><h4 id="图片路径问题："><a href="#图片路径问题：" class="headerlink" title="图片路径问题："></a>图片路径问题：</h4><p>利用mini-css-extract-plugin插件很轻松的就把CSS文件分离了出来，但是CSS路径并不正确，很多小伙伴就在这里搞个几天还是没有头绪，网上也给出了很多的解决方案，我觉的最好的解决方案是使用publicPath解决，我也一直在用。当然我们如果打包的js文件在cdn上也可以用下面的方法指定域名哦</p><p>publicPath：是在webpack.config.js文件的output选项中，主要作用就是处理静态文件路径的。</p><p>在处理前，我们在webpack.config.js 上方声明一个对象，叫website。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> website =&#123;</span><br><span class="line">    publicPath:<span class="string">"http://192.168.1.108:1717/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的IP和端口，是你本机的ip或者是你devServer配置的IP和端口。</p><p>然后在output选项中引用这个对象的publicPath属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出口文件的配置项</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">//输出的路径，用了Node语法</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        <span class="comment">//输出的文件名称</span></span><br><span class="line">        filename:<span class="string">'[name].js'</span>,</span><br><span class="line">        publicPath:website.publicPath</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>当然上面是全局的，那么如果我只想对图片单独配置一个输出的域名路径呢？<br><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块：例如解读CSS,图片如何转换，压缩</span></span><br><span class="line">   <span class="built_in">module</span>:&#123;</span><br><span class="line">       rules: [</span><br><span class="line">           &#123;</span><br><span class="line">             test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">             use: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ]</span><br><span class="line">           &#125;,&#123;</span><br><span class="line">              test:<span class="regexp">/\.(png|jpg|gif)/</span> ,</span><br><span class="line">              use:[&#123;</span><br><span class="line">                  loader:<span class="string">'url-loader'</span>,</span><br><span class="line">                  options:&#123;</span><br><span class="line">                      name: <span class="string">'[name].[ext]'</span>, <span class="comment">//其实url-loader内部调用的就是file-loader，我们看file-loader配置项就可以</span></span><br><span class="line">                      limit:<span class="number">200</span>*<span class="number">1024</span>,  <span class="comment">//byte,200k大小图片内压缩为dataUrl</span></span><br><span class="line">                      outputPath: <span class="string">'img/'</span>, <span class="comment">//打包图片指定路径</span></span><br><span class="line">                      publicPath: <span class="string">'http://oss'</span> <span class="comment">//这样就可以咯</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;]</span><br><span class="line">           &#125;</span><br><span class="line">         ]</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>配置完成后，你再使用webpack命令进行打包，你会发现原来的相对路径改为了绝对路径，这样来讲速度更快。</p><p><strong>html-withimg-loader</strong></p><ul><li>webpack处理资源无往不利，但有个问题总是很苦恼，html中直接使用img标签src加载图片的话，因为没有被依赖，图片将不会被打包。这个loader解决这个问题，图片会被打包，而且路径也处理妥当。额外提供html的include子页面功能。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br><span class="line">&#x2F;&#x2F;或者使用yarn</span><br><span class="line">yarn add -D html-withimg-loader</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(htm|html)$/i</span>,</span><br><span class="line">     use:[ <span class="string">'html-withimg-loader'</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在终端中可以进行打包了。你会发现images被很好的打包了。并且路径也完全正确。</p><h3 id="Less文件打包和分离"><a href="#Less文件打包和分离" class="headerlink" title="Less文件打包和分离"></a>Less文件打包和分离</h3><ul><li>我们讲解一下Less文件如何打包和分离。Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。也就是说Less给我们枯燥单一的样式文件加入了编程机制，这让我们这些前端程序员很受用，所以在工作中大部分程序员都使用了Leess开发。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less less-loader</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">yarn add -D less less-loader</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(sa|sc|c|le)ss$/</span>,</span><br><span class="line">    use : [</span><br><span class="line">        MiniCssExtractPlugin.loader,</span><br><span class="line">        <span class="string">"css-loader"</span> ,</span><br><span class="line">        <span class="string">"less-loader"</span>,</span><br><span class="line">        <span class="string">"sass-loader"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">"css/common.css"</span></span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>配置好后，你会发现less被分离到了index.css文件里。当然sass同理，这里就不阐述了</p><h3 id="自动处理css3前缀问题"><a href="#自动处理css3前缀问题" class="headerlink" title="自动处理css3前缀问题"></a>自动处理css3前缀问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm -d install postcss-loader autoprefixer</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">yarn add -D postcss-loader autoprefixer</span><br></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(sa|sc|c)ss$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        MiniCssExtractPlugin.loader,</span><br><span class="line">        <span class="string">'css-loader'</span>,</span><br><span class="line">        <span class="string">'sass-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或webpack3中这样用</span></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span>, <span class="attr">options</span>: &#123; <span class="attr">importLoaders</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">            <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>postcss.config.js</strong><br>postCSS推荐在项目根目录（和webpack.config.js同级），建立一个postcss.config.js文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩分离出来的css"><a href="#压缩分离出来的css" class="headerlink" title="压缩分离出来的css"></a>压缩分离出来的css</h3><ul><li>要缩小输出，请使用诸如optimize-css-assets-webpack-plugin之类的插件。<br>设置Optimization.minimizer会覆盖webpack提供的默认值，因此请确保还指定一个JS最小化器：</li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//压缩js最小化器</span></span><br><span class="line"><span class="keyword">const</span> TerserJSPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123; <span class="comment">//优化项</span></span><br><span class="line">    minimizer: [<span class="keyword">new</span> TerserJSPlugin(&#123;&#125;), <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].css'</span>,</span><br><span class="line">      chunkFilename: <span class="string">'[id].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>], <span class="comment">//注意这里不能和style-loader一块使用MiniCssExtractPlugin.loader会将css抽离出来使用link引用</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><ul><li>我们打包完成以后无法将es6相关语法转换成es5的语法，那么就需要babel插件去辅助我们完成这个操作咯<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D babel-loader @babel&#x2F;core @babel&#x2F;preset-env</span><br><span class="line">&#x2F;&#x2F;@babel&#x2F;core babel核心模块</span><br><span class="line">&#x2F;&#x2F;@babel&#x2F;preset-env 转换的模块</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">  rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use:[&#123;</span><br><span class="line">            loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">            <span class="comment">// exclude: /(node_modules|bower_components)/,</span></span><br><span class="line">            options:&#123;</span><br><span class="line">              presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>当我们使用一下语法时候<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  a =<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们编译webpack会出错，会告诉你需要什么插件我们对应的进行配置就好了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add @babel&#x2F;plugin-proposal-class-properties (https:&#x2F;&#x2F;git.io&#x2F;vb4SL) to the &#39;plugins&#39; section of your Babel config to enable transformation.</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use:[&#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        <span class="comment">// exclude: /(node_modules|bower_components)/,</span></span><br><span class="line">        options:&#123;</span><br><span class="line">          presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">          plugins: [<span class="string">'@babel/plugin-proposal-class-properties'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>当然babel对一些公共的方法使用了非常小的辅助代码比如 _extend。 默认情况下会被添加到每一个需要它的文件中，可以通过引用 babel runtime 作为一个独立模块，来避免重复引入。<br><a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime/" target="_blank" rel="noopener">详细解释</a><br>注意：咱们使用es6，es7语法的时候经常需要webpack需要配置该插件哦<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @babel&#x2F;plugin-transform-runtime @babel&#x2F;runtime</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/(node_modules|bower_components)/</span>, <span class="comment">//不包含node_modules</span></span><br><span class="line">    include: path.resolve(__dirname,<span class="string">'src'</span>),  <span class="comment">//包含src下的进行es语法转换</span></span><br><span class="line">    use:[&#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options:&#123;</span><br><span class="line">          presets: [<span class="string">'@babel/preset-env'</span>],</span><br><span class="line">          plugins: [<span class="string">'@babel/plugin-proposal-class-properties'</span>,<span class="string">'@babel/plugin-transform-runtime'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>还有一些es7的语法是webpack4无法自动转译的比如说：<code>aaa.includes(&#39;a&#39;)</code>,这时候我们就需要<code>@babel-polyfill</code></li><li>@babel/preset-env默认只转译js语法，而不转译新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法(比如Object.assign)都不会转译。这时就必须使用@babel/polyfill(内部集成了core-js和regenerator)。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @babel&#x2F;polyfill</span><br></pre></td></tr></table></figure></li></ul><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></span><br></pre></td></tr></table></figure><p>或者<br><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不建议使用这种方式，可以采用上面那种方式按需加载，不然polyfill打包以后的文件会很大</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [<span class="string">"@babel/polyfill"</span>, <span class="string">"./app/js"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上关于babel官方还提供使用.babelrc配置文件的方式配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"@babel/env"</span>, &#123;</span><br><span class="line">      <span class="attr">"modules"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"targets"</span>: &#123;</span><br><span class="line">         <span class="attr">"chrome"</span>: <span class="string">"64"</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [[<span class="string">"@babel/plugin-transform-runtime"</span>, &#123;</span><br><span class="line">      <span class="attr">"useBuiltIns"</span>: <span class="literal">true</span></span><br><span class="line">      <span class="comment">// "polyfill": false</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消除没有用到的css"><a href="#消除没有用到的css" class="headerlink" title="消除没有用到的css"></a>消除没有用到的css</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm -d install purifycss-webpack purify</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">yarn add -D purifycss-webpack purify</span><br></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br><span class="line"><span class="keyword">const</span> PurifyCssPlugin = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>);</span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> extractTextPlugin(<span class="string">"css/index.css"</span>),</span><br><span class="line">    <span class="keyword">new</span> PurifyCSSPlugin(&#123;</span><br><span class="line">        <span class="comment">// Give paths to parse for rules. These should be absolute!</span></span><br><span class="line">        paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了。</p><p>注意：使用这个插件必须配合extract-text-webpack-plugin这个插件，这个插件在前边的课程已经讲解过了。如果你还不会请自学一下。</p><p>配置好上边的代码，我们可以故意在css文件里写一些用不到的属性，然后用webpack打包，你会发现没用的CSS已经自动给你删除掉了。在工作中记得一定要配置这个plugins，因为这决定你代码的质量，非常有用。</p><h3 id="js代码检测eslint"><a href="#js代码检测eslint" class="headerlink" title="js代码检测eslint"></a>js代码检测eslint</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D eslint eslint-loader</span><br></pre></td></tr></table></figure><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">   use:&#123;</span><br><span class="line">       loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">       options:&#123;</span><br><span class="line">         enforce: <span class="string">'pre'</span> <span class="comment">//前置，在之前先运行，post是后面的意思</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p><a href="https://eslint.org/demo" target="_blank" rel="noopener">eslintrc.json下载</a><br><code>Download .eslintrc.json file with this configuration</code>点击这项进行eslint规则下载，注意，这里生成的文件需要加”.”,下载后可以修改为<code>.eslintrc.json</code>，将此文件拷贝到根目录中即可<br><strong>总结</strong></p><ul><li>好了，这篇总结的比较多慢慢消化，主要就是利用webpack针对css/less/sass等css样式，以及图片，字体等加载引入，以及打包优化，将没用到的css进行剔除，以及将css在js或者html中进行抽取出来到单独的css文件中进行维护</li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【webpack】一步步的看webpack-3</title>
      <link href="/2020/06/24/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-3/"/>
      <url>/2020/06/24/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-3/</url>
      
        <content type="html"><![CDATA[<p>好啦，介绍完webpack到底是干什么的以后呢，我们需要进入正题了，这篇主要介绍webpack的几个重要的概念<strong>入口</strong>,<strong>出口</strong>，<strong>loader</strong>,<strong>插件plugins</strong>,<strong>模式</strong></p><a id="more"></a><blockquote><h3 id="入口-entry-point"><a href="#入口-entry-point" class="headerlink" title="入口(entry point)"></a>入口(entry point)</h3></blockquote><ul><li><p>指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中，<br>可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。<br>接下来我们看一个 entry 配置的最简单例子：<br><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>单个入口语法</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>  <span class="comment">//此写法是下面的写法简写</span></span><br><span class="line">  &lt;!-- entry: &#123;</span><br><span class="line">    main: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">  &#125; --&gt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><blockquote><p>当你向 entry 传入一个数组时会发生什么？向 entry 属性传入「文件路径(file path)数组」将创建“多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用。</p></blockquote></li><li><p>对象语法</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。</p></li><li><p>数组语法</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: [<span class="string">'./src/app.js'</span>,<span class="string">'./src/vendors.js'</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：上面关于对象和数组语法主要是面向多页面应用（MPA）的，在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事：使用 <a href="https://www.webpackjs.com/plugins/commons-chunk-plugin/" target="_blank" rel="noopener">CommonsChunkPlugin</a>（该插件主要作用就是通过将公共模块拆出来-多个入口情况下，最终合成的文件能够在最开始的时候加载一次） 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。</p><blockquote><h3 id="出口（output）"><a href="#出口（output）" class="headerlink" title="出口（output）"></a>出口（output）</h3></blockquote><ul><li>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：<br><strong>webpack.config.js</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//输出的路径,结合node的path模块</span></span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span> <span class="comment">//输出的文件名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>output.filename<br>这里单独说一下filename其他用法<br>此选项决定了每个输出 bundle 的名称。这些 bundle 将写入到 output.path 选项指定的目录下。</li></ul><p>对于单个入口起点，filename 会是一个静态名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename: <span class="string">"bundle.js"</span></span><br></pre></td></tr></table></figure><p>然而，当通过多个入口起点(entry point)、代码拆分(code splitting)或各种插件(plugin)创建多个 bundle，应该使用以下一种替换方式，来赋予每个 bundle 一个唯一的名称……</p><p>使用入口名称：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename: <span class="string">"[name].bundle.js"</span></span><br></pre></td></tr></table></figure><p>使用内部 chunk id</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename: <span class="string">"[id].bundle.js"</span></span><br></pre></td></tr></table></figure><p>使用每次构建过程中，唯一的 hash 生成，可以指定hash生成的长度如：[hash:8]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename: <span class="string">"[name].[hash].bundle.js"</span></span><br></pre></td></tr></table></figure><p>使用基于每个 chunk 内容的 hash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename: &quot;[chunkhash].bundle.js&quot;</span><br></pre></td></tr></table></figure><p>因为 hash 是项目构建的哈希值，项目中如果有些变动，hash 一定会变，比如说我改动了 utils.js 的代码，index.js 里的代码虽然没有改变，但是大家都是用的同一份 hash。hash 一变，缓存一定失效了，这样子是没办法实现 CDN 和浏览器缓存的。</p><p><a href="https://www.webpackjs.com/configuration/output/" target="_blank" rel="noopener">其他配置项</a></p><p>总结：上面是webpack的最基础的配置，输入和输出，当然这里引入了一个chunk的概念，chunk表示一个文件，默认情况下webpack的输入是一个入口文件，输出也是一个文件，这个文件就是一个chunk，chunkId就是产出时给每个文件一个唯一标识id，chunkhash就是文件内容的md5值，name就是在entry中指定的key值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        collection: <span class="string">'./src/main.js'</span>     <span class="comment">// collection为chunk的名字，chunk的入口文件是main.js</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'./dist/js'</span>,</span><br><span class="line">        filename: <span class="string">'[name].[chunkhash].[hash:8].js'</span>   <span class="comment">// 输出到dist/js目录下，以collection+chunk内容的md5值作为输出的文件名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上输入输出会出现几个概念，下面做一下总结:</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">    main:[<span class="string">'./src/main.js'</span>,<span class="string">'./src/test.js'</span>],</span><br><span class="line">    other:[<span class="string">'./src.other.js'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">output:&#123;</span><br><span class="line">    filename:<span class="string">"[name].bundle.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.js中引入了gloabl.css；</p><ul><li><p>module</p><ul><li>main.js、test.js、other.js、global.css都是module</li></ul></li><li><p>entry-point</p><ul><li>main.js、test.js、other.js</li></ul></li><li><p>chunk</p><ul><li>main</li><li>other</li></ul></li><li><p>bundle</p><ul><li>main.bundle.js</li><li>other.bundle.js<br>entry的两个key对应两个chunk，最终会输出两个bundle；main.js、test.js、other.js都是entry-point</li></ul></li></ul><blockquote><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3></blockquote><ul><li>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。<br>本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</li></ul><p>在更高层面，在 webpack 的配置中 loader 有两个目标：</p><ul><li>test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。</li><li>use 属性，表示进行转换时，应该使用哪个 loader。</li></ul><p><strong>webpack.config.js</strong><br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><br>  以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息：</p><blockquote><p>“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。”<br>  重要的是要记得，在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules。然而，在定义错误时 webpack 会给出严重的警告。为了使你受益于此，如果没有按照正确方式去做，webpack 会“给出严重的警告”</p></blockquote><blockquote><h3 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h3></blockquote><ul><li>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。<br>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</li></ul><p>  <strong>webpack.config.js</strong><br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><br>  webpack 提供许多开箱可用的插件！查阅我们的<a href="https://www.webpackjs.com/plugins/" target="_blank" rel="noopener">插件列表</a>获取更多信息。</p><blockquote><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3></blockquote><ul><li>通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>或<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --mode=production</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>development</td><td>会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。</td></tr><tr><td>production</td><td>会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin.</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【webpack】一步步的看webpack-2</title>
      <link href="/2020/06/23/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-2/"/>
      <url>/2020/06/23/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-2/</url>
      
        <content type="html"><![CDATA[<p>前面先接触了一下webpack这个东西，那这个webpack到底是干什么的，为什么要用webpack呢？这篇文章主要讲一讲为什么要用webpack</p><a id="more"></a><blockquote><p>官方的概念</p></blockquote><ul><li>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</li></ul><p><strong>这是说的什么意思呢？其中官方的话有主要的两个概念：1. 打包，2.模块</strong></p><h3 id="为什么要打包"><a href="#为什么要打包" class="headerlink" title="为什么要打包"></a>为什么要打包</h3><p>然后让我们从一个html页面说起，下面的代码可以看到，我在html页面中通过script标签引入了3个JavaScript文件a.js，b.js和c.js，每个文件中分别定义了一个函数并导出（export）给外部用。并且它们之间有一定的依赖关系，c.js依赖于b.js，b.js依赖于a.js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|- index.html</span><br><span class="line">|- main.css</span><br><span class="line">| - a.js</span><br><span class="line">| - b.js</span><br><span class="line">| - c.js</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.html</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;&lt;link href&#x3D;&quot;main.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;hello world&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;a.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;b.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;c.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">export default function () &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">import add from &#39;a&#39;;</span><br><span class="line">export default function (c, d) &#123;</span><br><span class="line">  return c &#x2F; add(c, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; c.js</span><br><span class="line">import percentage from &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">export default function (e, f) &#123;</span><br><span class="line">  console.log(percentage(e, f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为有3个js文件，所以浏览器需要发送三次http 请求来获取这三个文件，然后依次执行其中的代码，如果其中有一个文件因为网络问题而延误了时间，那么整个页面的显示也会被延误。3个文件还好，而当我们的项目逐渐变大，有几十个到上百个JavaScript文件的时候，那问题会更严重，不但有延迟问题，还会遇到很难维护的问题 — 想想如何维护上百个文件的依赖关系？</p><p>这时候你会想，是不是我把所有JavaScript文件合成一个文件就好了呢？没错，我们确实可以这样做，这样就减少了http请求数量，让我们的页面加载和显示更快。不过这个合并的阶段是在开发完成之后才进行的，也就是说开发阶段我仍然是有a.js，b.js和c.js等等这些文件的，这样才好开发和维护，因为如果开发阶段就合并的话，就相当于我基于一个可能上万行的文件进行开发，这样的代码是没法维护的。</p><p>在开发后完成的这个合并的过程就是打包，这样你就明白为什么要打包了吧。webpack在打包过程中，会分析各个文件之间的依赖关系，然后生成一个依赖图并用文件的形式保存下来，未来浏览器运行代码的时候就可以读取这个文件，就知道了各个代码块之间的关联以及如何调用了。<br><img src="https://upload-images.jianshu.io/upload_images/1955691-271af3fea8c87e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1034/format/webp" alt="webpack"><br>上面只是用JavaScript文件来举例子，实际上webpack可以支持多种文件类型的打包，如css，sass，jpg，svg等等。</p><h3 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h3><p>上面的3个文件，每个文件都可以看做是一个模块，在JavaScript中可以把模块看做是一堆代码，这堆代码可以被复用，执行某个具体的操作，从表象上来看就是一个模块就是一个文件，其中包含了export这样的关键字用来将模块的功能导出给外部用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">import add from &#39;a&#39;;</span><br><span class="line">export default function (c, d) &#123;</span><br><span class="line">  return c &#x2F; add(c, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从b.js这个文件/模块中就可以看出，首先从a模块中导入了一个函数，然后定义了一个新的函数，并通过export 导出。<br><a href="https://www.webpackjs.com/concepts/modules/" target="_blank" rel="noopener">官方讲解模块</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>打包是webpack最核心的功能，webpack其它所有的功能都是为了让打包这个功能更好。我们从一个简单的html页面介绍了通过webpack对模块进行打包，既保留了单个模块的可维护性，又减少了页面的http请求，减少了页面加载时间，从而增加了页面的显示速度，让整个应用的体验更好。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【webpack】一步步的看webpack-1</title>
      <link href="/2020/06/22/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-1/"/>
      <url>/2020/06/22/webpack/%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%9A%84%E7%9C%8Bwebpack-1/</url>
      
        <content type="html"><![CDATA[<p>本文主要从最新的webpack4入手，慢慢的学习webpack的相关知识点，进行汇总</p><a id="more"></a><blockquote><p>第一次轻轻的接触</p></blockquote><ul><li><p><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">webpack官网地址</a></p></li><li><p><a href="https://github.com/webpack/webpack" target="_blank" rel="noopener">github地址</a></p><blockquote><p>使用webpack前提条件</p></blockquote><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p><code>node</code>,使用官方最新版本即可，由于webpack这里使用的是4，不再支持node v4一下的版本，所以node需要安装V4+的版本，<br>这是因为新的webpack和附属插件使用了es6的语法，v4版本对es6不是很到位，所以，就不伺候了</p></li><li><h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a><strong>本地安装</strong></h3><p>最新的webpack版本是：<code>v4.43.0</code></p></li><li><p>要安装最新版本或特定版本，请运行以下命令之一：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//这里需要安装webpack-cli，官方给出webpack4以上版本需要使用到`webpack-cli`</span><br><span class="line">cnpm install --save-dev webpack webpack-cli //yarn add -D webpack webpack-cli</span><br><span class="line">cnpm install --save-dev webpack@&lt;version&gt;</span><br></pre></td></tr></table></figure><p>当你在本地安装 webpack 后，你能够从 node_modules/.bin/webpack 访问它的 bin 版本。<br>使用<code>./node_modules/.bin/webpack</code>运行即可</p><blockquote><ul><li>由于还需要访问node_modules,这里我们使用linux命令指定别名进行运行webpack <code>alias webpack=&quot;node_modules/.bin/webpack&quot;</code></li><li>windows的话可以暂时放到环境变量中</li></ul></blockquote></li><li><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a><strong>全局安装</strong></h3><p>以下的 NPM 安装方式，将使 webpack 在全局环境下可用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --global webpack</span><br></pre></td></tr></table></figure><blockquote><p>不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。</p></blockquote></li></ul></li></ul><blockquote><p>跑一个小例子感受一下</p></blockquote><p>src/index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import bar from &#39;.&#x2F;bar&#39;;</span><br><span class="line"></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p>src/bar.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function bar() &#123;</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> webpack.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">      path: path.resolve(__dirname, &#39;dist&#39;),</span><br><span class="line">    filename: &#39;bundle.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>page.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;script src&#x3D;&quot;dist&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>然后在命令行运行 <code>webpack</code> 就会创建 <code>bundle.js</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Version: webpack 4.43.0</span><br><span class="line">Time: 82ms</span><br><span class="line">Built at: 2020&#x2F;06&#x2F;22 下午5:20:25</span><br><span class="line">    Asset       Size  Chunks             Chunk Names</span><br><span class="line">bundle.js  951 bytes       0  [emitted]  main</span><br><span class="line">Entrypoint main &#x3D; bundle.js</span><br><span class="line">[0] .&#x2F;src&#x2F;index.js + 1 modules 72 bytes &#123;0&#125; [built]</span><br><span class="line">    | .&#x2F;src&#x2F;index.js 32 bytes [built]</span><br><span class="line">    | .&#x2F;src&#x2F;bar.js 40 bytes [built]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里会报WARNING，是webpack4后新增了&#96;development&#96;、&#96;production&#96;和&#96;none&#96;环境变量的指定，既然官方推荐了我们可以加一下</span><br><span class="line">&#x2F;&#x2F;.&#x2F;node_modules&#x2F;.bin&#x2F;webpack --mode production</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WARNING in configuration</span><br><span class="line">The &#39;mode&#39; option has not been set, webpack will fallback to &#39;production&#39; for this value. Set &#39;mode&#39; option to &#39;development&#39; or &#39;production&#39; to enable defaults for each environment.</span><br><span class="line">You can also set it to &#39;none&#39; to disable any default behavior. Learn more: https:&#x2F;&#x2F;webpack.js.org&#x2F;configuration&#x2F;mode&#x2F;</span><br></pre></td></tr></table></figure><p><a href="https://www.webpackjs.com/guides/getting-started/#%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">官方教程</a></p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【随笔】BIC工具</title>
      <link href="/2020/06/18/article/BIC%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/06/18/article/BIC%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<ul><li>生活中批评员工的机会会有很多，那么有没有人因为批评的技巧有问题，导致你想批评员工，借此机会帮助员工，结果对方越来越糟糕了，或者对方跟你对着干，对方情绪越来越坏？我们在批评的时候最大的难点在情绪管理。很多人跟被批评的人说过这样的话：“我这个人是对事不对人。”但是真的能做到对事不对人吗？老板有时候还会补充：“我的确是对事不对人，但是事都是人做的。”<a id="more"></a>对事不对人是一个境界，这是东方式的管理，但是管理者没法做到。西方的办法一定是给你一个工具，用这个工具来讲话，你就能够做到对事不对人。这个工具叫做BIC（Behavior has impact which leads to consequence, 你的某一个行为，产生了什么样的影响，从而会导致什么样的后果？），这个工具就叫做BIC。</li></ul><p>第一部分：B（事实）</p><p>首先B代表当我要求你说出对方一个错误的行为的时候，我们有两种表达方式，一种叫做事实，一种叫做观点。那么当我们要说出对方一个错误的行为的时候，应该说事实还是应该说观点？大家都认为应该说事实，但是经常出问题在哪呢？我们很多管理者分不清事实和观点，我们经常把自己的观点当作是事实，比如：“小张，你最近的工作状态不太好。”这是一个观点，你如果是小张的话，你听了会觉得不高兴，再换一个，说：“我觉得你做工作不够投入。”这也是观点，让人听了很不舒服。再比如：“小张你最近经常迟到。”仍然还是观点。如果你是小张，你被别人说经常迟到很不爽，所以当加入“经常”这个词的时候，把一个事实变成了一个观点，因为这代表着我不喜欢你。</p><p>那么什么叫事实？比如：“小张，我看了一下考勤记录，上周你有三个迟到记录。今天早上咱们九点钟上课，你进教室的时候是9点半。”这是一个事实对吗？我有没有说你是一个坏员工？我有没有说你为什么迟到的？没有，我只是看到了这么一个现象而已，所以当简单的讲出一个现象的时候，你发现对方的情绪不容易起伏，而当你说你怎么上课这么喜欢迟到，对方情绪马上就起来了，你是不是不重视我的课呢？推理阶梯就已经出现了。所以我们平常跟人谈话的时候，是什么让我们的谈话变得很艰难？是我们一张口就已经伤了人了，所以一定要能够学会把你想要表达的观点改成事实。</p><p>第二部分：I（影响）</p><p>接下来I叫做影响，影响就是短期的，局部的就能够看到的负面结果，一定要跟这个人自身的利益挂钩。为什么要跟这个人自身的利益挂钩呢？因为他会重视。更重要的是一个人长期犯错，最终会影响到的一定是他自己，这是原理。我们跟员工谈话的唯一目的是为了帮助他，你得挽回他，帮助他，所以既然你要表达，你想帮他，就得让他感受到你想帮他，怎么才能让他感受到你想帮他呢？你可以说：“这样下去话，我担心咱们的班风会涣散，不利于咱们这次培训的效果，而且也不利于你在咱班的形象。”这是跟他的利益挂钩，这个叫做BIC。</p><p>到此为止，我没有说过你迟到的原因，没有给他扣过任何帽子，所以接下来我们就要去问他，为什么会出现这样的情况，允许员工去解释，所以BIC能够有效的去把你的观点以及你对这件事未来的担心讲出来。</p><p>2008年我第一次代表IBM去海尔上这个课程，IBM派了一些人在后边听我们讲课，那天我给海尔上的是团队那部分内容，带大家玩团队的游戏，玩完了以后大家很开心，都觉得很棒，给我的反馈很不错，我觉得很好，第一次上课就成功了。</p><p>晚上回到酒店， IBM的人打电话给我，他说：“樊老师，请问你有没有时间？关于今天上午上课有些内容，我想给你做一个反馈。”我一听这个我就知道我上课过程中有问题了。他接着说：“樊老师，今天早上你在讲团队那部分的时候，你是这样说的……”他把我的原话记了下来，然后给我念了一遍。这是事实，事实就是一个发生过的事儿。他把我的原话重复了一遍，这时候我不会生气，因为对方说的是我的原话。他把原话给念完了，然后接着说：“我观察到学生在做游戏的时候，并没有体会到您说的这几点。您把这个东西讲给他们听，会影响到他们对于已有的知识点的接收。”这是对这个班的影响，IBM的人认为我讲多了，讲的不是游戏当中体会到的东西，影响到学员对知识点的接收了。</p><p>第三部分：C（后果）</p><p>接下来到C了，也就是结论。IBM的人接着说：“这样下去的话，我们担心这门课程在中国的传播会变味，而且也不利于您成为一名优秀的facilitator（引导师）。” 不利于课程在中国传播这个结论是跟全局挂钩，不利于我我成为优秀的引导师是跟我挂钩。最后说：“那么樊老师，我想听听您的意见。”这时候我能有什么意见？人家说的很客观，而且也很诚恳。我回应到：“你说的有道理，我确实还是这个习惯，喜欢多讲，没有观察学生的反应，你这个提醒的特别到位，我回头一定会注意，我要更多的提问，观察学生的感受。”他说：“不，樊老师，您的讲课是很有特色的，你讲的真的挺好的，学生的反应也很好，所以如果您有什么独特的设计的话，请您一定告诉我们，如果你想改这门课程，我们可以给美国总部打报告，可以改这门课。”我说：“不用改课程，是我应该改变。”，我们俩客气了半天，最后结束。</p><p>通过这次反馈，我知道我讲课效果还不错，也很开心的去注意做facilitation。所以过了很多年以后，我们再一次见面，我还跟他说起这件事，感谢当年他对我的帮助。经过了这么一次负面反馈，我们俩的关系没有变得更糟糕，反倒拉近了，因为你知道人家做这个事是为了我，为了整个的团队，而且人家的水平很高，一般的学生听不出来，人家是高手，一听都听明白了，所以我就对人很尊敬，然后保持良好的关系，这就告诉我们，并不是所有的负面反馈都会伤害人。</p><p>良好的负面反馈一样会带来扩大公开象限的效果，会让员工觉得老板说话真有道理。IBM这样老牌的帝国公司，可怕在他们所有的人都是这样说话的，不是只有这总监一个人会这样说话。总监后来被挖到埃森哲就走了，换了一个年轻人上来接着干也是一样。他们入职第一天所受到的训练就是这些东西。表扬人就是二级反馈。批评人就BIC，开会就六顶思考帽，头脑风暴，布置工作说五遍，他永远有一大堆的方法放在那，所以这些人都被规规矩矩地塑造成了职业经理人。谁走了他都能够接着干，所以你们跟这些国外公司打交道，你会发现跟他们的老总说话和他们底下人说话感觉差别不大，因为都是套路。我们中国的企业从小做到大，这个是蛮快的，从无到有，从小到大是蛮快，但是从大做到巨大，是非常困难的。因为我们做到大，还能够勉强靠这些人的这种力量在维持，但是一旦做到超大，做到像可口可乐这样的规模就不行，所以我们的企业做到强大还有很长的距离，标准化是非常重要的一个过程。</p><p>不是要把大家的思想禁锢起来标准化，而是我们的沟通模式。沟通模式一旦标准化以后，你发现就跟早上我们开会一样，就会觉得很省劲，所以把BIC一定要学会。</p><p>作者：刘思彤班长<br>链接：<a href="https://www.jianshu.com/p/0c7ba0c06939" target="_blank" rel="noopener">https://www.jianshu.com/p/0c7ba0c06939</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【随笔】人生随笔</title>
      <link href="/2020/06/12/article/%E4%BA%BA%E7%94%9F%E9%9A%8F%E7%AC%94/"/>
      <url>/2020/06/12/article/%E4%BA%BA%E7%94%9F%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<ul><li><p>人的一生或多或少都会经历各样的选择，不同的选择决定着走向不同的道路</p><a id="more"></a><p> 人生这一辈子其实很短暂，现在的我已经快本三了，经历了困惑，做了很多错误的选择，如果有机会让我重新来过，那会不会是不一样的人生呢？<br>在刚出生，到上大学，其实这段时间是无法去主动选择的，大部分的人都是经历了一样的过程，上学，学习，写作业等等，其实也是人生必经阶段，当然出生的环境会影响人的人生轨迹，但是所有人生下来的环境是自己无法去选择的，只能去接受，那么当自己成年，或者以后有了自己的生活，那会面临这无数的选择，据说人的一天会面临4万多次选择，所有的事情在你不经意间你已经做出了选择，那么在点点滴滴就会影响着自己的人生道路，人生本身就是有起有落，人生不能重来，之前的选择都已经作废，接下来的选择才能决定你人生的走向，至于接下来的路怎么走，怎么选择，看你自己！<br>结婚，生子，工作将是接下来的走向，但是这个走向到底是越走越好，还是越走越不开心，在人生的岔路口要谨慎选择，往往在不经意间做了错误的选择，则会走向你不想面对的人生，人生就像选择题，或者是一场赌注，谁也不知道做了选择以后会发生什么，这样的人生才有意思不是么，很简单一个道理，怎么活看自己，怎么选择不一样的人生看自己，所以有些事情是自己可以决定也可以选择的，只是看你愿意不愿意，加油吧，骚年～</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes基础</title>
      <link href="/2020/06/11/kubernetes/kubernetes1/"/>
      <url>/2020/06/11/kubernetes/kubernetes1/</url>
      
        <content type="html"><![CDATA[<ul><li>主要说明Kubernetes中每个控制器说明和使用场景</li></ul><a id="more"></a><blockquote><h3 id="什么是控制器"><a href="#什么是控制器" class="headerlink" title="什么是控制器"></a>什么是控制器</h3></blockquote><ul><li>Kubernetes 中内建了很多 controller(控制器)，这些相当于一个状态机，用来控制 Pod 的具体状态和行为</li></ul><blockquote><h3 id="控制器类型"><a href="#控制器类型" class="headerlink" title="控制器类型"></a>控制器类型</h3></blockquote><ul><li>ReplicationController 和 ReplicaSet Deployment</li><li>DaemonSet</li><li>StateFulSet</li><li>Job/CronJob</li><li>Horizontal Pod Autoscaling</li></ul><blockquote><h3 id="ReplicationController-和-ReplicaSet"><a href="#ReplicationController-和-ReplicaSet" class="headerlink" title="ReplicationController 和 ReplicaSet"></a>ReplicationController 和 ReplicaSet</h3></blockquote><ul><li>ReplicationController(RC)用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退<br>出，会自动创建新的 Pod 来替代;而如果异常多出来的容器也会自动回收;<br>在新版本的 Kubernetes 中建议使用 ReplicaSet 来取代 ReplicationController 。ReplicaSet 跟<br>ReplicationController 没有本质的不同，只是名字不一样，并且 ReplicaSet 支持集合式的 selector;</li></ul><blockquote><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3></blockquote><ul><li>Deployment 为 Pod 和 ReplicaSet 提供了一个声明式定义 (declarative) 方法，用来替代以前的 ReplicationController 来方便的管理应用。典型的应用场景包括;<ul><li>定义 Deployment 来创建 Pod 和 ReplicaSet 滚动升级和回滚应用</li><li>扩容和缩容</li><li>暂停和继续 Deployment</li></ul></li></ul><blockquote><h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><p>DaemonSet 确保全部(或者一些)Node 上运行一个 Pod 的副本。当有 Node 加入集群时，也会为他们新增一个<br>Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod 使用 DaemonSet 的一些典型用法:</p></blockquote><ul><li>运行集群存储 daemon，例如在每个 Node 上运行 <code>glusterd</code> 、 <code>ceph</code></li><li>在每个 Node 上运行日志收集 daemon，例如 <code>fluentd</code> 、 <code>logstash</code></li><li>在每个 Node 上运行监控 daemon，例如 <strong><code>Prometheus Node Exporter、</code>collectd` 、</strong>Datadog 代理<strong>、 **New Relic 代理</strong>，或 <strong>Ganglia</strong> <code>gmond</code></li></ul><blockquote><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3></blockquote><ul><li>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束</li></ul><blockquote><h3 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h3></blockquote><ul><li>Cron Job 管理基于时间的 Job，即:<ul><li>在给定时间点只运行一次</li><li>周期性地在给定时间点运行</li></ul></li></ul><p><strong>使用前提条件:</strong>当前使用的 Kubernetes 集群，版本 &gt;= 1.8(对 CronJob)。对于先前版本的集群，版本 &lt; 1.8，启动 API Server时，通过传递选项 <code>--runtime-config=batch/v2alpha1=true</code> 可以开启 batch/v2alpha1 API**</p><ul><li>典型的用法如下所示: <ul><li>在给定的时间点调度 Job 运行</li><li>创建周期性运行的 Job，例如:数据库备份、发送邮件</li></ul></li></ul><blockquote><h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p>StatefulSet 作为 Controller 为 Pod 提供唯一的标识。它可以保证部署和 scale 的顺序<br>StatefulSet是为了解决有状态服务的问题(对应Deployments和ReplicaSets是为无状态服务而设计)，其应用 场景包括:</p></blockquote><ul><li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li><li>稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service(即没有 Cluster IP的Service)来实现 </li><li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行(即从0到 N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态)，基于init containers来实 现</li><li>有序收缩，有序删除(即从N-1到0)</li></ul><blockquote><h3 id="Horizontal-Pod-Autoscaling"><a href="#Horizontal-Pod-Autoscaling" class="headerlink" title="Horizontal Pod Autoscaling"></a>Horizontal Pod Autoscaling</h3></blockquote><ul><li>应用的资源使用率通常都有高峰和低谷的时候，如何削峰填谷，提高集群的整体资源利用率，让service中的Pod 个数自动调整呢?这就有赖于Horizontal Pod Autoscaling了，顾名思义，使Pod水平自动缩放</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zz胖博客大改版</title>
      <link href="/2020/06/10/hello-world/"/>
      <url>/2020/06/10/hello-world/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近工作不是很忙，对自己的博客来个大升级，更方便维护和阅读</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[Node] nodejs-mongoose</title>
      <link href="/2019/05/30/node/nodejs-mongoose/"/>
      <url>/2019/05/30/node/nodejs-mongoose/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs-mongoose"><a href="#nodejs-mongoose" class="headerlink" title="nodejs-mongoose"></a>nodejs-mongoose</h2><h3 id="关于mongoose返回对象的处理"><a href="#关于mongoose返回对象的处理" class="headerlink" title="关于mongoose返回对象的处理"></a>关于mongoose返回对象的处理</h3><p><a href="https://www.jianshu.com/p/e78fa39aa43f" target="_blank" rel="noopener">看这里</a></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] Express-路由 </title>
      <link href="/2019/05/29/Express/Express-%E8%B7%AF%E7%94%B1/"/>
      <url>/2019/05/29/Express/Express-%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express-路由"></a>Express-路由</h2><ul><li>什么是路由<br>简单磊说,咱们都用过路由器,那就是路由,比如门牌号地址,这也是路由,最简单的,url路径,其实就是路由<a id="more"></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] Express静态服务 </title>
      <link href="/2019/05/29/Express/Express%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/05/29/Express/Express%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Express静态服务"><a href="#Express静态服务" class="headerlink" title="Express静态服务"></a>Express静态服务</h2><ul><li><p>很简单看下面代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公开指定目录,下列方式就可以访问项目下public下的文件了</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 个人推荐咯</span></span><br><span class="line"><span class="comment"> * 当以/public/开头请求路径, 就回去./public/目录中查找对应的资源,也就是第一个参数是请求路径,第二个是对应的文件位置相对路径</span></span><br><span class="line"><span class="comment"> * 访问路径 http://localhost:3000/public/xxx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">app.use(<span class="string">'/public/'</span>,express.static(<span class="string">'./public/'</span>))</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"><span class="comment">//当省略第一个参数的时候,则可以通过省略/public/的方式访问,也就是直接访问/跟路径,没有代表的就是/</span></span><br><span class="line"><span class="comment">//访问路径 http://localhost:3000/xxx</span></span><br><span class="line">app.use(express.static(<span class="string">'./public/'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问路径 http://localhost:3000/a/xxx</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/a/'</span>,express.static(<span class="string">'./public/'</span>))</span><br></pre></td></tr></table></figure></li><li><p>剩下的看文档咯,很简单 <a href="http://www.expressjs.com.cn/starter/static-files.html" target="_blank" rel="noopener">文档</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] Express简介 </title>
      <link href="/2019/05/29/Express/Express%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/05/29/Express/Express%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Express简介"><a href="#Express简介" class="headerlink" title="Express简介"></a>Express简介</h2><ul><li>原生的node中http在某些方面已经不足以应对我们的开发需求,所以我们就需要使用框架来加快我们开发效率了,框架目的就是开发效率<a id="more"></a></li><li>所以<code>Express</code>终于来啦,当然现在出了新的框架<code>Koa2</code>,以后我会继续加入这一部分啦,最近先整理一下<code>Express</code>的内容</li><li><a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">Express官网</a></li><li>好吧,这个框架的作者<a href="">https://github.com/tj</a>,这哥们还是很牛逼啊</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] Express-HelloWord </title>
      <link href="/2019/05/29/Express/Express-HelloWord/"/>
      <url>/2019/05/29/Express/Express-HelloWord/</url>
      
        <content type="html"><![CDATA[<h2 id="Express-HelloWord"><a href="#Express-HelloWord" class="headerlink" title="Express-HelloWord"></a>Express-HelloWord</h2><h3 id="来吧-万事开头helloword"><a href="#来吧-万事开头helloword" class="headerlink" title="来吧,万事开头helloword"></a>来吧,万事开头helloword</h3><a id="more"></a><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>创建目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir myapp</span><br><span class="line">$ cd myapp</span><br></pre></td></tr></table></figure></li><li>初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure></li><li>安装<code>Express</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express --save</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>创建app.js文件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">//创建server ,node原生是http.createServer()</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">//公开指定目录,下列方式就可以访问项目下public下的文件了</span></span><br><span class="line">app.use(<span class="string">'/public/'</span>,express.static(<span class="string">'./public/'</span>))</span><br><span class="line"><span class="comment">//当服务器收到get请求时,路径为/的时候会调用这个方法</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">'hello express'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"server is running:"</span>+<span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>运行 node app.js</p></blockquote><h3 id="修改完代码自动重启-热加载"><a href="#修改完代码自动重启-热加载" class="headerlink" title="修改完代码自动重启,热加载"></a>修改完代码自动重启,热加载</h3><blockquote><p>简单直接一个工具<code>nodemon</code></p></blockquote><ul><li>安装<br><code>cnpm install --global nodemon</code></li><li>查看是否安装成功<br><code>nodemon --version</code></li><li>使用<br><code>nodemon app.js</code><blockquote><p>这样修改完js文件它就会自动加载啦,不用每次重启啦</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] nodejs-其他成员</title>
      <link href="/2019/05/29/node/nodejs-%E5%85%B6%E4%BB%96%E6%88%90%E5%91%98/"/>
      <url>/2019/05/29/node/nodejs-%E5%85%B6%E4%BB%96%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs-其他成员"><a href="#nodejs-其他成员" class="headerlink" title="nodejs-其他成员"></a>nodejs-其他成员</h2><blockquote><p>除了<code>require</code>、<code>exports</code> 等相关api之外，还有两个特殊的成员</p></blockquote><ul><li><code>__dirname</code>:<strong>动态获取</strong>可以获取当前文件模块所属目录的绝对路径</li><li><code>__filename</code>:<strong>动态获取</strong>可以获取当前文件的绝对路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;home&#x2F;zzp&#x2F;express-demo-project    &#x2F;&#x2F;__dirname</span><br><span class="line">&#x2F;home&#x2F;zzp&#x2F;express-demo-project&#x2F;demo.js &#x2F;&#x2F;__filename</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="有啥好处呢？"><a href="#有啥好处呢？" class="headerlink" title="有啥好处呢？"></a>有啥好处呢？</h4><blockquote><p>在文件操作中，使用相对路径是不可靠的，因为在Node中文件操作的路径被设计为相对与执行node命令所处的路径<br>所以为了解决这个问题，很简单，将相对路径变为绝对路径<br>所以例子来咯</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readfile(path.join(__dirname,<span class="string">'./a.txt'</span>),<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>所以强烈要求大家，以后操作相对路径的时候，都要用上面说的动态路径的方式哦<br>当然<code>require</code>中的相对路径是不受影响的哈，模块中的路径标识就是相对于当前文件模块，不受执行node命令所处路径的影响</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] nodejs-path</title>
      <link href="/2019/05/28/node/nodejs-path/"/>
      <url>/2019/05/28/node/nodejs-path/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs-path"><a href="#nodejs-path" class="headerlink" title="nodejs-path"></a>nodejs-path</h2><h3 id="做什么用的"><a href="#做什么用的" class="headerlink" title="做什么用的"></a>做什么用的</h3><ul><li>专门用来操作路径的</li><li>具体的函数看这里吧<a href="http://nodejs.cn/api/path.html" target="_blank" rel="noopener">nodejs-path</a><a id="more"></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] npm与package.json</title>
      <link href="/2019/05/24/node/npm%E4%B8%8Epackage.json/"/>
      <url>/2019/05/24/node/npm%E4%B8%8Epackage.json/</url>
      
        <content type="html"><![CDATA[<h2 id="npm与package-json"><a href="#npm与package-json" class="headerlink" title="npm与package.json"></a>npm与package.json</h2><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><ul><li>我们建议每一个项目都要有一个<code>package.json</code>文件</li><li>package.json 包描述文件(包的说明书)<ul><li>可以描述自己的项目依赖了哪些第三方包</li><li><code>--save</code> 放在包名之前和之后都可以,会保存<code>dependencies</code>依赖项</li><li><code>dependencies</code> 依赖的意思</li></ul></li><li><code>package.json</code> 可以通过命令 <code>npm init</code>方式创建,过程是以向导方式一步步设置,这个就不说啦,傻瓜式的呢,要是真是傻瓜的话,那就回车回车啦!<blockquote><p>生成以下文件</p></blockquote><a id="more"></a><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"npmtest"</span>, <span class="comment">//项目名称</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,<span class="comment">//版本号</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,<span class="comment">//描述</span></span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,<span class="comment">//项目主入口</span></span><br><span class="line">  <span class="attr">"scripts"</span>: &#123; <span class="comment">//scripts脚本</span></span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>, <span class="comment">//作者</span></span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span> <span class="comment">//证书</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>安装个jquery包试一下<br>运行 <code>npm install jquery --save</code></p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"npmtest"</span>, <span class="comment">//项目名称</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,<span class="comment">//版本号</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,<span class="comment">//描述</span></span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,<span class="comment">//项目主入口</span></span><br><span class="line">  <span class="attr">"scripts"</span>: &#123; <span class="comment">//scripts脚本</span></span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>, <span class="comment">//作者</span></span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>, <span class="comment">//证书</span></span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123; <span class="comment">//依赖</span></span><br><span class="line">    <span class="attr">"jquery"</span>: <span class="string">"^3.4.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总的来说这个<code>package.json</code>有啥用呢,其实简单来说,当你安装完包以后会生成<code>node_modules</code>文件夹,当你删除这个文件夹以后,可以直接在命令行运行<code>npm install</code> 他就会根据<code>package.json</code>中配置的依赖,自动安装了,不会出现找不到安装的包</p></blockquote></li></ul><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><ul><li><a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm网站</a>,这个就相当于dockerhub官方的私服,maven的资源仓库,也就是有自己的第三方包也可以发布到上面</li><li>常用命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm --version &#x2F;&#x2F;查看版本</span><br><span class="line">npm install --global npm &#x2F;&#x2F;升级npm版本</span><br></pre></td></tr></table></figure></li><li><code>npm init</code> //初始化<code>package.json</code><ul><li><code>npm init -y</code> //跳过向导,快速生成</li></ul></li><li><code>npm install 包名</code>  //只下载<ul><li><code>npm i 包名</code> //简写</li></ul></li><li><code>npm install --save 包名</code> //下载并且保存依赖到<code>package.json</code><ul><li><code>npm install -S 包名</code></li></ul></li><li><code>npm uninstall --save 包名</code> //删除依赖删除包<ul><li><code>npm un -S 包名</code> //简写</li></ul></li><li><code>npm help</code> //查看帮助</li></ul><blockquote><p>当然啦,npm你运行一下会发现,下载超级慢的,因为要翻墙,所以出现了<code>cnpm</code>,大家可以用<code>cnpm</code>命令也一样的,当然最近新出了一些其他的比如说<code>yarn</code>,都类似,看大家使用咯,以后会整理<code>yarn</code>方面的,敬请期待吧</p></blockquote><ul><li><code>global</code>代表全局下的安装,以后使用在哪个项目中都可以使用到<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global cnpm</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] js代码风格代码规范</title>
      <link href="/2019/05/23/node/js%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2019/05/23/node/js%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="js代码风格代码规范"><a href="#js代码风格代码规范" class="headerlink" title="js代码风格代码规范"></a>js代码风格代码规范</h2><blockquote><p>常见的规范:<a href="https://standardjs.com/" target="_blank" rel="noopener">JavaScript Standard Style</a><br><a href="https://www.ctolib.com/mip/getjll-JavaScript-Style-Guide.html" target="_blank" rel="noopener">Airbnb JavaScript Style</a></p></blockquote><a id="more"></a><h2 id="无分号代码风格"><a href="#无分号代码风格" class="headerlink" title="无分号代码风格"></a>无分号代码风格</h2><blockquote><p>当你采用了无分号代码风格的时候,只要注意一下情况,就不会有问题</p></blockquote><ul><li>当一行代码是以 (  [  `  开头的时候,则在前面不上一个分号以免语法错误</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] nodejs-exports</title>
      <link href="/2019/05/23/node/nodejs-exports/"/>
      <url>/2019/05/23/node/nodejs-exports/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs-exports"><a href="#nodejs-exports" class="headerlink" title="nodejs-exports"></a>nodejs-exports</h2><ul><li>简单来说exports就是导出</li><li>对于希望可以被其他模块访问的成员,我们就需要把这些公开的成员都挂载到exports接口对象中就可以了<blockquote><p>导出多个成员(对象中)</p></blockquote><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exports.a = <span class="number">123</span></span><br><span class="line">exports.c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">exports.e = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">exports.d = &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>导出单个成员(函数,字符串)</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><blockquote><p>下面情况会覆盖(函数会覆盖掉hello字符串)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>module也可以导出多个成员</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    str: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="到底怎么回事呢-我来解析一下-上面两种方式有什么区别呢"><a href="#到底怎么回事呢-我来解析一下-上面两种方式有什么区别呢" class="headerlink" title="到底怎么回事呢,我来解析一下,上面两种方式有什么区别呢"></a>到底怎么回事呢,我来解析一下,上面两种方式有什么区别呢</h4><ul><li>你可以认为在每一个模块内部都有一个自己的<code>module</code>对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该module对象中,有一个成员叫:exports</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    exports: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认在代码最后一句:所以谁require我,谁就能得到这个哦</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br></pre></td></tr></table></figure><blockquote><p>也就是说如果你需要对外导出成员,只需要把导出的成员挂载到<code>module.exports</code>中</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.foo = <span class="string">'bar'</span></span><br></pre></td></tr></table></figure><blockquote><p>但是我们发现每次导出接口成员都要通过<code>module.exports.xxx</code>的方式,特别麻烦<br>所以node为了简化操作,专门提供了一个变量 <code>exports = module.exports</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports</span><br></pre></td></tr></table></figure><blockquote><p>所以呢</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(exports === <span class="built_in">module</span>.exports)</span><br></pre></td></tr></table></figure><blockquote><p>注意!!!当一个模块要导出单个成员的时候,直接给<strong>exprots</strong>是不管用的!!</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不管用</span></span><br><span class="line">exprots = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><p>原因是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exports只是module.exports的一个引用而已,如果不清楚的话,那就看看js对象引用相关的内容吧</span></span><br><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports</span><br></pre></td></tr></table></figure><blockquote><p>注意:给<code>exports</code>赋值会断开 exports与module.exports之间的引用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] nodejs-require</title>
      <link href="/2019/05/23/node/nodejs-require/"/>
      <url>/2019/05/23/node/nodejs-require/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs-require"><a href="#nodejs-require" class="headerlink" title="nodejs-require"></a>nodejs-require</h2><ul><li>简单来说require就是加载</li><li>语法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 自定义变量名称 = <span class="built_in">require</span>(<span class="string">'模块'</span>)</span><br><span class="line"><span class="comment">//模块:核心模块</span></span><br><span class="line"><span class="comment">//第三方模块</span></span><br><span class="line"><span class="comment">//自定义模块</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li>执行被加载模块中的代码</li><li>当然它会优先在缓存加载(多个文件重复引用require模块的时候)</li><li>得到加载模块中的exports导出的接口对象</li><li>require可以省略后缀名<code>.js</code></li><li>require相对路径中<code>./</code> 不能省略,否则会报错</li><li>在node中,没有全局作用于,只有模块作用于</li><li>外部访问不到内部</li><li>内部也访问不到外部</li><li>关于require(‘模块/路径/第三方包’)<ul><li>路径形式的模块<code>./</code>(当前目录),<code>../</code>(上一级目录),<code>/xxx</code>,<code>/</code>,绝对路径<code>C:/</code></li><li>核心模块: 本质也是文件,只不过该核心模块的文件已经加载到二进制文件中了,可以在<a href="https://github.com/nodejs/node/tree/master/lib" target="_blank" rel="noopener">源码</a>中找到哦</li><li>第三方包: 凡是第三方的模块都必须通过npm或者cnpm/yarn来安装,可以通过<code>require(&#39;包名&#39;)</code>方式来加载<ul><li>先找到node_modules/xxx模块</li><li>node_modules/xxx/package.json文件</li><li>node_modules/xxx/package.json 文件中的main属性</li><li>main属性记录了xxx入口模块</li><li>如果没有package.json也没有main指定入口也没有,则node会自动找该目录下的index.js,如果上面说的都没有,则会进入上一级目录中的node_modules目录查找,如果上一级还没有,则继续往上上级找,如果还没找到则会报错<code>can node find module xxx</code><blockquote><p>注意!!咱们一个项目中有且只有一个node_modules文件夹哦,别多想了,人家就一个<br>想了解更多的node的底层 看这里@by <a href="https://www.infoq.cn/article/nodejs-module-mechanism" target="_blank" rel="noopener">&lt;&lt;深入浅出nodejs&gt;&gt;</a></p></blockquote></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] 关于nodejs中的http请求(2)</title>
      <link href="/2019/05/23/node/nodejs-http(2)/"/>
      <url>/2019/05/23/node/nodejs-http(2)/</url>
      
        <content type="html"><![CDATA[<h2 id="关于nodejs中的http请求-2"><a href="#关于nodejs中的http请求-2" class="headerlink" title="关于nodejs中的http请求(2)"></a>关于nodejs中的http请求(2)</h2><blockquote><p>在服务端默认发送的数据,其实是utf8编码的内容,但是浏览器并不知道你是utf8的内容,浏览器在不知道服务器响应内容的编码情况下,它会默认当前操作系统编码去解析,中文操作系统默认是gbk<br>解决方法就是正确的告诉浏览器给你发送的内容是什么编码,那怎么告诉浏览器呢,看下面代码吧..</p></blockquote><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hostname = <span class="string">'127.0.0.1'</span></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">3000</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (request,response)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`收到客户端请求,请求路径:<span class="subst">$&#123;request.url&#125;</span>`</span>);</span><br><span class="line">    response.statusCode = <span class="number">200</span>;</span><br><span class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html;charset=utf-8'</span>);</span><br><span class="line">    response.write(<span class="string">'response输出内容'</span>);</span><br><span class="line">    response.write(<span class="string">'response输出内容22'</span>);</span><br><span class="line">    response.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">server.on()</span><br><span class="line">server.listen(port,hostname,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>上边的代码是不是很熟悉呢,没错,就是http(1)中的代码.<br>但是不一样的,请看<code>response.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf-8&#39;);</code>,这一段代码就是给响应头增加<code>Content-Type</code>来指定内容类型,<br>在http协议中<code>Content-Type</code>,就是告知对方给你发送的数据类型,当然类型不止是<code>text/html</code><br>当然我们常说的编码,是针对字符的编码,所以图片什么的,不需要这东西的</p></blockquote><ul><li>普通文本 <code>text/plain</code></li><li>html <code>text/html</code> ,这样浏览器会将内容当成html去解析</li><li>…<blockquote><p>还有很多很多哦,去这里自己查吧 <a href="">http://tool.oschina.net/commons</a></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] 关于nodejs中的http请求(1)</title>
      <link href="/2019/05/22/node/nodejs-http(1)/"/>
      <url>/2019/05/22/node/nodejs-http(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="关于nodejs中的http请求-1"><a href="#关于nodejs中的http请求-1" class="headerlink" title="关于nodejs中的http请求(1)"></a>关于nodejs中的http请求(1)</h2><ul><li>request<ul><li>request应该都有了解,他其实就是请求对象,通过这个请求对象,可以获取客户端请求过来的一些信息,比如请求路径</li><li>request有很多属性</li><li>url,返回请求路径后缀比如 <a href="http://localhost:3000/test,这里返回的就是/test" target="_blank" rel="noopener">http://localhost:3000/test,这里返回的就是/test</a></li></ul></li><li>response<ul><li>response当然是响应对象了,通过这个响应对象可以返回信息给客户端</li><li>response要使用end来结束响应,不然客户端会一直等待<a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hostname = <span class="string">'127.0.0.1'</span></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">3000</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (request,response)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`收到客户端请求,请求路径:<span class="subst">$&#123;request.url&#125;</span>`</span>);</span><br><span class="line">    response.statusCode = <span class="number">200</span>;</span><br><span class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">    response.write(<span class="string">'response输出内容'</span>);</span><br><span class="line">    response.write(<span class="string">'response输出内容22'</span>);</span><br><span class="line">    response.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">server.on()</span><br><span class="line">server.listen(port,hostname,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] 服务端渲染与客户端渲染</title>
      <link href="/2019/05/21/node/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
      <url>/2019/05/21/node/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端渲染与客户端渲染"><a href="#服务端渲染与客户端渲染" class="headerlink" title="服务端渲染与客户端渲染"></a>服务端渲染与客户端渲染</h2><ul><li><p>服务端渲染</p><blockquote><p>说白了,就是在服务端使用模板引擎<br>末班引擎最早诞生于服务端,后来才到了前端</p></blockquote></li><li><p>服务端和客户端渲染的区别是什么</p><a id="more"></a><blockquote><p>客户端渲染</p></blockquote><ul><li>浏览器发请求,拿数据,模板引擎渲染,得到页面响应给浏览器页面中的字符串</li><li>浏览器收到服务端响应的页面字符串,从上到下一次解析html,解析过程中,如果发现有script标签就会执行脚本,如果发现ajax请求,则再次发起新的请求,最后在做模板引擎渲染</li><li>第一次请求拿到页面</li><li>第二次请求拿到动态数据</li></ul><blockquote><p>服务端渲染</p></blockquote><ul><li>服务端有页面和数据,服务端都提供</li><li>给浏览器响应页面的时候,服务端已经渲染完成整个页面,所以浏览器只管展示就可以了</li></ul></li></ul><blockquote><p>总结: 其实很清楚,服务端渲染更快,因为服务端所有事情全都做了,一次性给浏览器,浏览器不需要做什么,但是服务端也会造成压力<br>小技巧:有个小技巧可以快速知道是服务端渲染还是客户端渲染,就是打开网页查看源代码,如果源代码中可以搜索到页面的内容,那就是服务端渲染,如果是客户端渲染则是异步的渲染,不刷新页面而且查看源代码搜不到展示出来的内容.</p></blockquote><blockquote><p>还有个重点哦,异步渲染很难被爬虫抓取到的,所以客户端渲染很难被爬虫抓取到,这也就是大家说的客户端渲染SEO会有影响</p></blockquote><blockquote><p>所以很多网站等等都是客户端和服务端渲染结合来做的,服务端渲染为了SEO搜索引擎优化,而不需要考虑SEO的为了提高用户体验,所以采用客户端渲染</p></blockquote><blockquote><p>所以没有绝对哦,一般一个网站是客户端服务端渲染的结合版哦</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] nodejs-helloWord</title>
      <link href="/2019/05/21/node/nodejs-helloWord/"/>
      <url>/2019/05/21/node/nodejs-helloWord/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs-helloWord"><a href="#nodejs-helloWord" class="headerlink" title="nodejs-helloWord"></a>nodejs-helloWord</h2><h3 id="现在就是正式开始学习nodejs-好像什么语言学习都要从helloword学起-那node也从这里开始学吧"><a href="#现在就是正式开始学习nodejs-好像什么语言学习都要从helloword学起-那node也从这里开始学吧" class="headerlink" title="现在就是正式开始学习nodejs,好像什么语言学习都要从helloword学起,那node也从这里开始学吧"></a>现在就是正式开始学习nodejs,好像什么语言学习都要从helloword学起,那node也从这里开始学吧</h3><ul><li>nodejs写helloword很简单很简单<ul><li><ol><li>建一个js文件咯,当然这个名字有讲头了,咱们用nodejs当然文件名不能叫node.js了,哈哈是不是很傻,当然最好文件名也不要使用中文定义会出意想不到的问题啦,其他的名字随便起,小写字母文件名开头,好了建好文件了</li></ol></li><li><ol start="2"><li>我要写helloword啦<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var helloword &#x3D; &#39;helloword&#39;;</span><br><span class="line">console.log(helloword);</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li>写好了js代码,node怎么执行这个js文件呢,很简单,打开命令行,输入 <code>node (文件名).js</code>,看到了吧,我们期待已久的helloword出现了<a id="more"></a></li></ol></li></ul></li><li>当然上面是最简单的nodejs的例子</li><li>http服务关于helloword<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hostname = <span class="string">'127.0.0.1'</span></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">3000</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (request,res)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'收到客户端请求'</span>);</span><br><span class="line">    res.statusCode = <span class="number">200</span>;</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">    res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(port,hostname,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] 使用webstom开发nodejs</title>
      <link href="/2019/05/21/node/webstom%E5%BC%80%E5%8F%91nodejs/"/>
      <url>/2019/05/21/node/webstom%E5%BC%80%E5%8F%91nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="使用webstom开发nodejs"><a href="#使用webstom开发nodejs" class="headerlink" title="使用webstom开发nodejs"></a>使用webstom开发nodejs</h2><ul><li>nodejs自动提示 <a href="">https://www.cnblogs.com/tgxh/p/6293084.html</a><a id="more"></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] nodejs安装</title>
      <link href="/2019/05/21/node/nodejs%E5%AE%89%E8%A3%85/"/>
      <url>/2019/05/21/node/nodejs%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h2><ul><li>Windows<ul><li>windows安装很简单啦,去官网下载,(LTS版本是长期支持版本,稳定版)就可以啦(Currect版本体验版,最新特性版),然后写一部下一步咯<a href="">https://nodejs.org/en/</a> </li><li>一般安装完成以后,他会自动将node和npm都安装进去,以及环境变量</li><li>安装完成<code>node --version</code> 输出一下版本号咯</li></ul></li><li>linux<ul><li>官网也有啦,进去下载解压安装就好了<a id="more"></a></li></ul></li><li>NVM<ul><li>我最喜欢的就是这个工具了,多版本管理工具,可以下载多个版本的node,可以动态的切换,超级好用</li><li>windows下安装 <a href="">https://www.jianshu.com/p/d0e0935b150a</a></li><li>Ubuntu下安装 <a href="">https://www.cnblogs.com/duaimili/p/10084809.html</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] nodejs到底干嘛</title>
      <link href="/2019/05/21/node/nodejs%E5%88%B0%E5%BA%95%E5%B9%B2%E5%98%9B/"/>
      <url>/2019/05/21/node/nodejs%E5%88%B0%E5%BA%95%E5%B9%B2%E5%98%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs到底干嘛"><a href="#nodejs到底干嘛" class="headerlink" title="nodejs到底干嘛"></a>nodejs到底干嘛</h2><ul><li>Web服务器做后台,java/php能做的,他都能做</li><li>命令行工具<a id="more"></a></li><li>对于前端开发工程师来说,主要是使用第三方的工具<ul><li>WebPack</li><li>gulp</li><li>npm</li></ul></li><li>需要预备的知识<ul><li>HTML</li><li>CSS</li><li>JavaScript<ul><li>阮一峰的教程哦 <a href="">http://javascript.ruanyifeng.com/</a></li></ul></li><li>简单的命令行操作</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] nodejs到底是什么</title>
      <link href="/2019/05/21/node/nodejs%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2019/05/21/node/nodejs%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="nodejs到底是什么"><a href="#nodejs到底是什么" class="headerlink" title="nodejs到底是什么"></a>nodejs到底是什么</h2><ul><li><p>当然首先就是nodejs的官网 <a href="">https://nodejs.org/en/</a></p></li><li><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.</p><ul><li>nodejs不是一门语言</li><li>nodejs不是库,不是框架</li><li>nodejs是一个JavaScript运行时环境</li><li>简单来说就是nodejs可以解析和执行JavaScript代码(以前只有浏览器可以解析JavaScript代码,现在可以完全脱离浏览器来运行JavaScript)<a id="more"></a></li></ul></li><li><p>浏览器中的JavaScript</p><ul><li>ECMAScript<ul><li>基本语法</li><li>if</li><li>function</li><li>…</li></ul></li><li>BOM</li><li>DOM</li></ul></li><li><p>nodejs中的JavaScript</p><ul><li><strong>没有BOM和DOM(因为服务端是不操作页面的)</strong></li><li>ECMAScript</li><li>在nodejs这个JavaScript执行环境中,对JavaScript提供了一些服务端的API<ul><li>文件读写</li><li>网络服务构建</li><li>网络通信</li><li>http服务器</li><li>…</li></ul></li></ul></li><li><p>构建在Chrome的V8引擎之上</p><ul><li>什么是引擎,其实就是解析执行js用,引擎越好,那性能就越好</li><li>具体有哪些浏览器对应哪些引擎呢,自行百度咯 <a href="">https://baike.baidu.com/item/javascript%E5%BC%95%E6%93%8E/5356108?fr=aladdin</a><br>其实他的目标就是做后端应用</li></ul></li><li><p>nodejs特性</p><ul><li>nodejs event-driver 事件驱动</li><li>异步(非阻塞IO模型)</li><li>轻量和高效</li></ul></li><li><p>当然nodejs使用就不得不提npm</p><ul><li>npm是最大的开源库生态系统</li><li>npm是什么呢,其实就是将绝大多数第三方js相关的包放到npm上边,目的其实是为了开发人员更方便的下载和使用,也可以将自己写好的JavaScript工具类其他包发布到npm供其他人使用</li><li>比如之前要用jquery,需要下载jquery的js文件,然后引用,现在直接使用<code>npm install jquery</code>就可以了,简单直接</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Node] 为什么要使用nodejs</title>
      <link href="/2019/05/21/node/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8nodejs/"/>
      <url>/2019/05/21/node/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用nodejs"><a href="#为什么要使用nodejs" class="headerlink" title="为什么要使用nodejs"></a>为什么要使用nodejs</h2><a id="more"></a><ul><li><p>自己的理解</p><ol><li><p>其实根本原因是为了全栈工程师这个名号,什么是全栈工程师呢?很简单就是 front-end+back-end 就是前端加后端,当然如果加上移动端那更厉害咯</p></li><li><p>前端有什么呢,其实很简单,就是html+css+JavaScript,简单吧,当然js也有很多框架,什么vue,react,等等,css也提供很多框架咯,比如sass/less等等,html都出到HTML5咯,增加了很多新特性,也可以去了解,不过个人认为最难也是很难学深入的就是JavaScript了,所以本人一直在努力中..</p></li><li><p>当然这里的nodejs用途就是用来做back-end的,也就是后端应用,其实它的最大特点就是可以使用JavaScript编写后端服务,当然后端应用还有好多种,比如java/.net/PHP/Python/go,但是他们要单独学java语言/.net语言等等,需要重新学习一门语言.</p></li><li><p>感觉前端加上nodejs就可以做全栈了,前端这是都要包揽了吗,哈哈,其实感觉nodejs算是轻量化的后端服务,毕竟没有java处理大数据以及其他复杂的能力,就目前使用nodejs都用来开发一些小型的网站或应用系统,或者做中间层,比如vue+nodejs+java这种结构</p></li><li><p>总结以上 JavaScript –everywhere,凡是能用JavaScript实现的,最终都可以用JavaScript来实现,好厉害哟木有.</p></li></ol><p>好啦好啦,不啰嗦,后面继续学习nodejs咯,以上是个人理解,有歧义找我咯</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mapstruct插件</title>
      <link href="/2019/05/06/mapstruct/mapstruct/"/>
      <url>/2019/05/06/mapstruct/mapstruct/</url>
      
        <content type="html"><![CDATA[<h2 id="关于mapstruct插件的使用"><a href="#关于mapstruct插件的使用" class="headerlink" title="关于mapstruct插件的使用"></a>关于mapstruct插件的使用</h2><p><a href="https://blog.csdn.net/vtnews/article/details/80678533" target="_blank" rel="noopener">参考链接</a><br><a href="http://mapstruct.org/documentation/stable/reference/html/" target="_blank" rel="noopener">官网文档</a></p><a id="more"></a><h3 id="经常使用"><a href="#经常使用" class="headerlink" title="经常使用"></a>经常使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">PostHotSquareResourcesMapper</span></span>&#123;</span><br><span class="line">    PostHotSquareResourcesMapper INSTANCE= Mappers.getMapper(PostHotSquareResourcesMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mappings</span>(&#123;</span><br><span class="line">      <span class="meta">@Mapping</span>(target = <span class="string">"likeCount"</span>, expression = <span class="string">"java(post.getLikeCountValue())"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target = <span class="string">"shareCount"</span>, expression = <span class="string">"java(post.getShareCountValue())"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target = <span class="string">"label"</span>,source = <span class="string">"label"</span>, qualifiedByName = <span class="string">"formatLabelDef"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target = <span class="string">"author"</span>, expression = <span class="string">"java(new PostHotSquareResource.Author(post.getAuthor().getId(),post.getAuthor().getOperatorId()))"</span>),</span><br><span class="line">      <span class="meta">@Mapping</span>(target = <span class="string">"category"</span>, expression = <span class="string">"java(new PostHotSquareResource.Category(post.getCategory().getId(),post.getCategory().getGroup()))"</span>),</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function">PostHotSquareResource <span class="title">from</span><span class="params">(Post post)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;PostHotSquareResource&gt; <span class="title">toPost</span><span class="params">(Iterable&lt;Post&gt; posts)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Label <span class="title">formatLabelDef</span><span class="params">(com.dapeng.cloud.service.domain.Label label)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(label!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Label(label.getName(),label.getOrder(),label.getCreatedDate());</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;PostHotSquareResource&gt; <span class="title">toPostResources</span><span class="params">(Iterable&lt;Post&gt; posts)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PostHotSquareResourcesMapper.INSTANCE.toPost(posts);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mapstruct </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mapstruct插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决ubuntu安装软件has install-snap change in progress错误</title>
      <link href="/2019/04/28/Ubuntu/Ubuntu%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/28/Ubuntu/Ubuntu%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="解决ubuntu安装软件has-install-snap-change-in-progress错误"><a href="#解决ubuntu安装软件has-install-snap-change-in-progress错误" class="headerlink" title="解决ubuntu安装软件has install-snap change in progress错误"></a>解决ubuntu安装软件has install-snap change in progress错误</h3><a id="more"></a><p>今天在ubuntu软件商店安装idea报错：</p><p>cannot install “intellij-idea-community”: snap “intellij-idea-community”<br>       has “install-snap” change in progress</p><p>其实就是软件之前安装了一次，只是没安装完。</p><p>解决方案</p><p>先snap changes</p><p><img src="https://img-blog.csdn.net/20180506134025446?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE4NzAyODA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>可以看到ID=5是我之前安装失败的。</p><p>现在我们终止它</p><p>sudo snap abort 5</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea注释配置</title>
      <link href="/2019/04/26/Idea/Idea%E6%B3%A8%E9%87%8A%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/04/26/Idea/Idea%E6%B3%A8%E9%87%8A%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Idea-模板注释配置"><a href="#Idea-模板注释配置" class="headerlink" title="Idea 模板注释配置"></a>Idea 模板注释配置</h2><p>在使用IDEA开发的过程中，我们可以通过设置代码注释模版，实现注释信息的自动补齐，提高编码效率。<br>我使用的是Mac电脑，就以Mac环境来进行说明吧。</p><p>在Mac上配置IDEA的代码注释模版，主要包括两个部分：一个是File Head文件头注释，用于描述类文件的信息；一个是方法头注释，用于描述类方法的信息。具体配置过程如下。</p><a id="more"></a><p>一、配置类文件头注释模版<br>点击IDEA编译器左上角的“IntelliJ IDEA”按钮，选择“Preferences…”，在弹出窗口中，选择“Editor–&gt;File and Code Templates”，在窗口的右边“Schema”下拉栏选择“Default”，然后点击“Includes”标签，在右边模版栏中填写注释模版。最后点击右下角OK按钮生效。<br>参考内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 项目名称：$&#123;PROJECT_NAME&#125;</span><br><span class="line"> * 类 名 称：$&#123;NAME&#125;</span><br><span class="line"> * 类 描 述：TODO</span><br><span class="line"> * 创建时间：$&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class="line"> * 创 建 人：$&#123;USER&#125;</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p>其中${…}里填写的是自动填充内容的标签。窗口右下角有IDEA当前支持的标签列表。<br><img src="https://s1.51cto.com/images/blog/201902/13/19782026f917fafb71b6a68c7ced4797.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="在Mac版本下的IDEA中设置代码注释模版"></p><p>二、配置方法头注释模版<br>点击IDEA编译器左上角的“IntelliJ IDEA”按钮，选择“Preferences…”，在弹出窗口中，选择“Editor–&gt;Live Templates”，进入方法头注释模版编辑界面，如下图。<br><img src="https://s1.51cto.com/images/blog/201902/13/b6dba4df913ae9f76114239e3fcfa7f1.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="在Mac版本下的IDEA中设置代码注释模版"></p><p>添加方法头的注释，需要有以下步骤：<br>（1）首先通过点击图中第二步中的“+”号，创建注释模版分组，比如我们命名为：MethodGroup；<br>（2）在第四步中的“Abbreviation”输入框中添加填充注释时需要输入的指令关键字，此处我们使用“add”作为关键字，并在第五步中添加指令说明。经过这个步骤后，指令关键字会出现在上一步创建的注释分组MethodGroup中，效果如图中的第三步；<br>（3）编辑注释内容模版，参考如下（注意：不需要以 /* 开头，因为需要我们在添加注释时会手动输入）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* </span><br><span class="line"> * @name: $enclosing_method$ </span><br><span class="line"> * @description: TODO  $param$</span><br><span class="line"> * @return: $return$</span><br><span class="line"> * @date: $date$ $time$</span><br><span class="line"> * @auther: $user$</span><br><span class="line"> * </span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>（4）点击第七步按钮，在弹窗中指定注释代码里参数的取值方式。<br><img src="https://s1.51cto.com/images/blog/201902/13/bcdaa8b513012bc3cd49f8ed4622b471.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="在Mac版本下的IDEA中设置代码注释模版"></p><p>需要注意的是，如果param参数默认系统的methodParam()，那么在注释语句中，将以 “@param: [pa1, pa2…]”形式展现。我们使用groovyScript脚本来设置param的注释语句格式，让每个参数占一行。<br>脚本内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groovyScript(&quot;def result&#x3D;&#39;&#39;; def params&#x3D;\&quot;$&#123;_1&#125;\&quot;.replaceAll(&#39;[\\\\[|\\\\]|\\\\s]&#39;, &#39;&#39;).split(&#39;,&#39;).toList(); for(i &#x3D; 0; i &lt; params.size(); i++) &#123;if(params[i] &#x3D;&#x3D; &#39;&#39;) return result;if(i&#x3D;&#x3D;0) result +&#x3D; &#39;\\n&#39;; result+&#x3D;&#39;    * @param &#39; + params[i] + ((i &lt; params.size() - 1) ? &#39;\\n&#39; : &#39;&#39;)&#125;; return result&quot;, methodParameters())</span><br></pre></td></tr></table></figure><p>（5）接下来指定填充注释语句的提示字符，通过窗口中的“Expand with”来指定。”Space”表示空格，”Tab”表示 Tab键。<br>（6）最后是指定注释的使用范围，通过点击窗口下面的“…Change”来完成。<br><img src="https://s1.51cto.com/images/blog/201902/13/2d88a7c77a95cc29326be05e8e844136.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="在Mac版本下的IDEA中设置代码注释模版"></p>]]></content>
      
      
      <categories>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Spring boot - Swagger2] Swagger2的坑</title>
      <link href="/2019/01/28/Spring%20boot/Swagger/"/>
      <url>/2019/01/28/Spring%20boot/Swagger/</url>
      
        <content type="html"><![CDATA[<h3 id="Swagger2的坑"><a href="#Swagger2的坑" class="headerlink" title="Swagger2的坑"></a>Swagger2的坑</h3><a id="more"></a><h4 id="在使用Swagger2的时候出现404访问不到swagger-ui-html的问题"><a href="#在使用Swagger2的时候出现404访问不到swagger-ui-html的问题" class="headerlink" title="在使用Swagger2的时候出现404访问不到swagger-ui.html的问题"></a>在使用Swagger2的时候出现404访问不到swagger-ui.html的问题</h4><ul><li>解决：其实这个问题是资源访问不到的问题，其实默认的话是可以访问到的，只是有些其他配置导致的swagger-ui.html访问不到了，</li><li>原因<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">"/home"</span>).setViewName(<span class="string">"home"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"home"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/hello"</span>).setViewName(<span class="string">"hello"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/login"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">//        registry.addResourceHandler("/**")</span></span><br><span class="line"><span class="comment">//            .addResourceLocations("classpath:/static/");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        registry.addResourceHandler("swagger-ui.html")</span></span><br><span class="line"><span class="comment">//            .addResourceLocations("classpath:/META-INF/resources/");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        registry.addResourceHandler("/webjars/**")</span></span><br><span class="line"><span class="comment">//            .addResourceLocations("classpath:/META-INF/resources/webjars/");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>主要是这里我继承了WebMvcConfigurationSupport，导致资源访问不到的</strong><br><strong>改成这样就可以了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">"/home"</span>).setViewName(<span class="string">"home"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"home"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/hello"</span>).setViewName(<span class="string">"hello"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/login"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>还有一个地方就是使用EnableWebMvc这个注解，去掉就可以了</strong></p>]]></content>
      
      
      <categories>
          
          <category> Swagger2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装Mac主题</title>
      <link href="/2018/11/05/Ubuntu/Ubuntu%E5%AE%89%E8%A3%85Mac%E4%B8%BB%E9%A2%98/"/>
      <url>/2018/11/05/Ubuntu/Ubuntu%E5%AE%89%E8%A3%85Mac%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="安装完的效果："><a href="#安装完的效果：" class="headerlink" title="安装完的效果："></a>安装完的效果：</h2><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429161412129-1116249924.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429160502927-1578215265.png" alt="img"></p><p> <img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429160911712-900377874.jpg" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429160530821-484243121.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429160650449-1158372687.png" alt="img"></p><p>参考：</p><p><a href="https://linuxhint.com/gnome-tweak-tool-ubuntu-17-10/" target="_blank" rel="noopener">https://linuxhint.com/gnome-tweak-tool-ubuntu-17-10/</a></p><p>————————————————————————————————————————————————————</p><h2 id="下面正式开始"><a href="#下面正式开始" class="headerlink" title="下面正式开始"></a>下面正式开始</h2><p>————————————————————————————————————————————————————</p><p>要安装主题，首先要先安装相应的工具：TweakTool</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gnome-tweak-tool</span><br></pre></td></tr></table></figure><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/g1.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/g1.png" alt="img"></a></p><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/g2.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/g2.png" alt="img"></a></p><p>下图就是安装完后，打开的Tweaks</p><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/tweak-tool.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/tweak-tool.png" alt="img"></a></p><h2 id="修改窗口的按钮位置"><a href="#修改窗口的按钮位置" class="headerlink" title="修改窗口的按钮位置"></a>修改窗口的按钮位置</h2><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/tw-2.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/tw-2.png" alt="img"></a></p><p>Before:</p><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/t.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/t.png" alt="img"></a></p><p>After:</p><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/ta.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/ta.png" alt="img"></a></p><p>现在按钮位置就修改到左边了</p><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/tweaks.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/tweaks.png" alt="img"></a></p><h2 id="显示或隐藏桌面上的图标"><a href="#显示或隐藏桌面上的图标" class="headerlink" title="显示或隐藏桌面上的图标"></a><strong>显示或隐藏桌面上的图标</strong></h2><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/desktop.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/desktop.png" alt="img"></a></p><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/desktop-1.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/desktop-1.png" alt="img"></a></p><h2 id="修改鼠标图标"><a href="#修改鼠标图标" class="headerlink" title="修改鼠标图标"></a><strong>修改鼠标图标</strong></h2><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180504143142953-1844590600.png" alt="img"></p><p> <img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180504143239149-1367996840.png" alt="img"></p><h2 id="去掉Shell上无法修改的叹号"><a href="#去掉Shell上无法修改的叹号" class="headerlink" title="去掉Shell上无法修改的叹号"></a><strong>去掉Shell上无法修改的叹号</strong></h2><p><strong><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180504144028668-1218964325.png" alt="img"></strong></p><p>执行下面的命令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-shell-extensions</span><br></pre></td></tr></table></figure><p> <a href="https://linuxhint.com/wp-content/uploads/2017/11/1.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/1.png" alt="img"></a></p><p>安装完成后打开Tweaks选择 “Extensions”选项</p><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/2.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/2.png" alt="img"></a></p><p>“User themes” 按钮设置成on</p><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/3.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/3.png" alt="img"></a></p><p>去“Appearances”选项，就能发现Shell那里没有叹号了</p><p><a href="https://linuxhint.com/wp-content/uploads/2017/11/4.png" target="_blank" rel="noopener"><img src="https://linuxhint.com/wp-content/uploads/2017/11/4.png" alt="img"></a></p><p>————————————————————————————————————————————————————</p><h2 id="到现在我们已经把工具安装配置完成了，下面正式安装主题"><a href="#到现在我们已经把工具安装配置完成了，下面正式安装主题" class="headerlink" title="到现在我们已经把工具安装配置完成了，下面正式安装主题"></a>到现在我们已经把工具安装配置完成了，下面正式安装主题</h2><p>————————————————————————————————————————————————————</p><h2 id="1-安装GTK主题"><a href="#1-安装GTK主题" class="headerlink" title="1.安装GTK主题"></a>1.安装GTK主题</h2><p>去这个链接：<a href="https://www.opendesktop.org/s/Gnome/p/1171688/" target="_blank" rel="noopener">https://www.opendesktop.org/s/Gnome/p/1171688/</a></p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429121803984-914082047.png" alt="img"></p><p>网页上有好几个标签：Prodect、FIles、Changelogs等等</p><p>找到Files标签，去下载文件。点击文件名就可以下载。</p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429121841955-578359059.png" alt="img"></p><p>可以看到这里一共有6个压缩文件，分别包装各种主题。通过文件名能发现每一个文件都有一个“2”，这个2的意思是该压缩包下有两个主题。</p><p>随便选中一个比如Gnome-OSC-HS–2themes.tar.xz（第一个文件），下载下来。</p><p>通过xz和tar命令解压</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz -d Gnome-OSC-HS--2-themes.tar.xz</span><br><span class="line">tar xvf Gnome-OSC-HS--2-themes.tar.xz</span><br></pre></td></tr></table></figure><p> 解压后得到的文件夹中有两个文件夹</p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429122442367-1915958074.png" alt="img"></p><p>这两个文件夹分别是两个主题，把这两个文件夹移动到/usr/share/themes下就可以了。</p><p>然后打开前面安装的工具Tweaks（中文下叫“优化”）,在“应用程序”英文是“Applications”这个选项下就可以选择刚刚安装的主题了。这几个截图是我安装主题后的截图。</p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429122823939-394497790.png" alt="img"></p><p>刚刚是两个文件夹，就是两个主题，这两个主题从名字上看只有transparent前面是否有个not，顾名思义就是有没有透明效果。</p><p>到现在已经修改了外观样式，最大化最小化的样式已经很苹果了。</p><h2 id="2-修改图标"><a href="#2-修改图标" class="headerlink" title="2.修改图标"></a>2.修改图标</h2><p>去下面的链接下载</p><p><a href="https://www.opendesktop.org/s/Gnome/p/1102582/" target="_blank" rel="noopener">https://www.opendesktop.org/s/Gnome/p/1102582/</a></p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429154102972-127816603.png" alt="img"></p><p>解压后把文件都放到/usr/share/icons目录下，如下图（这是已经应用过主题的截图）所示：</p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429154233688-1776948414.png" alt="img"></p><p>然后去Tweaks中应用一下</p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180429154346719-2011249705.png" alt="img"></p><h2 id="3-修改桌面Shell"><a href="#3-修改桌面Shell" class="headerlink" title="3.修改桌面Shell"></a>3.修改桌面Shell</h2><p>去这个链接：<a href="https://www.opendesktop.org/s/Gnome/p/1013741/" target="_blank" rel="noopener">https://www.opendesktop.org/s/Gnome/p/1013741/</a></p><p>下载下面红框里的</p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180430224507785-1703816949.png" alt="img"></p><p>应用下</p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180430224439646-1134731024.png" alt="img"></p><p>效果：</p><p><img src="https://images2018.cnblogs.com/blog/871381/201804/871381-20180430224613985-870334125.png" alt="img"></p><p>-——————-</p><p>2018-05-09更新</p><p>关于plymouth theme，开机动画。</p><p>-——————-</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180509180355435-2101838157.png" alt="img"></p><p>如上图所示，/etc/alternatives/default.plymouth文件指定了一个logo文件夹，指定了一个执行脚本。开机的时候就用这个文件指定的logo和脚本执行。</p><p>那么思路就是，把logo文件夹和脚本指定成别的就可以修改开机动画。</p><p> 开机动画主题没找到好看的，试一下这个吧：</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180509175726877-1091423276.png" alt="img"></p><p>下载下压缩包，解压后：</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180509180008144-701658598.png" alt="img"></p><p>把解压的文件mv到 /usr/share/plymouth/themes/目录下</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180509181023701-324087762.png" alt="img"></p><p>然后去修改下/etc/alternatives/default.plymouth（先备份源文件）成如下</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180509181800614-743927760.png" alt="img"></p><p>实际图示就类似下图，不过中间的logo是会转动的（手机录制的不好看就不贴gif了）</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180509182709696-1629056255.png" alt="img"></p><p>-——————-</p><p>2018-05-10更新</p><p>GDM（GNOME Display Manager，GDM）主题，也就是登录界面的主题</p><p>-——————-</p><p>选了一个主题<a href="https://www.opendesktop.org/s/Gnome/p/1207015/，如下" target="_blank" rel="noopener">https://www.opendesktop.org/s/Gnome/p/1207015/，如下</a></p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180510173701794-799174149.png" alt="img"></p><p>解压压缩包</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180510220402766-1132179765.png" alt="img"></p><p>该文件夹下有三个文件</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180510220546905-1276945816.png" alt="img"></p><p>先说明下修改登录界面样式的原理：</p><p>重要步骤是在css文件，这个/usr/share/gnome-shell/theme/ubuntu.css就配置了登录界面的样式。</p><p>在/usr/share/gnome-shell/theme/ubuntu.css文件（上面我下载的包中，非系统自带的这个css文件）中有这样一行代码：</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180510221009185-1617979768.png" alt="img"></p><p>是的，Ubuntu18.04的登录界面是用css文件渲染的，做网页前端的应该最熟悉不过了。</p><p>如果你只想替换登录界面的背景，把系统自带的这个css文件中指定图像文件的位置修改成你自己的图片的绝对目录就行了。</p><p>当然，如果你想让你的登录界面炫酷一些，修改css文件，渲染成你想要的效果即可。</p><p>或者你想省事，那就和我一样去网上下载别人写好的css文件。</p><p>在我下载的<img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180510221834710-326009557.png" alt="img">中，还有个脚本文件，内容如下：</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180510221931666-1749878383.png" alt="img"></p><p>有注释，这个脚本的作用是把你现在正在用的壁纸模糊处理，然后放到  ~/Pictures/gdm_look.jpg，执行过脚本后，你的 ~/Pictures目录下就会多一个gdm_look.jpg文件，这个文件就是你当前用的壁纸的模糊处理过后的图片。</p><p>然后 ~/Pictures/gdm_look.jpg又被复制到/usr/share/backgrounds/目录下，再看下面这个图</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180510222529948-804318886.png" alt="img"></p><p>这个包中提供的css文件指定的登录页面壁纸，也就是脚本处理完后cp到/usr/share/backgrounds/的gdm_look.jpg。</p><p>至此，原理说明白了，操作如下：</p><p>备份/usr/share/gnome-shell/theme/ubuntu.css</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /usr/share/gnome-shell/theme/ubuntu.css /usr/share/gnome-shell/theme/ubuntu.css.backup</span><br></pre></td></tr></table></figure><p> 用下图中的ubuntu.css替换掉系统自带的/usr/share/gnome-shell/theme/ubuntu.css</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180510222747600-1683538837.png" alt="img"></p><p>把SetAsWallpaper脚本文件复制到~/.local/share/nautilus/scripts/目录下，然后修改下权限（如果需要）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x SetAsWallpaper</span><br></pre></td></tr></table></figure><p> 然后重启nautilus（下面的命令是关闭）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nautilus -q</span><br></pre></td></tr></table></figure><p>  点击桌面右下角“所有应用”，查找“nautilus ”</p><p> <img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180510223449772-2057063157.png" alt="img"></p><p>执行如下命令，修改下 /usr/share/backgrounds  的权限</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /usr/share/backgrounds/</span><br></pre></td></tr></table></figure><p> 最后一步，去~/.local/share/nautilus/scripts/  目录下执行下SetAsWallpaper脚本。</p><p>重启系统就好了。（执行脚本后，你的桌面壁纸可能会没了，重新设置下就好了）</p><p>最后放一张效果图：</p><p> <img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180510223831755-1959059064.png" alt="img"></p><p>-——————-</p><p>2018-05-12更新</p><p>TopBar</p><p>-——————-</p><p>我使用的gnome-shell主题是<img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180512103726433-810923744.png" alt="img">)它的TopBar是这样的<img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180512103647183-1624835691.png" alt="img">字体略粗，且很宽太占空间。</p><p>修改后的样子<img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180512103834659-1724814949.png" alt="img">这样明显好看一些。</p><p>下面正式开始修改，由于我是用的Sierra-compact-light主题，所以要去这个主题下面的配置文件（其实是一个css文件）修改，就是下面的目录</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/share/themes/Sierra-compact-light/gnome-shell/gnome-shell.css</span><br></pre></td></tr></table></figure><p> 如果你是想修改Ubuntu默认的TopBar就不是上面这个目录了而应该是Ubuntu默认Shell的目录，可能是下面几个文件中修改，因为我没试过，所以不确定具体是哪个文件。</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180512104619865-976101051.png" alt="img"></p><p>回到/usr/share/themes/Sierra-compact-light/gnome-shell/gnome-shell.css文件，也就是我的主题文件，ctrl+f找#panel</p><p>修改TopBar高度</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180512104947534-1431114294.png" alt="img"></p><p>加粗字体改成正常字体</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180512105117568-195764742.png" alt="img"></p><p>保存重启就好了。</p><p>-——————- </p><p>2018-05-19更新</p><p>Dash to Dock</p><p>-——————-</p><p>打开Ubuntu Software，直接搜索 dash to dock，安装上。</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180519120202372-1896900118.png" alt="img"></p><p> 打开Tweaks -&gt; Extensions，注意，这里不要打开Dash to Dock扩展，修改样式直接点击齿轮按钮就好，我尝试打开，但是锁屏后再进入桌面会有bug。</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180519135131930-538583427.png" alt="img"></p><p>我的设置如下</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180519120518296-729443.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180519120547735-1320337036.png" alt="img"></p><p>效果：</p><p><img src="https://images2018.cnblogs.com/blog/871381/201805/871381-20180519120739961-2027118947.png" alt="img"></p><p>比起docky这个的好处是直接修改的系统的dock，而docky是直接添加了一dock且系统自带的dock也不能移除，但docky有macOS的放大效果这个没有。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装idea</title>
      <link href="/2018/10/18/Ubuntu/Ubuntu%E5%AE%89%E8%A3%85idea/"/>
      <url>/2018/10/18/Ubuntu/Ubuntu%E5%AE%89%E8%A3%85idea/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>个人分类： Ubuntu  </p><h2 id="1、下载地址：https-www-jetbrains-com-idea-download-section-linux"><a href="#1、下载地址：https-www-jetbrains-com-idea-download-section-linux" class="headerlink" title="1、下载地址：https://www.jetbrains.com/idea/download/#section=linux"></a>1、下载地址：<a href="https://www.jetbrains.com/idea/download/#section=linux" target="_blank" rel="noopener">https://www.jetbrains.com/idea/download/#section=linux</a></h2><p><img src="http://www.zzpblog.cn/img/liunx%E4%B8%8B%E8%BD%BD.png" alt="下载页面"></p><h2 id="2、解压"><a href="#2、解压" class="headerlink" title="2、解压"></a>2、解压</h2><ul><li>找到下载的tar包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar -zxvf Idea-UI-2018.2.5.tar.gz</span><br></pre></td></tr></table></figure></li><li>进入bin/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd bin</span><br></pre></td></tr></table></figure></li><li>找到idea.sh并运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;idea.sh</span><br></pre></td></tr></table></figure><h2 id="2、破解"><a href="#2、破解" class="headerlink" title="2、破解"></a>2、破解</h2></li><li>修改环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gedit &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure></li><li>增加</li></ul><p>0.0.0.0 account.jetbrains.com</p><ul><li>注册码地址</li></ul><p><a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot热加载</title>
      <link href="/2018/10/05/Spring%20boot/Springboot%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
      <url>/2018/10/05/Spring%20boot/Springboot%E7%83%AD%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-boot-热加载"><a href="#Spring-boot-热加载" class="headerlink" title="Spring boot 热加载"></a>Spring boot 热加载</h1><a id="more"></a><p><strong>1 pom.xml文件</strong></p><p><strong>注：</strong>热部署功能spring-boot-1.3开始有的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;!-- optional&#x3D;true,依赖不会传递，该项目依赖devtools；之后依赖myboot项目的项目如果想要使用devtools，需要重新引入 --&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：project 中添加 spring-boot-maven-plugin,主要在eclipse中使用，idea中不需要添加此配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;fork&gt;true&lt;&#x2F;fork&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p><strong>2 更改idea配置</strong></p><p>　　1） “File” -&gt; “Settings” -&gt; “Build,Execution,Deplyment” -&gt; “Compiler”，选中打勾 “Build project automatically” 。</p><p>　　2） 组合键：“Shift+Ctrl+Alt+/” ，选择 “Registry” ，选中打勾 “compiler.automake.allow.when.app.running” 。</p><p><strong>3 Chrome禁用缓存</strong></p><p>　　F12或者“Ctrl+Shift+I”，打开开发者工具，“Network” 选项卡下 选中打勾 “Disable Cache(while DevTools is open)” </p>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu系统Xshell root连接时linux时提示ssh服务器拒绝了密码</title>
      <link href="/2018/09/29/Ubuntu/Ubuntu%20xShell%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/"/>
      <url>/2018/09/29/Ubuntu/Ubuntu%20xShell%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu系统Xshell-root连接时linux时提示ssh服务器拒绝了密码"><a href="#Ubuntu系统Xshell-root连接时linux时提示ssh服务器拒绝了密码" class="headerlink" title="Ubuntu系统Xshell root连接时linux时提示ssh服务器拒绝了密码"></a>Ubuntu系统Xshell root连接时linux时提示ssh服务器拒绝了密码</h1><a id="more"></a><p>安装openssh-server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>用Xshell root连接时linux时提示ssh服务器拒绝了密码，应该sshd设置了不允许root用户用密码远程登录<br>修改 /etc/ssh/sshd_config文件，注意，安装了openssh才会有这个文件，如果文件不存在请检查是否安装了openssh。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br></pre></td></tr></table></figure><ul><li><p>找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Authentication:</span><br><span class="line">LoginGraceTime 120</span><br><span class="line">PermitRootLogin prohibit-password</span><br><span class="line">StrictModes yes</span><br></pre></td></tr></table></figure><ul><li><p>修改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Authentication:</span><br><span class="line">LoginGraceTime 120</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">StrictModes yes</span><br></pre></td></tr></table></figure><ul><li><p>输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;ssh restart</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器通过宿主机安装JDK和MAVEN</title>
      <link href="/2018/09/29/docker/Docker%E9%83%A8%E7%BD%B2JDK%E5%92%8CMAVEN/"/>
      <url>/2018/09/29/docker/Docker%E9%83%A8%E7%BD%B2JDK%E5%92%8CMAVEN/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>Docker容器通过宿主机安装JDK和MAVEN</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="Docker容器通过宿主机安装JDK和MAVEN"><a href="#Docker容器通过宿主机安装JDK和MAVEN" class="headerlink" title="Docker容器通过宿主机安装JDK和MAVEN"></a>Docker容器通过宿主机安装JDK和MAVEN</h1><h3 id="1，下载jdk和maven"><a href="#1，下载jdk和maven" class="headerlink" title="1，下载jdk和maven"></a>1，下载jdk和maven</h3><p>JDK <a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.oracle.com%2Ftechnetwork%2Fjava%2Fjavase%2Fdownloads%2Fjdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br> MAVEN <a href="https://link.jianshu.com?t=https%3A%2F%2Fmaven.apache.org%2Fdownload.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a></p><h3 id="2，解压"><a href="#2，解压" class="headerlink" title="2，解压"></a>2，解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf jdk-8u161-linux-x64.tar.gz</span><br><span class="line">tar zxvf apache-maven-3.5.3.tar.gz</span><br></pre></td></tr></table></figure><h3 id="3移动到指定目录下"><a href="#3移动到指定目录下" class="headerlink" title="3移动到指定目录下"></a>3移动到指定目录下</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv .&#x2F;jdk-8u161 &#x2F;usr&#x2F;local</span><br><span class="line">mv .&#x2F;apache-maven-3.5.3&#x2F;usr&#x2F;local</span><br></pre></td></tr></table></figure><h3 id="4-Dockerfile"><a href="#4-Dockerfile" class="headerlink" title="4,  Dockerfile"></a>4,  Dockerfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk</span><br><span class="line">ENV CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">ENV MAVEN_HOME &#x2F;usr&#x2F;local&#x2F;maven</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME&#x2F;bin:$MAVEN_HOME&#x2F;bin</span><br><span class="line"></span><br><span class="line">CMD [&quot;java&quot;, &quot;-version&quot;]</span><br><span class="line">CMD [&quot;mvn&quot;, &quot;-v&quot;]</span><br></pre></td></tr></table></figure><h3 id="5，构建镜像"><a href="#5，构建镜像" class="headerlink" title="5，构建镜像"></a>5，构建镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t java_maven . 生成docker image。</span><br></pre></td></tr></table></figure><h3 id="6，启动容器"><a href="#6，启动容器" class="headerlink" title="6，启动容器"></a>6，启动容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_161:&#x2F;usr&#x2F;local&#x2F;jdk -v &#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.3:&#x2F;usr&#x2F;local&#x2F;maven --name jdk_maven java_maven</span><br></pre></td></tr></table></figure><p><img src="https:////upload-images.jianshu.io/upload_images/6880501-ac1904dd75b4e2f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/902/format/webp" alt="img"></p><p>image.png</p><p>运行容器后，显示上图，表示成功。</p><p>链接：<a href="https://www.jianshu.com/p/cb73ac39820b" target="_blank" rel="noopener">https://www.jianshu.com/p/cb73ac39820b</a></p><p>來源：简书</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker命令总结</title>
      <link href="/2018/09/28/docker/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/09/28/docker/Docker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>docker命令总结</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="docker命令总结"><a href="#docker命令总结" class="headerlink" title="docker命令总结"></a>docker命令总结</h1><h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker iamges   </span><br><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull [镜像名称]</span><br></pre></td></tr></table></figure><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi [镜像名称&#x2F;id]</span><br><span class="line">$ docker image rm [镜像名称&#x2F;id]</span><br><span class="line">$ docker image prune 清除none的镜像</span><br></pre></td></tr></table></figure><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 8080:8080 tomcat</span><br><span class="line">$ docker run -p 8080:8080 --name tomcat2 tomcat   运行一个镜像为tomcat名称为tomcat2的容器</span><br><span class="line">$ docker run -it --rm tomcat bash 交互方式进入退出时候删除</span><br><span class="line">$ docker run -it tomcat bash 交互方式进入但退出时候不删除</span><br><span class="line">$ docker run -p 8080:8080 -d tomcat   -d的意思是守护太运行，也就是后台运行</span><br></pre></td></tr></table></figure><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a  查看所有容器</span><br><span class="line">$ docker ps 查看正在运行的容器</span><br></pre></td></tr></table></figure><h2 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker restart 容器id</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it 容器id bash</span><br></pre></td></tr></table></figure><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop 容器名称&#x2F;id</span><br></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm 容器id</span><br><span class="line">$ docker rm -f 容器id   强制删除容器</span><br></pre></td></tr></table></figure><h2 id="删除镜像-1"><a href="#删除镜像-1" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi 镜像id&#x2F;镜像名称</span><br><span class="line">$ docker image rm 镜像id</span><br></pre></td></tr></table></figure><h2 id="监听查看日志"><a href="#监听查看日志" class="headerlink" title="监听查看日志"></a>监听查看日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f 容器名</span><br></pre></td></tr></table></figure><h2 id="构建Dockerfile"><a href="#构建Dockerfile" class="headerlink" title="构建Dockerfile"></a>构建Dockerfile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t 镜像名称 .   (.代表dockerfile路径)</span><br></pre></td></tr></table></figure><h2 id="Dockerfile命令"><a href="#Dockerfile命令" class="headerlink" title="Dockerfile命令"></a>Dockerfile命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM 镜像 （必须）</span><br><span class="line">WORKDIR 路径  (工作路径)</span><br><span class="line">COPY 上下文路径 目标镜像路径</span><br><span class="line">RUN shell脚本 (运行shell脚本)</span><br><span class="line">EXPOSE 8080 暴露端口</span><br><span class="line">CMD service nginx start CMD启动命令</span><br><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><h2 id="前台运行"><a href="#前台运行" class="headerlink" title="前台运行"></a>前台运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start</span><br></pre></td></tr></table></figure><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><h2 id="停止并移除容器"><a href="#停止并移除容器" class="headerlink" title="停止并移除容器"></a>停止并移除容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose 模板文件</title>
      <link href="/2018/09/28/docker/Docker-compose%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/"/>
      <url>/2018/09/28/docker/Docker-compose%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>docker-compose 模板文件</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="docker-compose-模板文件"><a href="#docker-compose-模板文件" class="headerlink" title="docker-compose 模板文件"></a>docker-compose 模板文件</h1><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p><p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    image: examples&#x2F;web</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;data&quot;</span><br></pre></td></tr></table></figure><p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中再次设置。</p><p>下面分别介绍各个指令的用法。</p><h3 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h3><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build: .&#x2F;dir</span><br></pre></td></tr></table></figure><p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p><p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p><p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: .&#x2F;dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure><p>使用 <code>cache_from</code> 指定构建镜像的缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  cache_from:</span><br><span class="line">    - alpine:latest</span><br><span class="line">    - corp&#x2F;web_app:3.14</span><br></pre></td></tr></table></figure><h3 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a><code>cap_add, cap_drop</code></h3><p>指定容器的内核能力（capacity）分配。</p><p>例如，让容器拥有所有能力可以指定为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL</span><br></pre></td></tr></table></figure><p>去掉 NET_ADMIN 能力可以指定为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cap_drop:</span><br><span class="line">  - NET_ADMIN</span><br></pre></td></tr></table></figure><h3 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h3><p>覆盖容器启动后默认执行的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a><code>configs</code></h3><p>仅用于 <code>Swarm mode</code></p><h3 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a><code>cgroup_parent</code></h3><p>指定父 <code>cgroup</code> 组，意味着将继承该组的资源限制。</p><p>例如，创建了一个 cgroup 组名称为 <code>cgroups_1</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgroup_parent: cgroups_1</span><br></pre></td></tr></table></figure><h3 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h3><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: docker-web-container</span><br></pre></td></tr></table></figure><blockquote><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></blockquote><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a><code>deploy</code></h3><p>仅用于 <code>Swarm mode</code></p><h3 id="devices"><a href="#devices" class="headerlink" title="devices"></a><code>devices</code></h3><p>指定设备映射关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - &quot;&#x2F;dev&#x2F;ttyUSB1:&#x2F;dev&#x2F;ttyUSB0&quot;</span><br></pre></td></tr></table></figure><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h3><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p></blockquote><h3 id="dns"><a href="#dns" class="headerlink" title="dns"></a><code>dns</code></h3><p>自定义 <code>DNS</code> 服务器。可以是一个值，也可以是一个列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 114.114.114.114</span><br></pre></td></tr></table></figure><h3 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a><code>dns_search</code></h3><p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - domain1.example.com</span><br><span class="line">  - domain2.example.com</span><br></pre></td></tr></table></figure><h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a><code>tmpfs</code></h3><p>挂载一个 tmpfs 文件系统到容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: &#x2F;run</span><br><span class="line">tmpfs:</span><br><span class="line">  - &#x2F;run</span><br><span class="line">  - &#x2F;tmp</span><br></pre></td></tr></table></figure><h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h3><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p><p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - .&#x2F;common.env</span><br><span class="line">  - .&#x2F;apps&#x2F;web.env</span><br><span class="line">  - &#x2F;opt&#x2F;secrets.env</span><br></pre></td></tr></table></figure><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># common.env: Set development environment</span><br><span class="line">PROG_ENV&#x3D;development</span><br></pre></td></tr></table></figure><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h3><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV&#x3D;development</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure><p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href="http://yaml.org/type/bool.html" target="_blank" rel="noopener">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a><code>expose</code></h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure><h3 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a><code>external_links</code></h3><blockquote><p>注意：不建议使用该指令。</p></blockquote><p>链接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的外部容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">external_links:</span><br><span class="line"> - redis_1</span><br><span class="line"> - project_db_1:mysql</span><br><span class="line"> - project_db_1:postgresql</span><br></pre></td></tr></table></figure><h3 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a><code>extra_hosts</code></h3><p>类似 Docker 中的 <code>--add-host</code> 参数，指定额外的 host 名称映射信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;googledns:8.8.8.8&quot;</span><br><span class="line"> - &quot;dockerhub:52.1.157.61&quot;</span><br></pre></td></tr></table></figure><p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure><h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h3><p>通过命令检查容器是否健康运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;]</span><br><span class="line">  interval: 1m30s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br></pre></td></tr></table></figure><h3 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h3><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image: ubuntu</span><br><span class="line">image: orchardup&#x2F;postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure><h3 id="labels"><a href="#labels" class="headerlink" title="labels"></a><code>labels</code></h3><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">labels:</span><br><span class="line">  com.startupteam.description: &quot;webapp for a startup team&quot;</span><br><span class="line">  com.startupteam.department: &quot;devops department&quot;</span><br><span class="line">  com.startupteam.release: &quot;rc3 for v1.0&quot;</span><br></pre></td></tr></table></figure><h3 id="links"><a href="#links" class="headerlink" title="links"></a><code>links</code></h3><blockquote><p>注意：不推荐使用该指令。</p></blockquote><h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a><code>logging</code></h3><p>配置日志选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp:&#x2F;&#x2F;192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure><p>目前支持三种日志驱动类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure><p><code>options</code> 配置日志驱动的相关参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options:</span><br><span class="line">  max-size: &quot;200k&quot;</span><br><span class="line">  max-file: &quot;10&quot;</span><br></pre></td></tr></table></figure><h3 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a><code>network_mode</code></h3><p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name&#x2F;id]&quot;</span><br></pre></td></tr></table></figure><h3 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h3><p>配置容器连接的网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">  other-network:</span><br></pre></td></tr></table></figure><h3 id="pid"><a href="#pid" class="headerlink" title="pid"></a><code>pid</code></h3><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid: &quot;host&quot;</span><br></pre></td></tr></table></figure><h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h3><p>暴露端口信息。</p><p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000:8000&quot;</span><br><span class="line"> - &quot;49100:22&quot;</span><br><span class="line"> - &quot;127.0.0.1:8001:8001&quot;</span><br></pre></td></tr></table></figure><p><em>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><h3 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a><code>secrets</code></h3><p>存储敏感数据，例如 <code>mysql</code> 服务密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;db_root_password</span><br><span class="line">  secrets:</span><br><span class="line">    - db_root_password</span><br><span class="line">    - my_other_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: .&#x2F;my_secret.txt</span><br><span class="line">  my_other_secret:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure><h3 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a><code>security_opt</code></h3><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">security_opt:</span><br><span class="line">    - label:user:USER</span><br><span class="line">    - label:role:ROLE</span><br></pre></td></tr></table></figure><h3 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a><code>stop_signal</code></h3><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop_signal: SIGUSR1</span><br></pre></td></tr></table></figure><h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h3><p>配置容器内核参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn&#x3D;1024</span><br><span class="line">  - net.ipv4.tcp_syncookies&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h3><p>指定容器的 ulimits 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h3><p>数据卷所挂载路径设置。可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line"> - &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line"> - cache&#x2F;:&#x2F;tmp&#x2F;cache</span><br><span class="line"> - ~&#x2F;configs:&#x2F;etc&#x2F;configs&#x2F;:ro</span><br></pre></td></tr></table></figure><h3 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h3><p>此外，还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code>等指令，基本跟 <code>docker run</code> 中对应参数的功能一致。</p><p>指定服务容器启动后执行的入口文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entrypoint: &#x2F;code&#x2F;entrypoint.sh</span><br></pre></td></tr></table></figure><p>指定容器中运行应用的用户名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user: nginx</span><br></pre></td></tr></table></figure><p>指定容器中工作目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">working_dir: &#x2F;code</span><br></pre></td></tr></table></figure><p>指定容器中搜索域名、主机名、mac 地址等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">domainname: your_website.com</span><br><span class="line">hostname: test</span><br><span class="line">mac_address: 08-00-27-00-0C-0A</span><br></pre></td></tr></table></figure><p>允许容器中运行一些特权命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privileged: true</span><br></pre></td></tr></table></figure><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart: always</span><br></pre></td></tr></table></figure><p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read_only: true</span><br></pre></td></tr></table></figure><p>打开标准输入，可以接受外部输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stdin_open: true</span><br></pre></td></tr></table></figure><p>模拟一个伪终端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tty: true</span><br></pre></td></tr></table></figure><h3 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量。</p><p>例如，下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code> 的值，并写入执行的指令中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">  image: &quot;mongo:$&#123;MONGO_VERSION&#125;&quot;</span><br></pre></td></tr></table></figure><p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器。</p><p>若当前目录存在 <code>.env</code> 文件，执行 <code>docker-compose</code> 命令时将从该文件中读取变量。</p><p>在当前目录新建 <code>.env</code> 文件并写入以下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 支持 # 号注释</span><br><span class="line">MONGO_VERSION&#x3D;3.6</span><br></pre></td></tr></table></figure><p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose 命令</title>
      <link href="/2018/09/28/docker/Docker-compose%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/09/28/docker/Docker-compose%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>docker-compose 命令</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="docker-compose-命令"><a href="#docker-compose-命令" class="headerlink" title="docker-compose 命令"></a>docker-compose 命令</h1><h3 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h3><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p><p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p><p><code>docker-compose</code> 命令的基本的使用格式是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f&#x3D;&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><ul><li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li><li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li><li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li><li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li><li><code>--verbose</code> 输出更多调试信息。</li><li><code>-v, --version</code> 打印版本并退出。</li></ul><h3 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h3><h4 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h4><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p><p>构建（重新构建）项目中的服务容器。</p><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p><p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p><p>选项包括：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器。</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li></ul><h4 id="config"><a href="#config" class="headerlink" title="config"></a><code>config</code></h4><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h4 id="down"><a href="#down" class="headerlink" title="down"></a><code>down</code></h4><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h4><p>进入指定的容器。</p><h4 id="help"><a href="#help" class="headerlink" title="help"></a><code>help</code></h4><p>获得一个命令的帮助。</p><h4 id="images"><a href="#images" class="headerlink" title="images"></a><code>images</code></h4><p>列出 Compose 文件中包含的镜像。</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a><code>kill</code></h4><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p><p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p><p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose kill -s SIGINT</span><br></pre></td></tr></table></figure><h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a><code>logs</code></h4><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p><p>该命令在调试问题的时候十分有用。</p><h4 id="pause"><a href="#pause" class="headerlink" title="pause"></a><code>pause</code></h4><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p><p>暂停一个服务容器。</p><h4 id="port"><a href="#port" class="headerlink" title="port"></a><code>port</code></h4><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p><p>打印某个容器端口所映射的公共端口。</p><p>选项：</p><ul><li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li><li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li></ul><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h4><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息。</li></ul><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a><code>pull</code></h4><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p><p>拉取服务依赖的镜像。</p><p>选项：</p><ul><li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li></ul><h4 id="push"><a href="#push" class="headerlink" title="push"></a><code>push</code></h4><p>推送服务依赖的镜像到 Docker 镜像仓库。</p><h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a><code>restart</code></h4><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h4><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li><li><code>-v</code> 删除容器所挂载的数据卷。</li></ul><h4 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h4><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p><p>在指定服务上执行一个命令。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure><p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><ul><li>给定命令将会覆盖原有的自动运行命令；</li><li>不会自动创建端口，以避免冲突。</li></ul><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure><p>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><ul><li><code>-d</code> 后台运行容器。</li><li><code>--name NAME</code> 为容器指定一个名字。</li><li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li><li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li><li><code>--no-deps</code> 不自动启动关联的服务容器。</li><li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li><li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li><li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li><li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li></ul><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a><code>scale</code></h4><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p><p>设置指定服务运行的容器个数。</p><p>通过 <code>service=num</code> 的参数来设置数量。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose scale web&#x3D;3 db&#x3D;2</span><br></pre></td></tr></table></figure><p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h4 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h4><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a><code>stop</code></h4><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h4 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h4><p>查看各个服务容器内运行的进程。</p><h4 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a><code>unpause</code></h4><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p><h4 id="up"><a href="#up" class="headerlink" title="up"></a><code>up</code></h4><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><ul><li><code>-d</code> 在后台运行服务容器。</li><li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li><li><code>--no-deps</code> 不启动服务所链接的容器。</li><li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li><li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li><li><code>--no-build</code> 不自动构建缺失的服务镜像。</li><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h4 id="version"><a href="#version" class="headerlink" title="version"></a><code>version</code></h4><p>格式为 <code>docker-compose version</code>。</p><p>打印版本信息。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea发布项目到git 使用</title>
      <link href="/2018/09/28/Idea/Idea%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0Git/"/>
      <url>/2018/09/28/Idea/Idea%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0Git/</url>
      
        <content type="html"><![CDATA[<h2 id="Idea发布项目到Git"><a href="#Idea发布项目到Git" class="headerlink" title="Idea发布项目到Git"></a>Idea发布项目到Git</h2><p>1、新建项目</p><a id="more"></a><ul><li><img src="http://zzpblog.cn/img/idea/1542075610448.png" alt="1542075610448"></li></ul><p><img src="http://zzpblog.cn/img/idea/1542075715230.png" alt="1542075715230"></p><p>2、打开idea要发布的项目</p><ul><li><p>VCS–Import into Version Control–Create git Respository</p></li><li><p>选择要发布的项目根目录<img src="http://zzpblog.cn/img/idea/1542075912959.png" alt="1542075912959"></p></li><li><p>右键项目目录–git–Add  项目内容加到本地git</p></li><li><p>右键项目目录–git–commit Directory 提交项目<img src="http://zzpblog.cn/img/idea/1542076032852.png" alt="1542076032852"></p></li><li><p>push <img src="http://zzpblog.cn/img/idea/1542076055244.png" alt="1542076055244"></p></li></ul><p><img src="http://zzpblog.cn/img/idea/1542076079317.png" alt="1542076079317"></p><ul><li><p>填写远程仓库的地址</p></li><li><p>这时候push会出现<img src="http://zzpblog.cn/img/idea/1542076117634.png" alt="1542076117634"></p></li><li><p>先右键项目–git–pull</p></li><li><p>会出现<img src="http://zzpblog.cn/img/idea/1542076172439.png" alt="1542076172439"></p></li><li><p>点击右下角，选择远程分支master–Rebase Current onto Selected   进行rebase把远程master更新下来</p></li></ul><p><img src="http://zzpblog.cn/img/idea/1542076207729.png" alt="1542076207729"></p><ul><li>再次Push 完成</li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>配置本地仓库</p><p>​     （1）VCS –&gt; Import into Version Control –&gt; Create Git Repository<img src="http://zzpblog.cn/img/idea/1223697-20171214155219623-814331974.png" alt="img"></p><p>​     （2）选择本地仓库位置（个人比较喜欢放在项目根目录下）</p><p><img src="http://zzpblog.cn/img/idea/1223697-20171214155419763-69054599.png" alt="img"></p><p>​     （3）创建完成后会在该位置生成一个.git文件</p><p><img src="http://zzpblog.cn/img/idea/1223697-20171214155555076-724220232.png" alt="img"></p><p>3：提交代码到本地仓库</p><p>​     （1）首先要add（<code>将目录下所有新增和修改存至缓存区，但不包括删除</code>）。</p><p>​               更改或新增的文件颜色会变为红色，意为可add。</p><p>​               add过后的文件颜色会变为绿色</p><p><img src="http://zzpblog.cn/img/idea/1223697-20171214160214076-1743250031.png" alt="img"></p><p>​     （2）其次要commit （将缓存区中的内容保存至本地仓库），文件为绿色意为可commit</p><p><img src="http://zzpblog.cn/img/idea/1223697-20171214160355826-1175305687.png" alt="img"></p><p>4：建立本地仓库与远程仓库的连接</p><p>​     如果没有远程仓库，需要创建一个远成仓库。可以自己搭建一个，也可以使用码云、coding等。</p><p>​     这里使用的是coding。</p><p>​     （1）打开Remotes</p><p><img src="http://zzpblog.cn/img/idea/1223697-20171214161119513-539226367.png" alt="img">     （2）在弹出的小窗口里点击加号，URL里填写在coding创建的项目所提供的https SSH链接。点击ok。</p><p><img src="http://zzpblog.cn/img/idea/1223697-20171214161436076-2130661491.png" alt="img"></p><p>​     （3）正常情况下到这里已经成功建立连接了。</p><p>​             在这里可能会出现这个错误：Remote URL test failed: unable to access ‘<a href="https://git.coding.net/taobu/back.git/&#39;" target="_blank" rel="noopener">https://git.coding.net/taobu/back.git/&#39;</a>: The requested URL returned error: 403</p><p>​             这个问题有可能是我们在coding或码云或github上注册账号所使用的邮箱与我们在本地配置git时使用的邮箱不一致。</p><p>​             解决方案是使用相同的邮箱即可</p><p>5：上传到远程仓库</p><p>​     （1）push到远程仓库</p><p><img src="http://zzpblog.cn/img/idea/1223697-20171214162044326-1064106412.png" alt="img"></p><p>​     （2）登录我们的远程仓库，在我们创建的项目中可以看得到已经有一个分支已成功推送</p>]]></content>
      
      
      <categories>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-compose 使用</title>
      <link href="/2018/09/28/docker/Docker-compose%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/28/docker/Docker-compose%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="docker-compose-使用"><a href="#docker-compose-使用" class="headerlink" title="docker-compose 使用"></a>docker-compose 使用</h1><a id="more"></a><h2 id="1、新建docker-compose-yml"><a href="#1、新建docker-compose-yml" class="headerlink" title="1、新建docker-compose.yml"></a>1、新建docker-compose.yml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;docker&#x2F;tomcat    &#x2F;&#x2F;已tomcat为例，tomcat目录为应用目录，没有可以创建</span><br><span class="line">$ vi docker-compose.yml</span><br></pre></td></tr></table></figure><h2 id="2、docker-compose-yml书写"><a href="#2、docker-compose-yml书写" class="headerlink" title="2、docker-compose.yml书写"></a>2、docker-compose.yml书写</h2><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  tomcat:</span><br><span class="line">    restart: always</span><br><span class="line">    image: tomcat</span><br><span class="line">    container_name: tomcat</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br></pre></td></tr></table></figure><p><code>version: &#39;3&#39;</code>  docker-compose的版本</p><p><code>services:</code> 代表服务</p><p><code>tomcat:</code> 服务的名字，这个名字可以随便起，前面为两个空格，不能按tab</p><p><code>image:</code>要使用的镜像,前面四个空格</p><p><code>container_name:</code>容器名字，前面四个空格</p><p><code>ports</code>：启动的端口</p><h4 id="运行-compose-项目"><a href="#运行-compose-项目" class="headerlink" title="运行 compose 项目"></a>运行 compose 项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose down</span><br></pre></td></tr></table></figure><h3 id="更换docker-compose路径"><a href="#更换docker-compose路径" class="headerlink" title="更换docker-compose路径"></a>更换docker-compose路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f &#x2F;usr&#x2F;local&#x2F;。。</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>编写tomcat+mysql的docker-compose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    restart: always</span><br><span class="line">    image: tomcat</span><br><span class="line">    container_name: web</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;usr&#x2F;local&#x2F;docker&#x2F;dapeng&#x2F;ROOT:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT</span><br><span class="line">  mysql:</span><br><span class="line">    restart: always</span><br><span class="line">    image: mysql:5.7.22</span><br><span class="line">    container_name: mysql</span><br><span class="line">    ports:</span><br><span class="line">      - 3306:3306</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia&#x2F;Shanghai</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    command:</span><br><span class="line">      --character-set-server&#x3D;utf8mb4</span><br><span class="line">      --collation-server&#x3D;utf8mb4_general_ci</span><br><span class="line">      --explicit_defaults_for_timestamp&#x3D;true</span><br><span class="line">      --lower_case_table_names&#x3D;1</span><br><span class="line">      --max_allowed_packet&#x3D;128M</span><br><span class="line">      --sql-mode&#x3D;&quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql-data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">volumes:</span><br><span class="line">  mysql-data:</span><br></pre></td></tr></table></figure><p>其中：environment为环境变量设置<br>     command:为初始化命令<br>     volumes：数据卷，这里的mysql-data:/var/lib/mysql   mysql-data在下面<br>     volumes:<br>       mysql-data:<br>     声明一个统一的mysql-data数据卷，数据一般放在/var目录下：默认目录放在/var/lib/docker/volumes下</p><p>启动 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-compose安装</title>
      <link href="/2018/09/28/docker/Docker-compose%E5%AE%89%E8%A3%85/"/>
      <url>/2018/09/28/docker/Docker-compose%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>什么是Docker-compose、Docker-compose安装</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="Docker-compose安装"><a href="#Docker-compose安装" class="headerlink" title="Docker-compose安装"></a>Docker-compose安装</h1><h2 id="什么是Docker-compose"><a href="#什么是Docker-compose" class="headerlink" title="什么是Docker-compose"></a>什么是Docker-compose</h2><p>Docker Compose` 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p><p>之前启动必须是要docker run 后面加一堆参数部署很麻烦，Docker-compose就是用来解决这个问题的。其实就是为了简化原生docker使用。</p><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p><p>其代码目前在 <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a> 上开源。</p><p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p><p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p><code>Compose</code> 中有两个重要的概念：</p><ul><li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li></ul><p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p><h2 id="Docker-Compose-安装与卸载"><a href="#Docker-Compose-安装与卸载" class="headerlink" title="Docker Compose 安装与卸载"></a>Docker Compose 安装与卸载</h2><p><code>Compose</code> 支持 Linux、macOS、Windows 10 三大平台。</p><p><code>Compose</code> 可以通过 Python 的包管理工具 <code>pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。</p><p>前两种方式是传统方式，适合本地环境下安装使用；最后一种方式则不破坏系统环境，更适合云计算场景。</p><p><code>Docker for Mac</code> 、<code>Docker for Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line"></span><br><span class="line">docker-compose version 1.17.1, build 6d101fb</span><br></pre></td></tr></table></figure><p>Linux 系统请使用以下介绍的方法安装。</p><h3 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h3><p>在 Linux 上的也安装十分简单，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。</p><p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.22.0&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line">$ sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="PIP-安装"><a href="#PIP-安装" class="headerlink" title="PIP 安装"></a>PIP 安装</h3><p><em>注：</em> <code>x86_64</code> 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 <code>ARM</code> (例如，树莓派)，再使用 <code>pip</code> 安装。</p><p>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</p><p>执行安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install -U docker-compose</span><br></pre></td></tr></table></figure><p>可以看到类似如下输出，说明安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collecting docker-compose</span><br><span class="line">  Downloading docker-compose-1.17.1.tar.gz (149kB): 149kB downloaded</span><br><span class="line">...</span><br><span class="line">Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress</span><br></pre></td></tr></table></figure><h3 id="bash-补全命令"><a href="#bash-补全命令" class="headerlink" title="bash 补全命令"></a>bash 补全命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;docker&#x2F;compose&#x2F;1.8.0&#x2F;contrib&#x2F;completion&#x2F;bash&#x2F;docker-compose &gt; &#x2F;etc&#x2F;bash_completion.d&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="容器中执行"><a href="#容器中执行" class="headerlink" title="容器中执行"></a>容器中执行</h3><p>Compose 既然是一个 Python 应用，自然也可以直接用容器来执行它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.8.0&#x2F;run.sh &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line">$ chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><p>实际上，查看下载的 <code>run.sh</code> 脚本内容，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">set -e</span><br><span class="line"></span><br><span class="line">VERSION&#x3D;&quot;1.8.0&quot;</span><br><span class="line">IMAGE&#x3D;&quot;docker&#x2F;compose:$VERSION&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Setup options for connecting to docker host</span><br><span class="line">if [ -z &quot;$DOCKER_HOST&quot; ]; then</span><br><span class="line">    DOCKER_HOST&#x3D;&quot;&#x2F;var&#x2F;run&#x2F;docker.sock&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -S &quot;$DOCKER_HOST&quot; ]; then</span><br><span class="line">    DOCKER_ADDR&#x3D;&quot;-v $DOCKER_HOST:$DOCKER_HOST -e DOCKER_HOST&quot;</span><br><span class="line">else</span><br><span class="line">    DOCKER_ADDR&#x3D;&quot;-e DOCKER_HOST -e DOCKER_TLS_VERIFY -e DOCKER_CERT_PATH&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Setup volume mounts for compose config and context</span><br><span class="line">if [ &quot;$(pwd)&quot; !&#x3D; &#39;&#x2F;&#39; ]; then</span><br><span class="line">    VOLUMES&#x3D;&quot;-v $(pwd):$(pwd)&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -n &quot;$COMPOSE_FILE&quot; ]; then</span><br><span class="line">    compose_dir&#x3D;$(dirname $COMPOSE_FILE)</span><br><span class="line">fi</span><br><span class="line"># TODO: also check --file argument</span><br><span class="line">if [ -n &quot;$compose_dir&quot; ]; then</span><br><span class="line">    VOLUMES&#x3D;&quot;$VOLUMES -v $compose_dir:$compose_dir&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -n &quot;$HOME&quot; ]; then</span><br><span class="line">    VOLUMES&#x3D;&quot;$VOLUMES -v $HOME:$HOME -v $HOME:&#x2F;root&quot; # mount $HOME in &#x2F;root to share docker.config</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Only allocate tty if we detect one</span><br><span class="line">if [ -t 1 ]; then</span><br><span class="line">    DOCKER_RUN_OPTIONS&#x3D;&quot;-t&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -t 0 ]; then</span><br><span class="line">    DOCKER_RUN_OPTIONS&#x3D;&quot;$DOCKER_RUN_OPTIONS -i&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec docker run --rm $DOCKER_RUN_OPTIONS $DOCKER_ADDR $COMPOSE_OPTIONS $VOLUMES -w &quot;$(pwd)&quot; $IMAGE &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>可以看到，它其实是下载了 <code>docker/compose</code> 镜像并运行。</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>如果是二进制包方式安装的，删除二进制文件即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><p>如果是通过 <code>pip</code> 安装的，则执行如下命令即可删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip uninstall docker-compose</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装mysql</title>
      <link href="/2018/09/27/docker/Docker%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85mysql/"/>
      <url>/2018/09/27/docker/Docker%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85mysql/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>Docker安装mysql</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="Docker安装mysql"><a href="#Docker安装mysql" class="headerlink" title="Docker安装mysql"></a>Docker安装mysql</h1><h2 id="1、拉取官方镜像"><a href="#1、拉取官方镜像" class="headerlink" title="1、拉取官方镜像"></a>1、拉取官方镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql:5.7.22</span><br></pre></td></tr></table></figure><h2 id="2、运行mysql"><a href="#2、运行mysql" class="headerlink" title="2、运行mysql"></a>2、运行mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456 \</span><br><span class="line">-d mysql:5.7.22</span><br></pre></td></tr></table></figure><p>注意，如果挂载宿主机目录不存在则会自动创建该文件夹</p><p>命令参数：</p><p>-p 3306:3306：将容器的3306端口映射到主机的3306端口<br>-v /usr/local/docker/mysql/conf:/etc/mysql：将主机当前目录下的 conf 挂载到容器的 /etc/mysql<br>-v /usr/local/docker/mysql/logs:/var/log/mysql：将主机当前目录下的 logs 目录挂载到容器的 /var/log/mysql<br>-v /usr/local/docker/mysql/data:/var/lib/mysql：将主机当前目录下的 data 目录挂载到容器的 /var/lib/mysql<br>-e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码<br>其中镜像mysql的存放目录如何获得：通过 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm mysql:5.7.22 bash 进入msql</span><br><span class="line">$ ls -al</span><br><span class="line">$ whereis mysql</span><br><span class="line">mysql: &#x2F;usr&#x2F;bin&#x2F;mysql &#x2F;usr&#x2F;lib&#x2F;mysql &#x2F;etc&#x2F;mysql &#x2F;usr&#x2F;share&#x2F;mysql</span><br></pre></td></tr></table></figure><h2 id="3、修改max-allowed-packet"><a href="#3、修改max-allowed-packet" class="headerlink" title="3、修改max_allowed_packet"></a>3、修改max_allowed_packet</h2><ul><li>先暂时不适用conf这个数据卷<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456 \</span><br><span class="line">-d mysql:5.7.22</span><br></pre></td></tr></table></figure></li><li>进入运行的mysql<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it mysql bash</span><br></pre></td></tr></table></figure></li><li>找到mysql中的max_allowed_packet<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;etc&#x2F;mysql&#x2F;</span><br><span class="line">$ echo &quot;max_allowed_packet&#x3D; 128M&quot; &gt;&gt; mysql.conf.d</span><br></pre></td></tr></table></figure></li><li>将mysql容器里的配置文件夹拷贝到宿主机的数据卷</li><li>先进入宿主机<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;conf</span><br><span class="line">$ docker cp mysql:&#x2F;etc&#x2F;mysql .</span><br><span class="line">相当于在宿主机运行命令 拷贝容器mysql中&#x2F;etc&#x2F;mysql 文件夹   到 . 也就是本目录</span><br><span class="line">然后将mysql中的东西全部移动到conf下</span><br><span class="line">$ cd mysql</span><br><span class="line">$ mv *.* ..</span><br><span class="line">$ rm -fr mysql</span><br><span class="line">$ docker rm -f mysql容器id</span><br></pre></td></tr></table></figure></li><li>重新启动一个新的容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456 \</span><br><span class="line">-d mysql:5.7.22</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker数据卷</title>
      <link href="/2018/09/27/docker/Docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
      <url>/2018/09/27/docker/Docker%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>Docker数据卷</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="Docker数据卷"><a href="#Docker数据卷" class="headerlink" title="Docker数据卷"></a>Docker数据卷</h1><p>由于Docker容器—对象，容器一旦销毁则，容器内的数据则一并会被删除<br>数据无法持久化</p><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享数据和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p></blockquote><h3 id="选择-v-还是-–mount-参数"><a href="#选择-v-还是-–mount-参数" class="headerlink" title="选择 -v 还是 -–mount 参数"></a>选择 -v 还是 -–mount 参数</h3><p>Docker 新用户应该选择 <code>--mount</code> 参数，经验丰富的 Docker 使用者对 <code>-v</code> 或者 <code>--volume</code> 已经很熟悉了，但是推荐使用 <code>--mount</code> 参数。</p><h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br></pre></td></tr></table></figure><p>查看所有的 <code>数据卷</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line"></span><br><span class="line">local               my-vol</span><br></pre></td></tr></table></figure><p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;my-vol&#x2F;_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/webapp</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    # -v my-vol:&#x2F;wepapp \</span><br><span class="line">    --mount source&#x3D;my-vol,target&#x3D;&#x2F;webapp \</span><br><span class="line">    training&#x2F;webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 信息在 “Mounts” Key 下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;my-vol&#x2F;_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;&#x2F;app&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure><p>实例：</p><p>已tomcat为例</p><p>先创建自己的ROOT目录，将tomcat中的ROOT挂在到自己的ROOT目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;docker&#x2F;tomcat&#x2F;ROOT</span><br><span class="line">$ mkdir ROOT</span><br><span class="line">$ cd vi index.html   创建一个html</span><br><span class="line">$ docker run -p 8080:8080 --name tomcat -d -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;tomcat&#x2F;ROOT:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT tomcat  </span><br><span class="line">-d守护太运行  -v挂在一个数据卷</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;docker&#x2F;tomcat&#x2F;ROOT 为宿主机目录  </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT 为镜像内tomcat中ROOT的目录</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker镜像(二)</title>
      <link href="/2018/09/27/docker/Docker%E9%95%9C%E5%83%8F(%E4%BA%8C)/"/>
      <url>/2018/09/27/docker/Docker%E9%95%9C%E5%83%8F(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>Dockerfile镜像操作</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="Dockerfile镜像操作"><a href="#Dockerfile镜像操作" class="headerlink" title="Dockerfile镜像操作"></a>Dockerfile镜像操作</h1><h2 id="1、WORKDIR-指定工作目录"><a href="#1、WORKDIR-指定工作目录" class="headerlink" title="1、WORKDIR 指定工作目录"></a>1、WORKDIR 指定工作目录</h2><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN cd &#x2F;app</span><br><span class="line">RUN echo &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><hr><h2 id="2、COPY-复制文件"><a href="#2、COPY-复制文件" class="headerlink" title="2、COPY 复制文件"></a>2、COPY 复制文件</h2><p>格式：</p><ul><li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener"><code>filepath.Match</code></a> 规则，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><hr><h2 id="3、ADD高级复制"><a href="#3、ADD高级复制" class="headerlink" title="3、ADD高级复制"></a>3、ADD高级复制</h2><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz &#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p><p>在 Docker 官方的 <code>Dockerfile 最佳实践文档</code> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p><hr><h2 id="4、CMD容器启动命令"><a href="#4、CMD容器启动命令" class="headerlink" title="4、CMD容器启动命令"></a>4、CMD容器启动命令</h2><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD echo $HOME</span><br></pre></td></tr></table></figure><p>在实际执行中，会将其变更为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 <code>CMD</code> 写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p><p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><hr><h2 id="5、EXPOSE-暴露端口"><a href="#5、EXPOSE-暴露端口" class="headerlink" title="5、EXPOSE 暴露端口"></a>5、EXPOSE 暴露端口</h2><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 <code>--icc=false</code>，当指定该参数后，容器间将默认无法互访，除非互相间使用了 <code>--links</code> 参数的容器才可以互通，并且只有镜像中 <code>EXPOSE</code> 所声明的端口才可以被访问。这个 <code>--icc=false</code> 的用法，在引入了 <code>docker network</code> 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h2 id="6、ENTRYPOINT-入口点"><a href="#6、ENTRYPOINT-入口点" class="headerlink" title="6、ENTRYPOINT 入口点"></a>6、ENTRYPOINT 入口点</h2><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p><h3 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h3><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*</span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value &quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in $PATH\&quot;\n&quot;.</span><br></pre></td></tr></table></figure><p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http:&#x2F;&#x2F;ip.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*</span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br><span class="line"></span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Server: nginx&#x2F;1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP&#x2F;5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h3 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h3><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">...</span><br><span class="line"># allow the container to be started with &#96;--user&#96;</span><br><span class="line">if [ &quot;$1&quot; &#x3D; &#39;redis-server&#39; -a &quot;$(id -u)&quot; &#x3D; &#39;0&#39; ]; then</span><br><span class="line">    chown -R redis .</span><br><span class="line">    exec su-exec redis &quot;$0&quot; &quot;$@&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id</span><br><span class="line">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br></pre></td></tr></table></figure><h2 id="7、ENV设置环境变量"><a href="#7、ENV设置环境变量" class="headerlink" title="7、ENV设置环境变量"></a>7、ENV设置环境变量</h2><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION&#x3D;1.0 DEBUG&#x3D;on \</span><br><span class="line">    NAME&#x3D;&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;node-v$NODE_VERSION-linux-x64.tar.xz&quot; \</span><br><span class="line">  &amp;&amp; curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;SHASUMS256.txt.asc&quot; \</span><br><span class="line">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="line">  &amp;&amp; grep &quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c - \</span><br><span class="line">  &amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C &#x2F;usr&#x2F;local --strip-components&#x3D;1 \</span><br><span class="line">  &amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="line">  &amp;&amp; ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;nodejs</span><br></pre></td></tr></table></figure><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p><p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker镜像(一)</title>
      <link href="/2018/09/27/docker/Docker%E9%95%9C%E5%83%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/09/27/docker/Docker%E9%95%9C%E5%83%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>Dockerfile定制镜像</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="Dockerfile定制镜像"><a href="#Dockerfile定制镜像" class="headerlink" title="Dockerfile定制镜像"></a>Dockerfile定制镜像</h1><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p><code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>首先建立一个Docker目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;local</span><br><span class="line">$ mkdir docker</span><br><span class="line">$ cd docker</span><br></pre></td></tr></table></figure><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mynginx</span><br><span class="line">$ cd mynginx</span><br><span class="line">$ vi Dockerfile</span><br></pre></td></tr></table></figure><p>其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code>就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://store.docker.com/" target="_blank" rel="noopener">Docker Store</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://store.docker.com/images/nginx/" target="_blank" rel="noopener"><code>nginx</code></a>、<a href="https://store.docker.com/images/redis/" target="_blank" rel="noopener"><code>redis</code></a>、<a href="https://store.docker.com/images/mongo/" target="_blank" rel="noopener"><code>mongo</code></a>、<a href="https://store.docker.com/images/mysql/" target="_blank" rel="noopener"><code>mysql</code></a>、<a href="https://store.docker.com/images/httpd/" target="_blank" rel="noopener"><code>httpd</code></a>、<a href="https://store.docker.com/images/php/" target="_blank" rel="noopener"><code>php</code></a>、<a href="https://store.docker.com/images/tomcat/" target="_blank" rel="noopener"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://store.docker.com/images/node" target="_blank" rel="noopener"><code>node</code></a>、<a href="https://store.docker.com/images/openjdk/" target="_blank" rel="noopener"><code>openjdk</code></a>、<a href="https://store.docker.com/images/python/" target="_blank" rel="noopener"><code>python</code></a>、<a href="https://store.docker.com/images/ruby/" target="_blank" rel="noopener"><code>ruby</code></a>、<a href="https://store.docker.com/images/golang/" target="_blank" rel="noopener"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://store.docker.com/images/ubuntu/" target="_blank" rel="noopener"><code>ubuntu</code></a>、<a href="https://store.docker.com/images/debian/" target="_blank" rel="noopener"><code>debian</code></a>、<a href="https://store.docker.com/images/centos/" target="_blank" rel="noopener"><code>centos</code></a>、<a href="https://store.docker.com/images/fedora/" target="_blank" rel="noopener"><code>fedora</code></a>、<a href="https://store.docker.com/images/alpine/" target="_blank" rel="noopener"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/" target="_blank" rel="noopener"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd" target="_blank" rel="noopener"><code>coreos/etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><ul><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</p></li><li><pre><code>docker exec -it 容器id bash<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">既然 &#96;RUN&#96; 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</span><br></pre></td></tr></table></figure>FROM debian:jessie</code></pre></li></ul><p>RUN apt-get update<br>RUN apt-get install -y gcc libc6-dev make<br>RUN wget -O redis.tar.gz “<a href="http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</a><br>RUN mkdir -p /usr/src/redis<br>RUN tar -xzf redis.tar.gz -C /usr/src/redis –strip-components=1<br>RUN make -C /usr/src/redis<br>RUN make -C /usr/src/redis install</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">之前说过，Dockerfile 中每一个指令都会建立一层，&#96;RUN&#96; 也不例外。每一个 &#96;RUN&#96; 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，&#96;commit&#96; 这一层的修改，构成新的镜像。</span><br><span class="line"></span><br><span class="line">而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</span><br><span class="line">这是很多初学 Docker 的人常犯的一个错误。</span><br><span class="line"></span><br><span class="line">*Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。*</span><br><span class="line"></span><br><span class="line">上面的 &#96;Dockerfile&#96; 正确的写法应该是这样：</span><br></pre></td></tr></table></figure><p>FROM debian:jessie</p><p>RUN buildDeps=’gcc libc6-dev make’ <br>    &amp;&amp; apt-get update <br>    &amp;&amp; apt-get install -y $buildDeps <br>    &amp;&amp; wget -O redis.tar.gz “<a href="http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</a> <br>    &amp;&amp; mkdir -p /usr/src/redis <br>    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis –strip-components=1 <br>    &amp;&amp; make -C /usr/src/redis <br>    &amp;&amp; make -C /usr/src/redis install <br>    &amp;&amp; rm -rf /var/lib/apt/lists/* <br>    &amp;&amp; rm redis.tar.gz <br>    &amp;&amp; rm -r /usr/src/redis <br>    &amp;&amp; apt-get purge -y –auto-remove $buildDeps</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 &#96;RUN&#96; 对一一对应不同的命令，而是仅仅使用一个 &#96;RUN&#96; 指令，并使用 &#96;&amp;&amp;&#96; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</span><br><span class="line"></span><br><span class="line">并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 &#96;\&#96; 的命令换行方式，以及行首 &#96;#&#96; 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</span><br><span class="line"></span><br><span class="line">此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 &#96;apt&#96; 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</span><br><span class="line"></span><br><span class="line">很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</span><br><span class="line"></span><br><span class="line">### WORKDIR 工作目录</span><br><span class="line"></span><br><span class="line">类似于cd ，而且通过交互式方式进入时候会直接进入到nginx目录下</span><br></pre></td></tr></table></figure><p>WORKDIR /usr/share/nginx/  切换到nginx目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 构建镜像</span><br><span class="line"></span><br><span class="line">好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</span><br><span class="line"></span><br><span class="line">在 &#96;Dockerfile&#96; 文件所在目录执行：</span><br></pre></td></tr></table></figure><p>$ docker build -t nginx:v3 .<br>Sending build context to Docker daemon 2.048 kB<br>Step 1 : FROM nginx<br> —&gt; e43d811ce2f4<br>Step 2 : RUN echo ‘<h1>Hello, Docker!</h1>‘ &gt; /usr/share/nginx/html/index.html<br> —&gt; Running in 9cdc27646c7b<br> —&gt; 44aa4490ce2c<br>Removing intermediate container 9cdc27646c7b<br>Successfully built 44aa4490ce2c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 &#96;Step 2&#96; 中，如同我们之前所说的那样，&#96;RUN&#96; 指令启动了一个容器 &#96;9cdc27646c7b&#96;，执行了所要求的命令，并最后提交了这一层 &#96;44aa4490ce2c&#96;，随后删除了所用到的这个容器 &#96;9cdc27646c7b&#96;。</span><br><span class="line"></span><br><span class="line">这里我们使用了 &#96;docker build&#96; 命令进行镜像构建。其格式为：</span><br></pre></td></tr></table></figure><p>docker build [选项] &lt;上下文路径/URL/-&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这里我们指定了最终镜像的名称 &#96;-t nginx:v3&#96;，构建成功后，我们可以像之前运行 &#96;nginx:v2&#96; 那样来运行这个镜像，其结果会和 &#96;nginx:v2&#96; 一样。</span><br><span class="line"></span><br><span class="line">### 镜像构建上下文（Context） </span><br><span class="line"></span><br><span class="line">如果注意，会看到 &#96;docker build&#96; 命令最后有一个 &#96;.&#96;。&#96;.&#96; 表示当前目录，而 &#96;Dockerfile&#96; 就在当前目录，因此不少初学者以为这个路径是在指定 &#96;Dockerfile&#96; 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定**上下文路径**。那么什么是上下文呢？</span><br><span class="line"></span><br><span class="line">首先我们要理解 &#96;docker build&#96; 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 [Docker Remote API](https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;api&#x2F;docker_remote_api&#x2F;)，而如 &#96;docker&#96; 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 &#96;docker&#96; 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</span><br><span class="line"></span><br><span class="line">当我们进行镜像构建的时候，并非所有定制都会通过 &#96;RUN&#96; 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 &#96;COPY&#96; 指令、&#96;ADD&#96; 指令等。而 &#96;docker build&#96; 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</span><br><span class="line"></span><br><span class="line">这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，&#96;docker build&#96; 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</span><br><span class="line"></span><br><span class="line">如果在 &#96;Dockerfile&#96; 中这么写：</span><br></pre></td></tr></table></figure><p>COPY ./package.json /app/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.&#x2F;package.json 这个路径指的是Docker server上下文的路径</span><br><span class="line"></span><br><span class="line">&#x2F;app&#x2F; 代表宿主机docker镜像里面文件夹的位置</span><br><span class="line"></span><br><span class="line">这并不是要复制执行 &#96;docker build&#96; 命令所在的目录下的 &#96;package.json&#96;，也不是复制 &#96;Dockerfile&#96; 所在目录下的 &#96;package.json&#96;，而是复制 **上下文（context）**目录下的 &#96;package.json&#96;。</span><br><span class="line"></span><br><span class="line">因此，&#96;COPY&#96; 这类指令中的源文件的路径都是*相对路径(Docker Server下带过来的)*。这也是初学者经常会问的为什么 &#96;COPY ..&#x2F;package.json &#x2F;app&#96; 或者 &#96;COPY &#x2F;opt&#x2F;xxxx &#x2F;app&#96; 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</span><br><span class="line"></span><br><span class="line">现在就可以理解刚才的命令 &#96;docker build -t nginx:v3 .&#96; 中的这个 &#96;.&#96;，实际上是在指定上下文的目录，&#96;docker build&#96; 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</span><br><span class="line"></span><br><span class="line">如果观察 &#96;docker build&#96; 输出，我们其实已经看到了这个发送上下文的过程：</span><br></pre></td></tr></table></figure><p>$ docker build -t nginx:v3 .<br>Sending build context to Docker daemon 2.048 kB<br>…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 &#96;COPY &#x2F;opt&#x2F;xxxx &#x2F;app&#96; 不工作后，于是干脆将 &#96;Dockerfile&#96; 放到了硬盘根目录去构建，结果发现 &#96;docker build&#96; 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 &#96;docker build&#96; 打包整个硬盘，这显然是使用错误。</span><br><span class="line"></span><br><span class="line">一般来说，应该会将 &#96;Dockerfile&#96; 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 &#96;.gitignore&#96; 一样的语法写一个 &#96;.dockerignore&#96;，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</span><br><span class="line"></span><br><span class="line">那么为什么会有人误以为 &#96;.&#96; 是指定 &#96;Dockerfile&#96; 所在目录呢？这是因为在默认情况下，如果不额外指定 &#96;Dockerfile&#96; 的话，会将上下文目录下的名为 &#96;Dockerfile&#96;的文件作为 Dockerfile。</span><br><span class="line"></span><br><span class="line">这只是默认行为，实际上 &#96;Dockerfile&#96; 的文件名并不要求必须为 &#96;Dockerfile&#96;，而且并不要求必须位于上下文目录中，比如可以用 &#96;-f ..&#x2F;Dockerfile.php&#96; 参数指定某个文件作为 &#96;Dockerfile&#96;。</span><br><span class="line"></span><br><span class="line">当然，一般大家习惯性的会使用默认的文件名 &#96;Dockerfile&#96;，以及会将其置于镜像构建上下文目录中。</span><br><span class="line"></span><br><span class="line">![1538029922544](http:&#x2F;&#x2F;www.zzpblog.cn&#x2F;img&#x2F;1538029922544.png)</span><br><span class="line"></span><br><span class="line">![1538029716957](http:&#x2F;&#x2F;www.zzpblog.cn&#x2F;img&#x2F;1538029716957.png)</span><br><span class="line"></span><br><span class="line">![1538030531675](http:&#x2F;&#x2F;www.zzpblog.cn&#x2F;img&#x2F;1538030531675.png)</span><br><span class="line"></span><br><span class="line">实例操作：</span><br></pre></td></tr></table></figure><p>$ ls -al<br>总用量 4<br>drwxr-xr-x. 2 root root  43 9月  27 15:05 .<br>drwxr-xr-x. 3 root root  20 9月  27 12:02 ..<br>-rw-r–r–. 1 root root 184 9月  27 15:05 Dockerfile<br>-rw-r–r–. 1 root root   0 9月  27 15:01 index2.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Dockerfile</span><br></pre></td></tr></table></figure><p>FROM tomcat<br>COPY index2.html /usr/local/tomcat/webapps/ROOT<br>index2.html相当于Docker Server下的路径 /usr/local/tomcat/webapps/ROOT相当于构建的镜像下的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">构建</span><br></pre></td></tr></table></figure><p>docker build -t mytomcat .<br>Sending build context to Docker daemon  7.168kB<br>Step 1/4 : FROM tomcat<br> —&gt; 41a54fe1f79d<br>Step 2/4 : COPY index2.html /usr/local/tomcat/webapps/ROOT<br> —&gt; Using cache<br> —&gt; 9cd9b0da59c4<br>Step 3/4 : WORKDIR /usr/local/tomcat/webapps/ROOT/<br> —&gt; Using cache<br> —&gt; 5f678b9212c9<br>Step 4/4 : RUN echo “hello Docker” &gt; /usr/local/tomcat/webapps/ROOT/index.html<br> —&gt; Running in 64deebaa2c4a<br>Removing intermediate container 64deebaa2c4a<br> —&gt; 99f30d526966<br>Successfully built 99f30d526966<br>Successfully tagged myshop:latest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">进入构建的镜像</span><br></pre></td></tr></table></figure><p>docker run -it –rm myshop bash<br>root@886e2d6031b0:/usr/local/tomcat/webapps/ROOT#ls -al<br>total 192<br>drwxr-xr-x. 1 root root    24 Sep 27 07:09 .<br>drwxr-xr-x. 1 root root    18 Sep  4 22:29 ..<br>-rw-r–r–. 1 root root  7142 Sep  4 22:30 RELEASE-NOTES.txt<br>drwxr-xr-x. 2 root root    21 Sep 12 20:48 WEB-INF<br>-rw-r–r–. 1 root root 27235 Sep  4 22:30 asf-logo-wide.svg<br>-rw-r–r–. 1 root root   713 Sep  4 22:29 bg-button.png<br>-rw-r–r–. 1 root root  1918 Sep  4 22:29 bg-middle.png<br>-rw-r–r–. 1 root root  1392 Sep  4 22:29 bg-nav-item.png<br>-rw-r–r–. 1 root root  1401 Sep  4 22:29 bg-nav.png<br>-rw-r–r–. 1 root root  3103 Sep  4 22:29 bg-upper.png<br>-rw-r–r–. 1 root root 21630 Sep  4 22:29 favicon.ico<br>-rw-r–r–. 1 root root    13 Sep 27 07:09 index.html<br>-rw-r–r–. 1 root root 12290 Sep  4 22:30 index.jsp<br>-rw-r–r–. 1 root root     0 Sep 27 07:01 index2.html     此文件已经拷贝<br>-rw-r–r–. 1 root root  2376 Sep  4 22:29 tomcat-power.gif<br>-rw-r–r–. 1 root root  5581 Sep  4 22:30 tomcat.css<br>-rw-r–r–. 1 root root  2066 Sep  4 22:29 tomcat.gif<br>-rw-r–r–. 1 root root  5103 Sep  4 22:29 tomcat.png<br>-rw-r–r–. 1 root root 67795 Sep  4 22:30 tomcat.svg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT&#x2F;</span><br><span class="line">RUN rm -fr *</span><br><span class="line">RUN echo &quot;hello Docker&quot; &gt; &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;ROOT&#x2F;index.html</span><br><span class="line"></span><br><span class="line">### 其它 &#96;docker build&#96; 的用法</span><br><span class="line"></span><br><span class="line">#### 直接用 Git repo 进行构建</span><br><span class="line"></span><br><span class="line">或许你已经注意到了，&#96;docker build&#96; 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</span><br></pre></td></tr></table></figure><p>$ docker build <a href="https://github.com/twang2218/gitlab-ce-zh.git#:8.14" target="_blank" rel="noopener">https://github.com/twang2218/gitlab-ce-zh.git#:8.14</a><br>docker build <a href="https://github.com/twang2218/gitlab-ce-zh.git\#:8.14" target="_blank" rel="noopener">https://github.com/twang2218/gitlab-ce-zh.git\#:8.14</a><br>Sending build context to Docker daemon 2.048 kB<br>Step 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0<br>8.14.0-ce.0: Pulling from gitlab/gitlab-ce<br>aed15891ba52: Already exists<br>773ae8583d14: Already exists<br>…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这行命令指定了构建所需的 Git repo，并且指定默认的 &#96;master&#96; 分支，构建目录为 &#96;&#x2F;8.14&#x2F;&#96;，然后 Docker 就会自己去 &#96;git clone&#96; 这个项目、切换到指定分支、并进入到指定目录后开始构建。</span><br><span class="line"></span><br><span class="line">#### 用给定的 tar 压缩包构建</span><br></pre></td></tr></table></figure><p>$ docker build <a href="http://server/context.tar.gz" target="_blank" rel="noopener">http://server/context.tar.gz</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果所给出的 URL 不是个 Git repo，而是个 &#96;tar&#96; 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</span><br><span class="line"></span><br><span class="line">#### 从标准输入中读取 Dockerfile 进行构建</span><br></pre></td></tr></table></figure><p>docker build - &lt; Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">或</span><br></pre></td></tr></table></figure><p>cat Dockerfile | docker build -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果标准输入传入的是文本文件，则将其视为 &#96;Dockerfile&#96;，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 &#96;COPY&#96; 进镜像之类的事情。</span><br><span class="line"></span><br><span class="line">#### 从标准输入中读取上下文压缩包进行构建</span><br></pre></td></tr></table></figure><p>$ docker build - &lt; context.tar.gz</p><p>```</p><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker镜像使用</title>
      <link href="/2018/09/27/docker/Docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/27/docker/Docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>Docker镜像使用、获取、列表、删除</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="Docker镜像的使用"><a href="#Docker镜像的使用" class="headerlink" title="Docker镜像的使用"></a>Docker镜像的使用</h1><h2 id="1、获取镜像"><a href="#1、获取镜像" class="headerlink" title="1、获取镜像"></a>1、获取镜像</h2><p>之前提到过，<a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]&#x2F;]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:16.04</span><br><span class="line">16.04: Pulling from library&#x2F;ubuntu</span><br><span class="line">bf5d46315322: Pull complete</span><br><span class="line">9f13e0ac480c: Pull complete</span><br><span class="line">e8988b5b3097: Pull complete</span><br><span class="line">40af181810e7: Pull complete</span><br><span class="line">e6f7c7e5c03e: Pull complete</span><br><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span><br><span class="line">Status: Downloaded newer image for ubuntu:16.04</span><br></pre></td></tr></table></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:16.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>16.04</code> 的镜像。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p><p><em>如果从 Docker Hub 下载镜像非常缓慢，可以参照 镜像加速器 配置加速器。</em></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:16.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm \</span><br><span class="line">    ubuntu:16.04 \</span><br><span class="line">    bash</span><br><span class="line"></span><br><span class="line">root@e7009c6ce357:&#x2F;# cat &#x2F;etc&#x2F;os-release</span><br><span class="line">NAME&#x3D;&quot;Ubuntu&quot;</span><br><span class="line">VERSION&#x3D;&quot;16.04.4 LTS, Trusty Tahr&quot;</span><br><span class="line">ID&#x3D;ubuntu</span><br><span class="line">ID_LIKE&#x3D;debian</span><br><span class="line">PRETTY_NAME&#x3D;&quot;Ubuntu 16.04.4 LTS&quot;</span><br><span class="line">VERSION_ID&#x3D;&quot;16.04&quot;</span><br><span class="line">HOME_URL&#x3D;&quot;http:&#x2F;&#x2F;www.ubuntu.com&#x2F;&quot;</span><br><span class="line">SUPPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;help.ubuntu.com&#x2F;&quot;</span><br><span class="line">BUG_REPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;bugs.launchpad.net&#x2F;ubuntu&#x2F;&quot;</span><br></pre></td></tr></table></figure><p><code>docker run</code> 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。</p><ul><li><code>-it</code>：已交互的方式运行容器，这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:16.04</code>：这是指用 <code>ubuntu:16.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 16.04.4 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h3 id="已交互的方式运行容器"><a href="#已交互的方式运行容器" class="headerlink" title="已交互的方式运行容器"></a>已交互的方式运行容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 8080:8080 tomcat</span><br><span class="line">$ docker run -P tomcat  P代表随机端口</span><br><span class="line">$ docker exec -it 容器id bash&#96;</span><br></pre></td></tr></table></figure><h2 id="2、列出镜像"><a href="#2、列出镜像" class="headerlink" title="2、列出镜像"></a>2、列出镜像</h2><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code>或者使用 <code>docker images</code> 列出所有镜像 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis                latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx                latest              05a60462f8ba        5 days ago          181 MB</span><br><span class="line">mongo                3.2                 fe9198c04d62        5 days ago          342 MB</span><br><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br><span class="line">ubuntu               16.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">ubuntu               latest              f753707788c5        4 weeks ago         127 MB</span><br><span class="line">ubuntu               14.04               1e0c3dd64ccd        4 weeks ago         188 MB</span><br></pre></td></tr></table></figure><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个<strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:16.04</code> 和 <code>ubuntu:latest</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:16.04</code> 镜像大小，在这里是 <code>127 MB</code>，但是在 <a href="https://hub.docker.com/r/library/ubuntu/tags/" target="_blank" rel="noopener">Docker Hub</a> 显示的却是 <code>50 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker system df</span></span><br><span class="line"></span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span><br><span class="line">Images              24                  0                   1.992GB             1.992GB (100%)</span><br><span class="line">Containers          1                   0                   62.82MB             62.82MB (100%)</span><br><span class="line">Local Volumes       9                   0                   652.2MB             652.2MB (100%)</span><br><span class="line">Build Cache                                                 0B                  0B</span><br></pre></td></tr></table></figure><h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls -f dangling=<span class="literal">true</span></span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。<br>注意！！！！需要先删除容器，不然镜像无法删除！！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image prune</span></span><br></pre></td></tr></table></figure><h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls -a</span></span><br></pre></td></tr></table></figure><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h3 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h3><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><p>根据仓库名列出镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls ubuntu</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               f753707788c5        4 weeks ago         127 MB</span><br><span class="line">ubuntu              latest              f753707788c5        4 weeks ago         127 MB</span><br><span class="line">ubuntu              14.04               1e0c3dd64ccd        4 weeks ago         188 MB</span><br></pre></td></tr></table></figure><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls ubuntu:16.04</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              16.04               f753707788c5        4 weeks ago         127 MB</span><br></pre></td></tr></table></figure><p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls -f since=mongo:3.2</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx               latest              05a60462f8ba        5 days ago          181 MB</span><br></pre></td></tr></table></figure><p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p><p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls -f label=com.example.version=0.1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h3><p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls -q</span></span><br><span class="line">5f515359c7f8</span><br><span class="line">05a60462f8ba</span><br><span class="line">fe9198c04d62</span><br><span class="line">00285df0df87</span><br><span class="line">f753707788c5</span><br><span class="line">f753707788c5</span><br><span class="line">1e0c3dd64ccd</span><br></pre></td></tr></table></figure><p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p><p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <a href="https://gohugo.io/templates/go-templates/" target="_blank" rel="noopener">Go 的模板语法</a>。</p><p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls --format <span class="string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span></span></span><br><span class="line">5f515359c7f8: redis</span><br><span class="line">05a60462f8ba: nginx</span><br><span class="line">fe9198c04d62: mongo</span><br><span class="line">00285df0df87: &lt;none&gt;</span><br><span class="line">f753707788c5: ubuntu</span><br><span class="line">f753707788c5: ubuntu</span><br><span class="line">1e0c3dd64ccd: ubuntu</span><br></pre></td></tr></table></figure><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls --format <span class="string">"table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span></span></span><br><span class="line">IMAGE ID            REPOSITORY          TAG</span><br><span class="line">5f515359c7f8        redis               latest</span><br><span class="line">05a60462f8ba        nginx               latest</span><br><span class="line">fe9198c04d62        mongo               3.2</span><br><span class="line">00285df0df87        &lt;none&gt;              &lt;none&gt;</span><br><span class="line">f753707788c5        ubuntu              16.04</span><br><span class="line">f753707788c5        ubuntu              latest</span><br><span class="line">1e0c3dd64ccd        ubuntu              14.04</span><br></pre></td></tr></table></figure><h2 id="3、删除本地镜像"><a href="#3、删除本地镜像" class="headerlink" title="3、删除本地镜像"></a>3、删除本地镜像</h2><p>如果要删除本地的镜像，<br>注意！！！！需要先删除容器，不然镜像无法删除！！<br>可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br><span class="line">或者</span><br><span class="line">$ docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span><br><span class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</span><br><span class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</span><br><span class="line">nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</span><br></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm 501</span><br><span class="line">Untagged: redis:alpine</span><br><span class="line">Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</span><br><span class="line">Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</span><br><span class="line">Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</span><br><span class="line">Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</span><br><span class="line">Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</span><br><span class="line">Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</span><br><span class="line">Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm centos</span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --digests</span><br><span class="line">REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB</span><br><span class="line"></span><br><span class="line">$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br><span class="line">Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure><h3 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h3><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的源。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h3 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q redis)</span><br></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q -f before&#x3D;mongo:3.2)</span><br></pre></td></tr></table></figure><p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p><h3 id="CentOS-RHEL-的用户需要注意的事项"><a href="#CentOS-RHEL-的用户需要注意的事项" class="headerlink" title="CentOS/RHEL 的用户需要注意的事项"></a>CentOS/RHEL 的用户需要注意的事项</h3><p>在 Ubuntu/Debian 上有 <code>UnionFS</code> 可以使用，如 <code>aufs</code> 或者 <code>overlay2</code>，而 CentOS 和 RHEL 的内核中没有相关驱动。因此对于这类系统，一般使用 <code>devicemapper</code> 驱动利用 LVM 的一些机制来模拟分层存储。这样的做法除了性能比较差外，稳定性一般也不好，而且配置相对复杂。Docker 安装在 CentOS/RHEL 上后，会默认选择 <code>devicemapper</code>，但是为了简化配置，其 <code>devicemapper</code> 是跑在一个稀疏文件模拟的块设备上，也被称为 <code>loop-lvm</code>。这样的选择是因为不需要额外配置就可以运行 Docker，这是自动配置唯一能做到的事情。但是 <code>loop-lvm</code> 的做法非常不好，其稳定性、性能更差，无论是日志还是 <code>docker info</code> 中都会看到警告信息。官方文档有明确的文章讲解了如何配置块设备给 <code>devicemapper</code> 驱动做存储层的做法，这类做法也被称为配置 <code>direct-lvm</code>。</p><p>除了前面说到的问题外，<code>devicemapper</code> + <code>loop-lvm</code> 还有一个缺陷，因为它是稀疏文件，所以它会不断增长。用户在使用过程中会注意到 <code>/var/lib/docker/devicemapper/devicemapper/data</code> 不断增长，而且无法控制。很多人会希望删除镜像或者可以解决这个问题，结果发现效果并不明显。原因就是这个稀疏文件的空间释放后基本不进行垃圾回收的问题。因此往往会出现即使删除了文件内容，空间却无法回收，随着使用这个稀疏文件一直在不断增长。</p><p>所以对于 CentOS/RHEL 的用户来说，在没有办法使用 <code>UnionFS</code> 的情况下，一定要配置 <code>direct-lvm</code> 给 <code>devicemapper</code>，无论是为了性能、稳定性还是空间利用率。</p><p><em>或许有人注意到了 CentOS 7 中存在被 backports 回来的 overlay 驱动，不过 CentOS 里的这个驱动达不到生产环境使用的稳定程度，所以不推荐使用。</em></p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装</title>
      <link href="/2018/09/27/docker/Docker%E5%AE%89%E8%A3%85/"/>
      <url>/2018/09/27/docker/Docker%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>Docker分为两个版本：Docker-ce 社区版（免费）、Docker-EE 企业版（收费）</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="一、安装docker"><a href="#一、安装docker" class="headerlink" title="一、安装docker"></a>一、安装docker</h1><p>Docker分为两个版本：Docker-ce 社区版（免费）、Docker-EE 企业版（收费）</p><h2 id="1、Ubuntu-安装-Docker"><a href="#1、Ubuntu-安装-Docker" class="headerlink" title="1、Ubuntu 安装 Docker"></a>1、Ubuntu 安装 Docker</h2><blockquote><p>警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.</p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h4><p>Docker CE 支持以下版本的 <a href="https://www.ubuntu.com/server" target="_blank" rel="noopener">Ubuntu</a> 操作系统：</p><ul><li>Artful 17.10 (Docker CE 17.11 Edge +)</li><li>Xenial 16.04 (LTS)</li><li>Trusty 14.04 (LTS)</li></ul><p>Docker CE 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本,当前最新的 LTS 版本为 Ubuntu 16.04。</p><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker \</span><br><span class="line">               docker-engine \</span><br><span class="line">               docker.io</span><br></pre></td></tr></table></figure><h4 id="Ubuntu-14-04-可选内核模块"><a href="#Ubuntu-14-04-可选内核模块" class="headerlink" title="Ubuntu 14.04 可选内核模块"></a>Ubuntu 14.04 可选内核模块</h4><p>从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (<code>linux-image-extra-*</code>) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。<code>AUFS</code> 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 <code>AUFS</code>。</p><p>如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    linux-image-extra-$(uname -r) \</span><br><span class="line">    linux-image-extra-virtual</span><br></pre></td></tr></table></figure><h4 id="Ubuntu-16-04"><a href="#Ubuntu-16-04" class="headerlink" title="Ubuntu 16.04 +"></a>Ubuntu 16.04 +</h4><p>Ubuntu 16.04 + 上的 Docker CE 默认使用 <code>overlay2</code> 存储层驱动,无需手动配置。</p><h3 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h3><p>由于 <code>apt</code> 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code> 密钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># $ curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>然后，我们需要向 <code>source.list</code> 中添加 Docker 软件源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">    &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">    $(lsb_release -cs) \</span><br><span class="line">    stable&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># $ sudo add-apt-repository \</span><br><span class="line">#    &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">#    $(lsb_release -cs) \</span><br><span class="line">#    stable&quot;</span><br></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要最新或者测试版本的 Docker CE 请将 stable 改为 edge 或者 test。从 Docker 17.06 开始，edge test 版本的 APT 镜像源也会包含稳定版本的 Docker。</p></blockquote><h4 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h4><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><h3 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h3><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line"># 可能会出现 404 错误，请移步下面的特别说明</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。</p><h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><p>2018 年 7 月 21 日，貌似阿里云这边在做调整，故导致 Docker 的 Aliyun 安装脚本不可用，是永久性还是临时性的尚不清除，如果你已经按照之前的操作安装 Docker，请按以下步骤进行修复并重新安装</p><ul><li>如果已经使用了 Aliyun 脚本安装并成功的<ul><li>请先卸载 Docker，命令为：<code>apt-get autoremove docker-ce</code></li><li>删除 <code>/etc/apt/sources.list.d</code> 目录下的 <code>docker.list</code> 文件</li></ul></li><li>使用 <code>AzureChinaCloud</code> 镜像脚本重新安装，命令为：<code>sudo sh get-docker.sh --mirror AzureChinaCloud</code></li></ul><h3 id="启动-Docker-CE"><a href="#启动-Docker-CE" class="headerlink" title="启动 Docker CE"></a>启动 Docker CE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>Ubuntu 14.04 请使用以下命令启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker start</span><br></pre></td></tr></table></figure><h3 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><p>将当前用户加入 <code>docker</code> 组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p>退出当前终端并重新登录，进行如下测试。</p><h3 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">ca4f61b1923c: Pull complete</span><br><span class="line">Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https:&#x2F;&#x2F;cloud.docker.com&#x2F;</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;userguide&#x2F;</span><br></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p><h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 <code>国内镜像加速</code>。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Docker 官方 Ubuntu 安装文档</a></li></ul><h2 id="2、CentOS-安装-Docker"><a href="#2、CentOS-安装-Docker" class="headerlink" title="2、CentOS 安装 Docker"></a>2、CentOS 安装 Docker</h2><blockquote><p>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.</p></blockquote><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="系统要求-1"><a href="#系统要求-1" class="headerlink" title="系统要求"></a>系统要求</h4><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。</p><h4 id="卸载旧版本-1"><a href="#卸载旧版本-1" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h3 id="使用-yum-安装"><a href="#使用-yum-安装" class="headerlink" title="使用 yum 安装"></a>使用 yum 安装</h3><p>执行以下命令安装依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p>执行下面的命令添加 <code>yum</code> 软件源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line"># $ sudo yum-config-manager \</span><br><span class="line">#     --add-repo \</span><br><span class="line">#     https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><p>如果需要最新版本的 Docker CE 请使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --enable docker-ce-edge</span><br></pre></td></tr></table></figure><p>如果需要测试版本的 Docker CE 请使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --enable docker-ce-test</span><br></pre></td></tr></table></figure><h4 id="安装-Docker-CE-1"><a href="#安装-Docker-CE-1" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h4><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="使用脚本自动安装-1"><a href="#使用脚本自动安装-1" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h3><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。</p><h3 id="启动-Docker-CE-1"><a href="#启动-Docker-CE-1" class="headerlink" title="启动 Docker CE"></a>启动 Docker CE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="建立-docker-用户组-1"><a href="#建立-docker-用户组-1" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><p>将当前用户加入 <code>docker</code> 组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p>退出当前终端并重新登录，进行如下测试。</p><h3 id="测试-Docker-是否安装正确-1"><a href="#测试-Docker-是否安装正确-1" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">ca4f61b1923c: Pull complete</span><br><span class="line">Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https:&#x2F;&#x2F;cloud.docker.com&#x2F;</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;userguide&#x2F;</span><br></pre></td></tr></table></figure><p>若能正常输出以上信息，则说明安装成功。</p><h3 id="镜像加速-1"><a href="#镜像加速-1" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 <code>国内镜像加速</code>。</p><h3 id="添加内核参数"><a href="#添加内核参数" class="headerlink" title="添加内核参数"></a>添加内核参数</h3><p>默认配置下，如果在 CentOS 使用 Docker CE 看到下面的这些警告信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: bridge-nf-call-iptables is disabled</span><br><span class="line">WARNING: bridge-nf-call-ip6tables is disabled</span><br></pre></td></tr></table></figure><p>请添加内核配置参数以启用这些功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tee -a &#x2F;etc&#x2F;sysctl.conf &lt;&lt;-EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后重新加载 <code>sysctl.conf</code> 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -p</span><br></pre></td></tr></table></figure><h3 id="参考文档-1"><a href="#参考文档-1" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/" target="_blank" rel="noopener">Docker 官方 CentOS 安装文档</a>。</li></ul><h2 id="3、Docker-镜像加速器"><a href="#3、Docker-镜像加速器" class="headerlink" title="3、Docker 镜像加速器"></a>3、Docker 镜像加速器</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" target="_blank" rel="noopener">Docker 官方提供的中国 registry mirror</a></li><li><a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a></li><li><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a></li></ul><p>我们以 Docker 官方加速器为例进行介绍。</p><h3 id="Ubuntu-14-04、Debian-7-Wheezy"><a href="#Ubuntu-14-04、Debian-7-Wheezy" class="headerlink" title="Ubuntu 14.04、Debian 7 Wheezy"></a>Ubuntu 14.04、Debian 7 Wheezy</h3><p>对于使用 <a href="http://upstart.ubuntu.com/" target="_blank" rel="noopener">upstart</a> 的系统而言，编辑 <code>/etc/default/docker</code> 文件，在其中的 <code>DOCKER_OPTS</code> 中配置加速器地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS&#x3D;&quot;--registry-mirror&#x3D;https:&#x2F;&#x2F;registry.docker-cn.com&quot;</span><br></pre></td></tr></table></figure><p>重新启动服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure><h3 id="Ubuntu-16-04-、Debian-8-、CentOS-7"><a href="#Ubuntu-16-04-、Debian-8-、CentOS-7" class="headerlink" title="Ubuntu 16.04+、Debian 8+、CentOS 7"></a>Ubuntu 16.04+、Debian 8+、CentOS 7</h3><p>对于使用 <a href="https://www.freedesktop.org/wiki/Software/systemd/" target="_blank" rel="noopener">systemd</a> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p></blockquote><p>之后重新启动服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果您之前查看旧教程，修改了 <code>docker.service</code> 文件内容，请去掉您添加的内容（<code>--registry-mirror=https://registry.docker-cn.com</code>），这里不再赘述。</p></blockquote><h3 id="Windows-10"><a href="#Windows-10" class="headerlink" title="Windows 10"></a>Windows 10</h3><p>对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 <code>Settings</code>，打开配置窗口后左侧导航菜单选择 <code>Daemon</code>。在 <code>Registry mirrors</code>一栏中填写加速器地址 <code>https://registry.docker-cn.com</code>，之后点击 <code>Apply</code> 保存后 Docker 就会重启并应用配置的镜像地址了。</p><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>对于使用 macOS 的用户，在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址 <code>https://registry.docker-cn.com</code>。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了。</p><h3 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h3><p>配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 <code>docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https:&#x2F;&#x2F;registry.docker-cn.com&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker仓库</title>
      <link href="/2018/09/27/docker/Docker%E4%BB%93%E5%BA%93/"/>
      <url>/2018/09/27/docker/Docker%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>公有 Docker Registry 私有 Docker Registry</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<code>Docker Registry</code> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个<strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个<strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>以 <a href="https://store.docker.com/images/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>14.04</code>, <code>16.04</code>。我们可以通过 <code>ubuntu:14.04</code>，或者 <code>ubuntu:16.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="公有-Docker-Registry"><a href="#公有-Docker-Registry" class="headerlink" title="公有 Docker Registry"></a>公有 Docker Registry</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 <a href="https://coreos.com/" target="_blank" rel="noopener">CoreOS</a> 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，<a href="http://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的镜像使用的就是这个服务。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为<strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p><h3 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://store.docker.com/images/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p><p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 中，提供了这些高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/vmware/harbor" target="_blank" rel="noopener">VMWare Harbor</a> 和 <a href="https://www.sonatype.com/docker" target="_blank" rel="noopener">Sonatype Nexus</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker引擎架构</title>
      <link href="/2018/09/27/docker/Docker%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/09/27/docker/Docker%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。</p><p>一种服务器，它是一种称为守护进程并且长时间运行的程序。<br>REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。<br>一个有命令行界面 (CLI) 工具的客户端。</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><h1 id="Docker引擎"><a href="#Docker引擎" class="headerlink" title="Docker引擎"></a>Docker引擎</h1><p>Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。</p><p>一种服务器，它是一种称为守护进程并且长时间运行的程序。<br>REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。<br>一个有命令行界面 (CLI) 工具的客户端。<br>Docker 引擎组件的流程如下图所示：</p><p><img src="http://www.zzpblog.cn/img/620140640_31678.png" alt="img"><br>如图所示，Docker需要学习的由容器、镜像、网络、数据卷，通过Dockercli命令行工具操作</p><hr><h1 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p><p>Docker 容器通过 Docker 镜像来创建。</p><p>容器与镜像的关系类似于面向对象编程中的对象与类。</p><p>例如：User.class 镜像</p><p>User user=new User() 容器，也就是说定制镜像，部署只需要new一个容器就可以直接使用</p><table><thead><tr><th>Docker</th><th>面向对象</th></tr></thead><tbody><tr><td>容器</td><td>对象</td></tr><tr><td>镜像</td><td>类</td></tr></tbody></table><p><img src="http://www.zzpblog.cn/img/262150629_86976.png" alt="img"></p><p>图例说明：<br>docker build：构建命令–docker守护进程—构建Ubuntu镜像—docker run镜像，启动容器<br>docker pull：拉取走官方找取镜像比如Ubuntu镜像—docker run镜像，启动容器</p><table><thead><tr><th>标题</th><th>说明</th></tr></thead><tbody><tr><td>镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板。</td></tr><tr><td>容器(Container)</td><td>容器是独立运行的一个或一组应用。</td></tr><tr><td>客户端(Client)</td><td>Docker 客户端通过命令行或者其他工具使用 Docker API (<a href="https://docs.docker.com/reference/api/docker_remote_api" target="_blank" rel="noopener">https://docs.docker.com/reference/api/docker_remote_api</a>) 与 Docker 的守护进程通信。</td></tr><tr><td>主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td>仓库(Registry)</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</td></tr><tr><td>Docker Machine</td><td>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么用Docker</title>
      <link href="/2018/09/27/docker/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Docker/"/>
      <url>/2018/09/27/docker/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Docker/</url>
      
        <content type="html"><![CDATA[<p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p><a id="more"></a><h3 id="更高效的利用系统资源"><a href="#更高效的利用系统资源" class="headerlink" title="更高效的利用系统资源"></a>更高效的利用系统资源</h3><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h3 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h3><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h3 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h3><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><h3 id="持续交付和部署"><a href="#持续交付和部署" class="headerlink" title="持续交付和部署"></a>持续交付和部署</h3><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <code>Dockerfile</code> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="noopener">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="noopener">持续部署(Continuous Delivery/Deployment)</a> 系统进行自动部署。</p><p>而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h3 id="更轻松的迁移"><a href="#更轻松的迁移" class="headerlink" title="更轻松的迁移"></a>更轻松的迁移</h3><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><h3 id="更轻松的维护和扩展"><a href="#更轻松的维护和扩展" class="headerlink" title="更轻松的维护和扩展"></a>更轻松的维护和扩展</h3><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易（例如 TOMCAT继承JAVA，那么TOMCAT就默认已经装了JAVA），也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://store.docker.com/search?q=&source=verified&type=image" target="_blank" rel="noopener">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h3 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h3><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为 <code>MB</code></td><td>一般为 <code>GB</code></td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker初探</title>
      <link href="/2018/09/27/docker/Docker%E5%88%9D%E6%8E%A2/"/>
      <url>/2018/09/27/docker/Docker%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>&lt;Excerpt in index | 首页摘要&gt;<br>关于Docker是什么</p><a id="more"></a><p>&lt;The rest of contents | 余下全文&gt;</p><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 <a href="https://en.wikipedia.org/wiki/Docker_(software)" target="_blank" rel="noopener">2013 年 3 月以 Apache 2.0 授权协议开源</a>，主要项目代码在 <a href="https://github.com/moby/moby" target="_blank" rel="noopener">GitHub</a> 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 <a href="https://www.opencontainers.org/" target="_blank" rel="noopener">开放容器联盟（OCI）</a>。</p><p>Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，<a href="https://blog.docker.com/2013/10/dotcloud-is-becoming-docker-inc/" target="_blank" rel="noopener">dotCloud 公司决定改名为 Docker</a>。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p><p>Docker 使用 Google 公司推出的 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a> 和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd</a>。</p><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="http://www.zzpblog.cn/img/virtualization.png" alt="传统虚拟化"></p><p><img src="http://www.zzpblog.cn/img/docker.png" alt="Docker"></p><p>我们现在使用的是1.12版本，从1.11到1.12是一个里程碑</p><p>hypervisor：一种运行在物理服务器和操作系统之间的中间层软件，可以允许多个操作系统和应用共享一套基础物理硬件。可以将hypervisor看做是虚拟环境中的“元”操作系统，可以协调访问服务器上的所有物理设备和虚拟机，所以又称为虚拟机监视器（virtual machine monitor）。hypervisor是所有虚拟化技术的核心，非中断的支持多工作负载迁移是hypervisor的基本功能。当服务器启动并执行hypervisor时，会给每一台虚拟机分配适量的内存，cpu，网络和磁盘资源，并且加载所有虚拟机的客户操作系统。</p><p>原始结构 <img src="http://www.zzpblog.cn/img/1537964839146.png" alt="1537964839146"></p><p>传统虚拟化：</p><p><img src="http://www.zzpblog.cn/img/1537965716161.png" alt="1537965716161"></p><ul><li><p>传统虚拟化技术是独占资源的，只能利用分配给它的部分资源</p><p>比如：一台计算机：CPU i7  4核 内存16GB</p><p>VMware 2GB内存 则这台计算机还剩余14GB可用 独占资源</p><p> VMware 2GB内存 则这台计算机还剩余12GB可用 独占资源</p><p>当VMware中有一个应用app，他占用14GB内存，则会出现内存溢出</p></li></ul><p>Docker:</p><p><img src="http://www.zzpblog.cn/img/1537965899817.png" alt="1537965899817"></p><ul><li>Docker可以利用宿主机的全部资源，共享资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件库</title>
      <link href="/2018/09/26/vue/vue%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
      <url>/2018/09/26/vue/vue%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>===官方===</p><ul><li><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">https://github.com/vuejs/vue</a><a id="more"></a><h4 id="vue-components组件库"><a href="#vue-components组件库" class="headerlink" title="vue-components组件库"></a>vue-components组件库</h4></li></ul><p>—PC端—</p><ul><li><a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">https://github.com/ElemeFE/element</a> <code>Vue2.0 PC端UI组件库</code></li><li><a href="https://github.com/iview/iview" target="_blank" rel="noopener">https://github.com/iview/iview</a> <code>一套基于 Vue.js 的高质量 UI 组件库</code></li><li><a href="https://github.com/jackbarham/vuejs-style-guide" target="_blank" rel="noopener">https://github.com/jackbarham/vuejs-style-guide</a> <code>Vue UI框架 vibecast UI风格</code></li><li><a href="https://github.com/luojilab/radon-ui" target="_blank" rel="noopener">https://github.com/luojilab/radon-ui</a> <code>一个帮助你快速开发产品的Vue组件库，简洁好用，效率高，让你摆脱各种定制化的烦恼</code></li><li><a href="https://github.com/myronliu347/vue-carbon" target="_blank" rel="noopener">https://github.com/myronliu347/vue-carbon</a> <code>基于vue开发的material design ui库</code></li><li><a href="https://github.com/N3-components/N3-components" target="_blank" rel="noopener">https://github.com/N3-components/N3-components</a> <code>Vue UI组件库</code></li><li><a href="https://github.com/okoala/vue-antd" target="_blank" rel="noopener">https://github.com/okoala/vue-antd</a> <code>Vue版 ant.design UI组件库</code></li><li><a href="https://github.com/posva/vue-mdl" target="_blank" rel="noopener">https://github.com/posva/vue-mdl</a> <code>Material Design Lite 组件库</code></li><li><a href="https://github.com/rafaelpimpa/buefy" target="_blank" rel="noopener">https://github.com/rafaelpimpa/buefy</a> <code>基于 Bulma 的 Vue.js 轻量级 UI 组件库</code></li><li><a href="https://github.com/AT-UI/at-ui" target="_blank" rel="noopener">https://github.com/AT-UI/at-ui</a> <code>at-ui 一款基于 Vue.js 2.0 的前端 UI 组件库，主要用于快速开发 PC 网站产品</code></li><li><a href="https://github.com/vuetifyjs/vuetify" target="_blank" rel="noopener">https://github.com/vuetifyjs/vuetify</a> <code>基于 Material 的 Vue.js 2.0 前端 UI 组件库</code></li><li><a href="https://github.com/myliang/fish-ui" target="_blank" rel="noopener">https://github.com/myliang/fish-ui</a> <code>一个 Vue.js 2.0 的 Web UI 工具库</code></li><li><a href="https://github.com/wmfe/xcui" target="_blank" rel="noopener">https://github.com/wmfe/xcui</a> <code>基于Vue2.0 的桌面端组件库</code></li></ul><p>—移动端—</p><ul><li><a href="https://github.com/airyland/vux" target="_blank" rel="noopener">https://github.com/airyland/vux</a><code>vue 微信UI组件库</code></li><li><a href="https://github.com/mennghao/vue-mui" target="_blank" rel="noopener">https://github.com/mennghao/vue-mui</a><code>Vue UI组件库</code></li><li><a href="https://github.com/wdfe/wdui" target="_blank" rel="noopener">https://github.com/wdfe/wdui</a><code>基于 Vue 2.0 的移动 UI 组件库</code></li><li><a href="https://github.com/youzan/vant" target="_blank" rel="noopener">https://github.com/youzan/vant</a><code>有赞开发的基于 Vue.js 2.0 的 UI 组件库</code></li><li><a href="https://github.com/ydcss/vue-ydui" target="_blank" rel="noopener">https://github.com/ydcss/vue-ydui</a><code>一只基于Vue2.x的移动端&amp;微信UI。</code></li><li><a href="https://www.awesomes.cn/repo/didi/cube-ui" target="_blank" rel="noopener">https://www.awesomes.cn/repo/didi/cube-ui</a><code>滴滴团队开发的一套基于 Vue.js 实现的精致移动端组件库</code></li><li><a href="https://github.com/zdliuccit/ml-ui" target="_blank" rel="noopener">https://github.com/zdliuccit/ml-ui</a><code>一套为开发者、设计师和产品经理准备的基于 Vue 2 的移动端组件库</code></li></ul><h4 id="vue-form表单"><a href="#vue-form表单" class="headerlink" title="vue-form表单"></a>vue-form表单</h4><ul><li><a href="https://github.com/lincenying/vue2-ajax-form" target="_blank" rel="noopener">https://github.com/lincenying/vue2-ajax-form</a> <code>Vue2 ajax提交表单组件</code></li><li><a href="https://github.com/monterail/vue-multiselect" target="_blank" rel="noopener">https://github.com/monterail/vue-multiselect</a> <code>Vue 模拟select组件</code></li><li><a href="https://github.com/jinzhe/vue-calendar" target="_blank" rel="noopener">https://github.com/jinzhe/vue-calendar</a> <code>Vue 日期组件</code></li><li><a href="https://github.com/PeakTai/vue-uploader" target="_blank" rel="noopener">https://github.com/PeakTai/vue-uploader</a> <code>Vue 上传组件</code></li><li><a href="https://github.com/xiaokaike/magic-upload-image" target="_blank" rel="noopener">https://github.com/xiaokaike/magic-upload-image</a> <code>多功能图片上传，支持截图黏贴，拖拽，文件上传</code></li><li><a href="https://github.com/james2doyle/vue-ajax-form-component" target="_blank" rel="noopener">https://github.com/james2doyle/vue-ajax-form-component</a> <code>Vue ajax提交表单组件</code></li><li><a href="https://github.com/wszgxa/vue-v" target="_blank" rel="noopener">https://github.com/wszgxa/vue-v</a> <code>Vue 表单验证组件</code></li></ul><h4 id="vue-handle操作"><a href="#vue-handle操作" class="headerlink" title="vue-handle操作"></a>vue-handle操作</h4><ul><li><a href="https://github.com/MeCKodo/vue-tap" target="_blank" rel="noopener">https://github.com/MeCKodo/vue-tap</a><code>Vue的tap手势插件</code></li><li><a href="https://github.com/kokdemo/vue-href" target="_blank" rel="noopener">https://github.com/kokdemo/vue-href</a> <code>Vue的指令插件，可以让你给任何dom加上一个跳转的事件</code></li></ul><h4 id="vue-image图片"><a href="#vue-image图片" class="headerlink" title="vue-image图片"></a>vue-image图片</h4><ul><li><a href="https://github.com/waynecz/vue-img-inputer" target="_blank" rel="noopener">https://github.com/waynecz/vue-img-inputer</a> <code>基于 Vue2 的图片输入框，用于图片预览、拖拽、回填，主题可选，高度可定制</code></li><li><a href="https://github.com/hilongjw/vue-lazyload" target="_blank" rel="noopener">https://github.com/hilongjw/vue-lazyload</a> <code>Vue 图片懒加载组件</code></li><li><a href="https://github.com/JALBAA/vue-lazyload-img" target="_blank" rel="noopener">https://github.com/JALBAA/vue-lazyload-img</a> <code>Vue 图片懒加载组件</code></li><li><a href="https://github.com/qusiba/vue-slider" target="_blank" rel="noopener">https://github.com/qusiba/vue-slider</a> <code>Vue 幻灯片组件</code></li><li><a href="https://github.com/coffcer/vue-loading" target="_blank" rel="noopener">https://github.com/coffcer/vue-loading</a> <code>Vue loadding组件</code></li><li><a href="https://github.com/shhdgit/vue-easy-slider" target="_blank" rel="noopener">https://github.com/shhdgit/vue-easy-slider</a> <code>Vue.js 的轮播组件</code></li><li><a href="https://github.com/xLogic92/vue-picture-preview" target="_blank" rel="noopener">https://github.com/xLogic92/vue-picture-preview</a> <code>移动端 Vue.js 图片预览插件</code></li></ul><h4 id="vue-notice通知"><a href="#vue-notice通知" class="headerlink" title="vue-notice通知"></a>vue-notice通知</h4><ul><li><a href="https://github.com/s4l1h/vue-toastr" target="_blank" rel="noopener">https://github.com/s4l1h/vue-toastr</a> <code>Vue Toastr 组件</code></li><li><a href="https://www.npmjs.com/package/vue-toaster-plugin" target="_blank" rel="noopener">https://www.npmjs.com/package/vue-toaster-plugin</a> <code>Vue Toastr 组件</code></li></ul><h4 id="vue-other其他"><a href="#vue-other其他" class="headerlink" title="vue-other其他"></a>vue-other其他</h4><ul><li><a href="https://github.com/miaolz123/vue-markdown" target="_blank" rel="noopener">https://github.com/miaolz123/vue-markdown</a> <code>Vue markdown解析器组件</code></li><li><a href="https://github.com/wy-ei/vue-filter" target="_blank" rel="noopener">https://github.com/wy-ei/vue-filter</a> <code>Vue 过滤器组件</code></li><li><a href="https://github.com/BrockReece/vue-faker" target="_blank" rel="noopener">https://github.com/BrockReece/vue-faker</a> <code>Vue 数据伪造器</code></li><li><a href="https://github.com/Twiknight/vue-transition" target="_blank" rel="noopener">https://github.com/Twiknight/vue-transition</a> <code>Vue 处理CSS转换组件和动画</code></li><li><a href="https://github.com/shidianxia/vue-localforage" target="_blank" rel="noopener">https://github.com/shidianxia/vue-localforage</a> <code>Vue 本地存储插件</code></li><li><a href="https://github.com/jaweii/vueg" target="_blank" rel="noopener">https://github.com/jaweii/vueg</a> <code>为 webApp 提供转场特效的开源 Vue 插件</code></li><li><a href="https://github.com/jcc/v-distpicker" target="_blank" rel="noopener">https://github.com/jcc/v-distpicker</a> <code>一个简单易用的地区选择器</code></li><li><a href="https://github.com/adeptoas/sweet-modal-vue" target="_blank" rel="noopener">https://github.com/adeptoas/sweet-modal-vue</a> <code>支持 Vue.js 的漂亮模态框组件</code></li><li><a href="https://fritx.github.io/vue-at" target="_blank" rel="noopener">https://fritx.github.io/vue-at</a> <code>At.js 的 Vue.js 组件，自动完成 @ 功能</code></li><li><a href="https://github.com/epicmaxco/epic-spinners" target="_blank" rel="noopener">https://github.com/epicmaxco/epic-spinners</a> <code>一系列使用方便的 CSS loading 效果集合组件</code></li><li><a href="https://github.com/michalsnik/vue-content-placeholders" target="_blank" rel="noopener">https://github.com/michalsnik/vue-content-placeholders</a> <code>在网页内容加载完成之前渲染占位布局的 Vue 组件</code></li><li><a href="https://github.com/tipsy/bubbly-bg" target="_blank" rel="noopener">https://github.com/tipsy/bubbly-bg</a> <code>小于 1kB 的漂亮的泡状背景库</code></li><li><a href="https://github.com/chenxuan0000/vue-seamless-scroll" target="_blank" rel="noopener">https://github.com/chenxuan0000/vue-seamless-scroll</a> <code>Vue.js 无缝滚动组件</code></li></ul><p>===实例===</p><ul><li><a href="https://github.com/jackhutu/jackblog-vue" target="_blank" rel="noopener">https://github.com/jackhutu/jackblog-vue</a></li><li><a href="https://github.com/lincenying/mmf-blog-vue2" target="_blank" rel="noopener">https://github.com/lincenying/mmf-blog-vue2</a></li><li><a href="https://github.com/lincenying/mmf-blog-vue2-ssr" target="_blank" rel="noopener">https://github.com/lincenying/mmf-blog-vue2-ssr</a></li></ul><p>===资料===</p><ul><li><a href="https://github.com/vuejs/awesome-vue" target="_blank" rel="noopener">https://github.com/vuejs/awesome-vue</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue组件库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode插件集</title>
      <link href="/2018/09/26/vscode/vscode%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/09/26/vscode/vscode%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="VScode-插件工具集，不求全但求好"><a href="#VScode-插件工具集，不求全但求好" class="headerlink" title="VScode 插件工具集，不求全但求好"></a>VScode 插件工具集，不求全但求好</h1><a id="more"></a><h2 id="一、代码快捷键"><a href="#一、代码快捷键" class="headerlink" title="一、代码快捷键"></a>一、代码快捷键</h2><p>在 VScode 的首页可以设置通用快捷键，因为平常用sublime比较多，所以干脆合并成一套。</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db4b875cd6e9f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h2 id="二、代码提示"><a href="#二、代码提示" class="headerlink" title="二、代码提示"></a>二、代码提示</h2><h3 id="1-Path-Intellisense"><a href="#1-Path-Intellisense" class="headerlink" title="1. Path Intellisense"></a>1. Path Intellisense</h3><p>自动路径补全</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db5917e096057?imageslim" alt="img"></p><h3 id="2-Document-this"><a href="#2-Document-this" class="headerlink" title="2. Document this"></a>2. Document this</h3><blockquote><p>js 的注释模板 （注意：新版的 vscode 已经原生支持,在 function 上输入 <code>/** tab</code> ）</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db653d9f07827?imageslim" alt="img"></p><h2 id="三、代码格式"><a href="#三、代码格式" class="headerlink" title="三、代码格式"></a>三、代码格式</h2><h3 id="1-ESlint"><a href="#1-ESlint" class="headerlink" title="1. ESlint"></a>1. ESlint</h3><p>代码规范，对不符合要求的代码或者有语法错误的<code>**JS代码**</code>进行提示，可以自定制提示规则</p><h3 id="2-HTMLHint"><a href="#2-HTMLHint" class="headerlink" title="2. HTMLHint"></a>2. HTMLHint</h3><p><code>**html代码**</code>检测</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db679595bf974?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="3-beautify"><a href="#3-beautify" class="headerlink" title="3. beautify"></a>3. beautify</h3><p>格式化代码的工具</p><h2 id="四、代码可视化改善"><a href="#四、代码可视化改善" class="headerlink" title="四、代码可视化改善"></a>四、代码可视化改善</h2><h3 id="1-colorize"><a href="#1-colorize" class="headerlink" title="1. colorize"></a>1. colorize</h3><p>可视化颜色哦，做组件涉及很多不同的主题，个人还是蛮稀饭的</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165dd0b9349ce93c?imageslim" alt="img"></p><h3 id="2-RegExp-Preview-and-Editor"><a href="#2-RegExp-Preview-and-Editor" class="headerlink" title="2. RegExp Preview and Editor"></a>2. RegExp Preview and Editor</h3><p>这个就厉害了.可以完美的展示你写的正则,图形化给你看你写正则的形成</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165dd0e294c1267e?imageslim" alt="img"></p><h3 id="3-Better-Comments"><a href="#3-Better-Comments" class="headerlink" title="3. Better Comments"></a>3. Better Comments</h3><p>最好用的注释区域高亮,对于TODO这些支持也很好</p><h3 id="4-BreadCrumb-in-StatusBar"><a href="#4-BreadCrumb-in-StatusBar" class="headerlink" title="4. BreadCrumb in StatusBar"></a>4. BreadCrumb in StatusBar</h3><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165f02c1d66e84d6?imageslim" alt="img"></p><p>-—————————————————————————</p><blockquote><p>华丽丽的分割线，以下插件根据框架语言选择，用什么装什么，不用就不要装了，浪费内存</p></blockquote><h2 id="五、React-插件"><a href="#五、React-插件" class="headerlink" title="五、React 插件"></a>五、React 插件</h2><h3 id="1-ES7-React-Redux-GraphQL-React-Native-snippets"><a href="#1-ES7-React-Redux-GraphQL-React-Native-snippets" class="headerlink" title="1. ES7 React/Redux/GraphQL/React-Native snippets"></a>1. ES7 React/Redux/GraphQL/React-Native snippets</h3><p>涵盖的代码片段贼丰富，React 相关代码提示有这个就够了</p><h3 id="2-Useful-React-Snippets"><a href="#2-Useful-React-Snippets" class="headerlink" title="2. Useful React Snippets"></a>2. Useful React Snippets</h3><p>当然如果你只用React,那用这个代码提示吧，管够了</p><h3 id="3-CSS-Blocks"><a href="#3-CSS-Blocks" class="headerlink" title="3. CSS Blocks"></a>3. CSS Blocks</h3><p>支持css模块化的智能提示，跳转，墙裂推荐</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db89e726dc423?imageslim" alt="img"></p><h3 id="4-styled-components-snippets"><a href="#4-styled-components-snippets" class="headerlink" title="4. styled-components-snippets"></a>4. styled-components-snippets</h3><p><code>styled-components</code>的代码片段</p><h2 id="六、Vue-插件"><a href="#六、Vue-插件" class="headerlink" title="六、Vue 插件"></a>六、Vue 插件</h2><h3 id="1-vetur"><a href="#1-vetur" class="headerlink" title="1. vetur"></a>1. vetur</h3><p>语法高亮、智能感知、Emmet 等</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db5f1b9206903?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="2-VueHelper"><a href="#2-VueHelper" class="headerlink" title="2. VueHelper"></a>2. VueHelper</h3><p>snippet 代码片段</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db619907151a2?imageslim" alt="img"></p><h3 id="3-Vue-VSCode-Snippets"><a href="#3-Vue-VSCode-Snippets" class="headerlink" title="3. Vue VSCode Snippets"></a>3. Vue VSCode Snippets</h3><p>很全面的vue代码片段</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165dd1842617030d?imageslim" alt="img"></p><h2 id="七、Node"><a href="#七、Node" class="headerlink" title="七、Node"></a>七、Node</h2><h3 id="1-eggjs"><a href="#1-eggjs" class="headerlink" title="1. eggjs"></a>1. eggjs</h3><p>蛋框的相关帮助插件,代码片段,智能提示等</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db7263a88bd17?imageslim" alt="img"></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db762eedb1220?imageslim" alt="img"></p><h3 id="2-egg-jump-definition"><a href="#2-egg-jump-definition" class="headerlink" title="2. egg-jump-definition"></a>2. egg-jump-definition</h3><p>蛋框的函数跳转：<code>Cmd+4</code></p><p>``</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/15/165db7a2bbf1247c?imageslim" alt="img"></p><h2 id="八、微信小程序"><a href="#八、微信小程序" class="headerlink" title="八、微信小程序"></a>八、微信小程序</h2><h3 id="1-mpvue-snippets"><a href="#1-mpvue-snippets" class="headerlink" title="1. mpvue snippets"></a>1. mpvue snippets</h3><p><code>mpvue</code>的一些代码片段,以及部分原生小程序的代码提示</p><h3 id="2-minapp"><a href="#2-minapp" class="headerlink" title="2. minapp"></a>2. minapp</h3><p>用<code>VS Code</code>写小程序必备的插件,里面有众多实用的特性集成</p><h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h2 id="九、Markdown-插件"><a href="#九、Markdown-插件" class="headerlink" title="九、Markdown 插件"></a>九、Markdown 插件</h2><h3 id="1-Markdown-All-in-One"><a href="#1-Markdown-All-in-One" class="headerlink" title="1. Markdown All in One"></a>1. Markdown All in One</h3><p>Markdown 的提示插件用这一个足以，集成了语法快捷键、Math、预览等，很实用</p><h3 id="2-markdownlint"><a href="#2-markdownlint" class="headerlink" title="2. markdownlint"></a>2. markdownlint</h3><p>对 markdown 的语法格式规范进行代码提示</p><h2 id="十、代码审查"><a href="#十、代码审查" class="headerlink" title="十、代码审查"></a>十、代码审查</h2><h3 id="1-CodeMetrics"><a href="#1-CodeMetrics" class="headerlink" title="1. CodeMetrics"></a>1. CodeMetrics</h3><p> 可以计算TS/JS内代码的复杂度(比如函数这些),这些与代码质量和性能是挂钩的</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165f0642c7e50cf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="2-Import-Cost"><a href="#2-Import-Cost" class="headerlink" title="2.Import Cost"></a>2.Import Cost</h3><p>就是你import一个东西的时候,可以计算改引入模块的大小!</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165f064cd1dccca5?imageslim" alt="img"></p><h3 id="3-Git-Lens"><a href="#3-Git-Lens" class="headerlink" title="3. Git Lens"></a>3. <a href="https://link.juejin.im?target=https%3A%2F%2Flink.juejin.im%2F%3Ftarget%3Dhttps%253A%252F%252Fmarketplace.visualstudio.com%252Fitems%253FitemName%253Deamodio.gitlens">Git Lens</a></h3><p>暂时没有发现比这个看git记录更为详细了</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165f066a17101593?imageslim" alt="img"></p><h2 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h2><p>下面的插件可有可无，如有相应功能的需求，却也是非常棒的插件</p><h3 id="1-fileheader"><a href="#1-fileheader" class="headerlink" title="1. fileheader"></a>1. fileheader</h3><p>顶部注释模板，可定义作者、时间等信息，并会自动更新最后修改时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+alt+i</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165efe55554811e5?imageslim" alt="img"></p><h3 id="2-Paste-JSON-as-Code"><a href="#2-Paste-JSON-as-Code" class="headerlink" title="2. Paste JSON as Code"></a>2. Paste JSON as Code</h3><p>JSON 格式转换成其他的语言格式</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165f00c633f4f0a0?imageslim" alt="img"></p><h3 id="3-Node-js-Modules-Intellisense"><a href="#3-Node-js-Modules-Intellisense" class="headerlink" title="3. Node.js Modules Intellisense"></a>3. Node.js Modules Intellisense</h3><p>对于<code>node_module</code>的智能提示</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165f01769837b07c?imageslim" alt="img"></p><h3 id="4-npm-import-package-version"><a href="#4-npm-import-package-version" class="headerlink" title="4. npm-import-package-version"></a>4. npm-import-package-version</h3><p>显示导入的 npm 包的版本信息</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165f01d5c46cbf9f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="5-File-Tree-View"><a href="#5-File-Tree-View" class="headerlink" title="5. File Tree View"></a>5. File Tree View</h3><p>提供几个常见编程语言的函数或状态的树集合展示,可以快速点击跳转!!</p><h3 id="6-NPM-Scripts"><a href="#6-NPM-Scripts" class="headerlink" title="6. NPM-Scripts"></a>6. NPM-Scripts</h3><p>在侧边栏可视化执行 npm 命令(项目内的 <code>package.json</code>),  小巧实用</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165f0242b91ad27d?imageslim" alt="img"></p><h3 id="7-emojisense"><a href="#7-emojisense" class="headerlink" title="7. :emojisense:"></a>7. :emojisense:</h3><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165f05a9c21aaa9a?imageslim" alt="img"></p><h2 id="十二、代码片段"><a href="#十二、代码片段" class="headerlink" title="十二、代码片段"></a>十二、代码片段</h2><p>两种方式定义代码片段</p><ul><li>菜单栏-&gt;文件-&gt;首选项-&gt;用户代码片段</li><li>ctrl+shift + p =&gt; snippet</li></ul><p><img src="https://user-gold-cdn.xitu.io/2017/2/23/204d3456162156dec5fa099ce73d8595?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="è¿éåå¾çæè¿°"></p><p><code>toRem</code>: 只是一个单纯的描述</p><p><code>prefix</code>: 是触发snippet的简写</p><p><code>body</code>: 是展开的代码片段</p><p><code>$1,$2：</code>表示占位符，用于用户展开代码片段所需要替换的，也可以写成<code>${1:label}</code>键值对的方式</p><p><code>description</code> : 用户你在输出snippet之前，方便自己识别的注释，而不用强行记忆那些简写的</p><p>来源：<a href="https://juejin.im/post/5b9c7a0b6fb9a05d2778f631" target="_blank" rel="noopener">https://juejin.im/post/5b9c7a0b6fb9a05d2778f631</a> 掘金</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于vscode(一)</title>
      <link href="/2018/09/25/vscode/vscode%20git/"/>
      <url>/2018/09/25/vscode/vscode%20git/</url>
      
        <content type="html"><![CDATA[<h2 id="主要用于记录关于vscode操作git的一些注意事项以及使用方式"><a href="#主要用于记录关于vscode操作git的一些注意事项以及使用方式" class="headerlink" title="主要用于记录关于vscode操作git的一些注意事项以及使用方式"></a>主要用于记录关于vscode操作git的一些注意事项以及使用方式</h2><a id="more"></a><p>1、点击第三个进入页面<br>2、点击初始化存储库，弹出框项目所在的根目录选择文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3、git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;zc.com&#x2F;nuxtproject.git   命令行输入这个后面的地址为git的地址，和远程git链接</span><br><span class="line">4、git remote -v查看远程git地址</span><br><span class="line">5、git pull origin master --allow-unrelated-histories 合并pushmaster分之</span><br><span class="line">6、更改代码后可以点击加号暂存，然后消息框内输入提交的信息，然后再快捷键ctrl+enter提交，然后使用命令</span><br><span class="line">git push origin master  将代码push 或者使用点击，推送进行push</span><br><span class="line">git config --global user.email &quot;352761120@qq.com&quot;</span><br></pre></td></tr></table></figure><p>7、ctrl+shift+P或者</p><p>面板，输入git有提示创建分之，</p><p>可以切换分之</p><p>如果push这个分之不管用git push –set-upstream origin zzp2<br>如果合并分之，同上调出面板，git有提示合并分之，选择一个要合并的分之就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令集合</title>
      <link href="/2018/09/25/Ubuntu/linxu(1)/"/>
      <url>/2018/09/25/Ubuntu/linxu(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux命令集合"><a href="#Linux命令集合" class="headerlink" title="Linux命令集合"></a>Linux命令集合</h2><a id="more"></a><h2 id="一、Linux基础命令"><a href="#一、Linux基础命令" class="headerlink" title="一、Linux基础命令"></a>一、Linux基础命令</h2><h3 id="1、ls指令"><a href="#1、ls指令" class="headerlink" title="1、ls指令"></a>1、ls指令</h3><h3 id="2、pwd命令"><a href="#2、pwd命令" class="headerlink" title="2、pwd命令"></a>2、pwd命令</h3><h3 id="3、cd命令"><a href="#3、cd命令" class="headerlink" title="3、cd命令"></a>3、cd命令</h3><h3 id="4、mkdir命令"><a href="#4、mkdir命令" class="headerlink" title="4、mkdir命令"></a>4、mkdir命令</h3><h3 id="5、touch命令"><a href="#5、touch命令" class="headerlink" title="5、touch命令"></a>5、touch命令</h3><h3 id="6、cp命令"><a href="#6、cp命令" class="headerlink" title="6、cp命令"></a>6、cp命令</h3><h3 id="7、mv命令"><a href="#7、mv命令" class="headerlink" title="7、mv命令"></a>7、mv命令</h3><h3 id="8、rm命令"><a href="#8、rm命令" class="headerlink" title="8、rm命令"></a>8、rm命令</h3><h3 id="9、vim命令"><a href="#9、vim命令" class="headerlink" title="9、vim命令"></a>9、vim命令</h3><h3 id="10、输出重定向"><a href="#10、输出重定向" class="headerlink" title="10、输出重定向"></a>10、输出重定向</h3><h3 id="11、cat命令"><a href="#11、cat命令" class="headerlink" title="11、cat命令"></a>11、cat命令</h3><h2 id="二、Linux进阶指令"><a href="#二、Linux进阶指令" class="headerlink" title="二、Linux进阶指令"></a>二、Linux进阶指令</h2><h2 id="1、df指令"><a href="#1、df指令" class="headerlink" title="1、df指令"></a>1、df指令</h2><h3 id="2、free指令"><a href="#2、free指令" class="headerlink" title="2、free指令"></a>2、free指令</h3><h3 id="3、head指令"><a href="#3、head指令" class="headerlink" title="3、head指令"></a>3、head指令</h3><h3 id="4、tail指令"><a href="#4、tail指令" class="headerlink" title="4、tail指令"></a>4、tail指令</h3><h3 id="5、less指令"><a href="#5、less指令" class="headerlink" title="5、less指令"></a>5、less指令</h3><p>作用：查看文件，以做少的内容输出，按下辅助功能键</p><h3 id="6、wc指令"><a href="#6、wc指令" class="headerlink" title="6、wc指令"></a>6、wc指令</h3><p>作用：统计文件内容信息（包含行数、单词数、字节数）</p><p>语法：#wc -lwc 文件路径</p><p>-l:行数</p><p>-w:单词数</p><p>-c:字节数</p><h3 id="7、date"><a href="#7、date" class="headerlink" title="7、date"></a>7、date</h3><p>作用：操作时间和日期（读取、设置）</p><p>小解释：CST：指的是当地时间</p><p>用法1：#date +%F或者#date +”%Y-%m-%d”</p><p>用法2  #date “+%F %T”或者#date +”%Y-%m-%d %H:%M:%S”</p><h3 id="8、cal"><a href="#8、cal" class="headerlink" title="8、cal"></a>8、cal</h3><p>作用：日历</p><p>语法：#cal 等价于#cal -1当前月日历</p><p>语法：#cal -3 三天的</p><p>语法：# cal -y  2018输出某一年的</p><h3 id="9、clear-ctrl-L指令"><a href="#9、clear-ctrl-L指令" class="headerlink" title="9、clear/ctrl+L指令"></a>9、clear/ctrl+L指令</h3><p>作用：清楚信息</p><h3 id="10、管道"><a href="#10、管道" class="headerlink" title="10、管道"></a>10、管道</h3><p>作用：一般用于过滤</p><p>语法：#ls /| grep y 需要通过管道查询出根目录下包含“y”字母的文档名称</p><p>grep主要用于过滤</p><p>扩展处理：#ls /| wc -l</p><h2 id="三、Linux高级指令"><a href="#三、Linux高级指令" class="headerlink" title="三、Linux高级指令"></a>三、Linux高级指令</h2><h3 id="1、hostname指令"><a href="#1、hostname指令" class="headerlink" title="1、hostname指令"></a>1、hostname指令</h3><p>作用：操作服务器的主机名</p><p>用法1：hostname 输出完整主机名</p><p>用法2：hostname -f 输出当前主机名中的fqdn（权限定域名）</p><h3 id="2、id指令"><a href="#2、id指令" class="headerlink" title="2、id指令"></a>2、id指令</h3><p>作用：查看一个用户的一些基本信息，不指定则默认当前用户</p><p>###　3、whoami指令</p><p>作用：显示当前的登录名</p><h3 id="4、ps-ef指令"><a href="#4、ps-ef指令" class="headerlink" title="4、ps -ef指令"></a>4、ps -ef指令</h3><p>作用：用于查看当前服务器的进程</p><p>-e：表示全部进程</p><p>-f：表示全部列</p><p>案例：#ps -ef |grep 进程名称</p><h3 id="5、top指令"><a href="#5、top指令" class="headerlink" title="5、top指令"></a>5、top指令</h3><p>作用：查看服务器进程占用的资源</p><p>语法：#top 动态资源</p><p>退出：q</p><p>解释：PR：优先级</p><p>VIRT：虚拟内存</p><p>RES：常驻内存</p><p>SHR：共享内存</p><p>​    计算一个进程实际使用的内存 = 常驻内存（RES）</p><p>注意：在运行top的时候可以按下快捷键排序，从高到底降序</p><p>M：表示内存排序</p><p>P：按照CPU使用率排序</p><p>1：当服务器有多个CPU时可以使用‘1’ 切换是否展示每个cpu的详细信息</p><h3 id="6、du-sh指令"><a href="#6、du-sh指令" class="headerlink" title="6、du -sh指令"></a>6、du -sh指令</h3><p>作用：查看目录的真实大小</p><p>-s:只显示汇总的大小</p><p>-h：表示以高可读形式显示</p><p>案例：#du -sh 后面是路径例如/etc/</p><h2 id="四、常用的命令"><a href="#四、常用的命令" class="headerlink" title="四、常用的命令"></a>四、常用的命令</h2><h3 id="1、查看系统版本"><a href="#1、查看系统版本" class="headerlink" title="1、查看系统版本"></a>1、查看系统版本</h3><p>lsb_release -a</p><h3 id="2、压缩文件"><a href="#2、压缩文件" class="headerlink" title="2、压缩文件"></a>2、压缩文件</h3><h3 id="tar压缩命令"><a href="#tar压缩命令" class="headerlink" title="tar压缩命令"></a>tar压缩命令</h3><table><thead><tr><th>tar</th><th>tar [-cxzjvf] 压缩打包文档的名称 欲打包目录</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td>-c</td><td>建立一个归档文件的参数指令压缩</td></tr><tr><td></td><td></td><td>-x</td><td>解开一个归档文件的参数指令解压</td></tr><tr><td></td><td></td><td>-z</td><td>是否需要用 gzip 压缩</td></tr><tr><td></td><td></td><td>-j</td><td>是否需要用 bzip2 压缩</td></tr><tr><td></td><td></td><td>-v</td><td>压缩的过程中显示文件</td></tr><tr><td></td><td></td><td>-f</td><td>使用档名，在 f 之后要立即接档名</td></tr><tr><td></td><td></td><td>-tf</td><td>查看归档文件里面的文件</td></tr></tbody></table><p><strong>例子：</strong></p><ul><li>压缩文件夹：<code>tar -zcvf test.tar.gz test\</code></li><li>解压文件夹：<code>tar -zxvf test.tar.gz</code></li></ul><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>gzip</td><td>gzip [选项] 压缩（解压缩）的文件名</td><td></td><td></td></tr><tr><td></td><td></td><td>-d</td><td>解压缩</td></tr><tr><td></td><td></td><td>-l</td><td>对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字</td></tr><tr><td></td><td></td><td>-v</td><td>对每一个压缩和解压的文件，显示文件名和压缩比</td></tr><tr><td></td><td></td><td>-num</td><td>用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6</td></tr></tbody></table><p>说明：压缩文件后缀为 gz</p><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>bzip2</td><td>bzip2 [-cdz]</td><td></td><td></td></tr><tr><td></td><td></td><td>-d</td><td>解压缩</td></tr><tr><td></td><td></td><td>-z</td><td>压缩参数</td></tr><tr><td></td><td></td><td>-num</td><td>用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6</td></tr></tbody></table><p>说明：压缩文件后缀为 bz2</p><h3 id="3、安装包"><a href="#3、安装包" class="headerlink" title="3、安装包"></a>3、安装包</h3><p>centos：下是使用yum install 软件名 卸载使用yum remove 软件名</p><p>Ubuntu：apt-get install 文件名 卸载使用apt-get remove 文件名</p><h4 id="centos修改数据源："><a href="#centos修改数据源：" class="headerlink" title="centos修改数据源："></a>centos修改数据源：</h4><p> 超简单将Centos的yum源更换为国内的阿里云源 </p><h4 id="1、备份"><a href="#1、备份" class="headerlink" title="1、备份"></a>1、备份</h4><p><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code>、</p><h4 id="2、下载新的CentOS-Base-repo-到-etc-yum-repos-d"><a href="#2、下载新的CentOS-Base-repo-到-etc-yum-repos-d" class="headerlink" title="2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/"></a>2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/</h4><h5 id="CentOS-5"><a href="#CentOS-5" class="headerlink" title="CentOS 5"></a>CentOS 5</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-5.repo</span><br></pre></td></tr></table></figure><h5 id="CentOS-6"><a href="#CentOS-6" class="headerlink" title="CentOS 6"></a>CentOS 6</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-6.repo</span><br></pre></td></tr></table></figure><h5 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h5><p><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></p><h4 id="3、运行yum-makecache生成缓存"><a href="#3、运行yum-makecache生成缓存" class="headerlink" title="3、运行yum makecache生成缓存"></a>3、运行yum makecache生成缓存</h4><h4 id="Ubuntu："><a href="#Ubuntu：" class="headerlink" title="Ubuntu："></a>Ubuntu：</h4><h4 id="编辑数据源"><a href="#编辑数据源" class="headerlink" title="编辑数据源"></a>编辑数据源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure><p>删除全部内容并修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h4 id="更新数据源"><a href="#更新数据源" class="headerlink" title="更新数据源"></a>更新数据源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure><h3 id="4、文件权限"><a href="#4、文件权限" class="headerlink" title="4、文件权限"></a>4、文件权限</h3><p>r 读</p><p>w 写</p><p>x 执行</p><p>ls –al<code>使用 ls 不带参数只显示文件名称，通过</code>ls –al` 可以显示文件或者目录的权限信息。</p><p><code>ls -l 文件名</code> 显示信息包括：文件类型 (<code>d</code> 目录，<code>-</code> 普通文件，<code>l</code> 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称</p><p><code>-rw-r--r-- 1 lusifer lusifer 675 Oct 26 17:20 .profile</code></p><ul><li><code>-</code>：普通文件</li><li><code>rw-</code>：说明用户 lusifer 有读写权限，没有运行权限</li><li><code>r--</code>：表示用户组 lusifer 只有读权限，没有写和运行的权限</li><li><code>r--</code>：其他用户只有读权限，没有写权限和运行的权限</li></ul><table><thead><tr><th>-rw-r–r–</th><th>1</th><th>lusifer</th><th>lusifer</th><th>675</th><th>Oct 26 17:20</th><th>.profile</th></tr></thead><tbody><tr><td>文档类型及权限</td><td>连接数</td><td>文档所属用户</td><td>文档所属组</td><td>文档大小</td><td>文档最后被修改日期</td><td>文档名称</td></tr></tbody></table><table><thead><tr><th>-</th><th>rw-</th><th>r–</th><th>r–</th></tr></thead><tbody><tr><td>文档类型</td><td>文档所有者权限（user）</td><td>文档所属用户组权限（group）</td><td>其他用户权限（other）</td></tr></tbody></table><p> 文档类型</p><ul><li><code>d</code> 表示目录</li><li><code>l</code> 表示软连接</li><li><code>–</code> 表示文件</li><li><code>c</code> 表示串行端口字符设备文件</li><li><code>b</code> 表示可供存储的块设备文件</li><li>余下的字符 3 个字符为一组。<code>r</code> 只读，<code>w</code> 可写，<code>x</code> 可执行，<code>-</code> 表示无此权限</li></ul><h4 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h4><p>指有多少个文件指向同一个索引节点。</p><h4 id="文档所属用户和所属组"><a href="#文档所属用户和所属组" class="headerlink" title="文档所属用户和所属组"></a>文档所属用户和所属组</h4><p>就是文档属于哪个用户和用户组。文件所属用户和组是可以更改的</p><h4 id="文档大小"><a href="#文档大小" class="headerlink" title="文档大小"></a>文档大小</h4><p>默认是 bytes</p><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组</p><p><code>chown [-R] 用户名称 文件或者目录</code></p><p><code>chown [-R] 用户名称 用户组名称 文件或目录</code></p><p>-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限</p><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>简单实用化chmod 直接使用chmod +x shell.sh对这个文件赋予可执行权限</p><p>不使用x执行权限   chmod -x shell.sh</p><p>执行shell.sh使用路径下的文件<img src="C:%5CUsers%5CADMINI~1.WIN%5CAppData%5CLocal%5CTemp%5C1534684170468.png" alt="1534684170468"></p><p><img src="C:%5CUsers%5CADMINI~1.WIN%5CAppData%5CLocal%5CTemp%5C1534684028323.png" alt="1534684028323"></p><p>改变访问权限</p><p><code>chmod [who] [+ | - | =] [mode] 文件名</code></p><h5 id="who"><a href="#who" class="headerlink" title="who"></a>who</h5><p>表示操作对象可以是以下字母的一个或者组合</p><ul><li>u：用户 user</li><li>g：用户组 group</li><li>o：表示其他用户</li><li>a：表示所有用户是系统默认的</li></ul><h5 id="操作符号"><a href="#操作符号" class="headerlink" title="操作符号"></a>操作符号</h5><ul><li>+：表示添加某个权限</li><li>-：表示取消某个权限</li><li>=：赋予给定的权限，取消文档以前的所有权限</li></ul><h5 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h5><p>表示可执行的权限，可以是 r、w、x</p><h5 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h5><p>文件名可以使空格分开的文件列表</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lusifer@UbuntuBase:~$ ls -al test.txt </span><br><span class="line">-rw-rw-r-- 1 lusifer lusifer 6 Nov  2 21:47 test.txt</span><br><span class="line">lusifer@UbuntuBase:~$ chmod u&#x3D;rwx,g+r,o+r test.txt </span><br><span class="line">lusifer@UbuntuBase:~$ ls -al test.txt </span><br><span class="line">-rwxrw-r-- 1 lusifer lusifer 6 Nov  2 21:47 test.txt</span><br><span class="line">lusifer@UbuntuBase:~$</span><br></pre></td></tr></table></figure><h3 id="5、数字设定法"><a href="#5、数字设定法" class="headerlink" title="5、数字设定法"></a>5、数字设定法</h3><p>数字设定法中数字表示的含义</p><ul><li>0 表示没有任何权限</li><li>1 表示有可执行权限 = <code>x</code></li><li>2 表示有可写权限 = <code>w</code></li><li>4 表示有可读权限 = <code>r</code></li></ul><p>也可以用数字来表示权限如 chmod 755 file_name</p><table><thead><tr><th>r w x</th><th>r – x</th><th>r - x</th></tr></thead><tbody><tr><td>4 2 1</td><td>4 - 1</td><td>4 - 1</td></tr><tr><td>user</td><td>group</td><td>others</td></tr></tbody></table><p>若要 rwx 属性则 4+2+1=7</p><p>若要 rw- 属性则 4+2=6</p><p>若要 r-x 属性则 4+1=5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lusifer@UbuntuBase:~$ chmod 777 test.txt </span><br><span class="line">lusifer@UbuntuBase:~$ ls -al test.txt </span><br><span class="line">-rwxrwxrwx 1 lusifer lusifer 6 Nov  2 21:47 test.txt</span><br><span class="line"></span><br><span class="line">lusifer@UbuntuBase:~$ chmod 770 test.txt </span><br><span class="line">lusifer@UbuntuBase:~$ ls -al test.txt </span><br><span class="line">-rwxrwx--- 1 lusifer lusifer 6 Nov  2 21:47 test.txt</span><br></pre></td></tr></table></figure><h2 id="五、JAVA安装"><a href="#五、JAVA安装" class="headerlink" title="五、JAVA安装"></a>五、JAVA安装</h2><h3 id="Linux-安装-Java"><a href="#Linux-安装-Java" class="headerlink" title="Linux 安装 Java"></a>Linux 安装 Java</h3><p>此处以 JDK 1.8.0_152 为例</p><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><h4 id="解压缩并移动到指定目录"><a href="#解压缩并移动到指定目录" class="headerlink" title="解压缩并移动到指定目录"></a>解压缩并移动到指定目录</h4><h5 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u152-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;java</span><br></pre></td></tr></table></figure><h5 id="移动安装包"><a href="#移动安装包" class="headerlink" title="移动安装包"></a>移动安装包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv jdk1.8.0_152&#x2F; &#x2F;usr&#x2F;local&#x2F;java&#x2F;</span><br></pre></td></tr></table></figure><h5 id="设置所有者"><a href="#设置所有者" class="headerlink" title="设置所有者"></a>设置所有者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R root:root &#x2F;usr&#x2F;local&#x2F;java&#x2F;</span><br></pre></td></tr></table></figure><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><h5 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano &#x2F;etc&#x2F;environment</span><br></pre></td></tr></table></figure><h5 id="添加如下语句"><a href="#添加如下语句" class="headerlink" title="添加如下语句"></a>添加如下语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games&quot;</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_152</span><br><span class="line">export JRE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_152&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;$CLASSPATH:$JAVA_HOME&#x2F;lib:$JAVA_HOME&#x2F;jre&#x2F;lib</span><br></pre></td></tr></table></figure><h5 id="配置用户环境变量"><a href="#配置用户环境变量" class="headerlink" title="配置用户环境变量"></a>配置用户环境变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h5 id="添加如下语句-1"><a href="#添加如下语句-1" class="headerlink" title="添加如下语句"></a>添加如下语句</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$PS1&quot; ]; then</span><br><span class="line">  if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; !&#x3D; &quot;&#x2F;bin&#x2F;sh&quot; ]; then</span><br><span class="line">    # The file bash.bashrc already sets the default PS1.</span><br><span class="line">    # PS1&#x3D;&#39;\h:\w\$ &#39;</span><br><span class="line">    if [ -f &#x2F;etc&#x2F;bash.bashrc ]; then</span><br><span class="line">      . &#x2F;etc&#x2F;bash.bashrc</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">    if [ &quot;&#96;id -u&#96;&quot; -eq 0 ]; then</span><br><span class="line">      PS1&#x3D;&#39;# &#39;</span><br><span class="line">    else</span><br><span class="line">      PS1&#x3D;&#39;$ &#39;</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_152</span><br><span class="line">export JRE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_152&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;$CLASSPATH:$JAVA_HOME&#x2F;lib:$JAVA_HOME&#x2F;jre&#x2F;lib</span><br><span class="line">export PATH&#x3D;$JAVA_HOME&#x2F;bin:$JAVA_HOME&#x2F;jre&#x2F;bin:$PATH:$HOME&#x2F;bin</span><br><span class="line"></span><br><span class="line">if [ -d &#x2F;etc&#x2F;profile.d ]; then</span><br><span class="line">  for i in &#x2F;etc&#x2F;profile.d&#x2F;*.sh; do</span><br><span class="line">    if [ -r $i ]; then</span><br><span class="line">      . $i</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">  unset i</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="使用户环境变量生效"><a href="#使用户环境变量生效" class="headerlink" title="使用户环境变量生效"></a>使用户环境变量生效</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h4 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@UbuntuBase:&#x2F;usr&#x2F;local&#x2F;java# java -version</span><br><span class="line">java version &quot;1.8.0_152&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_152-b16)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</span><br></pre></td></tr></table></figure><h4 id="为其他用户更新用户环境变量"><a href="#为其他用户更新用户环境变量" class="headerlink" title="为其他用户更新用户环境变量"></a>为其他用户更新用户环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su lusifer</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><h3 id="六、yum"><a href="#六、yum" class="headerlink" title="六、yum"></a>六、yum</h3><p>更新yum</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h3 id="七、文件目录代表的意思"><a href="#七、文件目录代表的意思" class="headerlink" title="七、文件目录代表的意思"></a>七、文件目录代表的意思</h3><h4 id="etc-放置配置文件"><a href="#etc-放置配置文件" class="headerlink" title="etc 放置配置文件"></a><code>etc</code> 放置配置文件</h4><h4 id="var-放置数据文件一般日志"><a href="#var-放置数据文件一般日志" class="headerlink" title="var 放置数据文件一般日志"></a><code>var</code> 放置数据文件一般日志</h4><h4 id="usr-一般放置用户的一些数据文件等"><a href="#usr-一般放置用户的一些数据文件等" class="headerlink" title="usr 一般放置用户的一些数据文件等"></a><code>usr</code> 一般放置用户的一些数据文件等</h4>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Docker] 安装Docker</title>
      <link href="/2018/06/23/docker/install-docker/"/>
      <url>/2018/06/23/docker/install-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="1-CentOS-安装Docker"><a href="#1-CentOS-安装Docker" class="headerlink" title="1. CentOS 安装Docker"></a>1. CentOS 安装Docker</h2><blockquote><p>建议使用centos7</p></blockquote><h3 id="1-1-安装Docker"><a href="#1-1-安装Docker" class="headerlink" title="1.1. 安装Docker"></a>1.1. 安装Docker</h3><h4 id="1-1-1-卸载旧版本"><a href="#1-1-1-卸载旧版本" class="headerlink" title="1.1.1. 卸载旧版本"></a>1.1.1. 卸载旧版本</h4><p>旧版本的Docker命名为<code>docker</code>或<code>docker-engine</code>，如果有安装旧版本，先卸载旧版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove -y docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h4 id="1-1-2-使用仓库安装"><a href="#1-1-2-使用仓库安装" class="headerlink" title="1.1.2. 使用仓库安装"></a>1.1.2. 使用仓库安装</h4><p>1、安装yum-utils、device-mapper-persistent-data、lvm2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><p>2、添加软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="1-1-3-安装Docker"><a href="#1-1-3-安装Docker" class="headerlink" title="1.1.3. 安装Docker"></a>1.1.3. 安装Docker</h4><p>安装最新版本的Docker CE。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y docker-ce</span><br></pre></td></tr></table></figure><h4 id="1-1-4-启动Docker"><a href="#1-1-4-启动Docker" class="headerlink" title="1.1.4. 启动Docker"></a>1.1.4. 启动Docker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line">$ sudo systemctl start docker</span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><h3 id="1-2-安装指定版本Docker"><a href="#1-2-安装指定版本Docker" class="headerlink" title="1.2. 安装指定版本Docker"></a>1.2. 安装指定版本Docker</h3><p>1、列出可安装版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64            18.03.0.ce-1.el7.centos             docker-ce-stable</span><br></pre></td></tr></table></figure><p>2、安装指定版本</p><p>例如：docker-ce-18.03.0.ce</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce-&lt;VERSION STRING&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-升级Docker"><a href="#1-3-升级Docker" class="headerlink" title="1.3. 升级Docker"></a>1.3. 升级Docker</h3><p>依据1.2的方法选择指定版本安装。</p><h3 id="1-4-卸载Docker"><a href="#1-4-卸载Docker" class="headerlink" title="1.4. 卸载Docker"></a>1.4. 卸载Docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载Docker</span></span><br><span class="line">$ sudo yum remove docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理镜像、容器、存储卷等</span></span><br><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><h2 id="2-Ubuntu-安装Docker"><a href="#2-Ubuntu-安装Docker" class="headerlink" title="2. Ubuntu 安装Docker"></a>2. Ubuntu 安装Docker</h2><h3 id="2-1-安装Docker"><a href="#2-1-安装Docker" class="headerlink" title="2.1. 安装Docker"></a>2.1. 安装Docker</h3><h4 id="2-1-1-卸载旧版本"><a href="#2-1-1-卸载旧版本" class="headerlink" title="2.1.1. 卸载旧版本"></a>2.1.1. 卸载旧版本</h4><p>旧版本的Docker命名为<code>docker</code>或<code>docker-engine</code>，如果有安装旧版本，先卸载旧版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><h4 id="2-1-2-使用仓库安装"><a href="#2-1-2-使用仓库安装" class="headerlink" title="2.1.2. 使用仓库安装"></a>2.1.2. 使用仓库安装</h4><p>1、升级apt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>2、允许apt使用https</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><p>3、添加Docker 官方的GPG密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>4、添加Docker软件源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure><h4 id="2-1-3-安装Docker"><a href="#2-1-3-安装Docker" class="headerlink" title="2.1.3. 安装Docker"></a>2.1.3. 安装Docker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># update</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># install docker</span></span><br><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><h4 id="2-1-4-启动Docker"><a href="#2-1-4-启动Docker" class="headerlink" title="2.1.4. 启动Docker"></a>2.1.4. 启动Docker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置为开机启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="2-2-安装指定版本Docker"><a href="#2-2-安装指定版本Docker" class="headerlink" title="2.2. 安装指定版本Docker"></a>2.2. 安装指定版本Docker</h3><p>1、列出仓库的可安装版本，<code>apt-cache madison docker-ce</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt-cache madison docker-ce</span></span><br><span class="line"> docker-ce | 18.06.0~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br><span class="line"> docker-ce | 18.03.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br></pre></td></tr></table></figure><p>2、指定版本安装</p><p>例如：docker-ce=18.03.0<del>ce-0</del>ubuntu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce=&lt;VERSION&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-升级Docker"><a href="#2-3-升级Docker" class="headerlink" title="2.3.  升级Docker"></a>2.3.  升级Docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新源</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 依据上述方法，指定版本安装</span></span><br></pre></td></tr></table></figure><h3 id="2-4-卸载Docker"><a href="#2-4-卸载Docker" class="headerlink" title="2.4. 卸载Docker"></a>2.4. 卸载Docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载 docker ce</span></span><br><span class="line">sudo apt-get purge docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理镜像、容器、存储卷等</span></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><p>文章参考：</p><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Redis] Redis集群模式部署</title>
      <link href="/2018/04/17/redis/redis-cluster/"/>
      <url>/2018/04/17/redis/redis-cluster/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Redis部署"><a href="#1-Redis部署" class="headerlink" title="1. Redis部署"></a>1. Redis部署</h2><blockquote><p>以下以Linux系统为例</p></blockquote><a id="more"></a><h3 id="1-1-下载和编译"><a href="#1-1-下载和编译" class="headerlink" title="1.1 下载和编译"></a>1.1 下载和编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-4.0.7.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-4.0.7.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-4.0.7</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>编译完成后会在<code>src</code>目录下生成Redis服务端程序<code>redis-server</code>和客户端程序<code>redis-cli</code>。</p><h3 id="1-2-启动服务"><a href="#1-2-启动服务" class="headerlink" title="1.2 启动服务"></a>1.2 启动服务</h3><p><strong>1、前台运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server</span><br></pre></td></tr></table></figure><p>该方式启动默认为<code>前台方式</code>运行，使用默认配置。</p><p><strong>2、后台运行</strong></p><p>可以修改<code>redis.conf</code>文件的<code>daemonize</code>参数为<code>yes</code>，指定配置文件启动，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> By default Redis does not run as a daemon. Use <span class="string">'yes'</span> <span class="keyword">if</span> you need it.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that Redis will write a pid file <span class="keyword">in</span> /var/run/redis.pid when daemonized.</span></span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>指定配置文件启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/redis-server redis.conf</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定配置文件后台启动</span></span><br><span class="line">[root@kube-node-1 redis-4.0.7]# src/redis-server redis.conf</span><br><span class="line">95778:C 30 Jan 00:44:37.633 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">95778:C 30 Jan 00:44:37.634 # Redis version=4.0.7, bits=64, commit=00000000, modified=0, pid=95778, just started</span><br><span class="line">95778:C 30 Jan 00:44:37.634 # Configuration loaded</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看Redis进程</span></span><br><span class="line">[root@kube-node-1 redis-4.0.7]# ps aux|grep redis</span><br><span class="line">root      95779  0.0  0.0 145268   468 ?        Ssl  00:44   0:00 src/redis-server 127.0.0.1:6379</span><br></pre></td></tr></table></figure><p>更多启动参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 src]# ./redis-server --help</span><br><span class="line">Usage: ./redis-server [/path/to/redis.conf] [options]</span><br><span class="line">       ./redis-server - (read config from stdin)</span><br><span class="line">       ./redis-server -v or --version</span><br><span class="line">       ./redis-server -h or --help</span><br><span class="line">       ./redis-server --test-memory &lt;megabytes&gt;</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">       ./redis-server (run the server with default conf)</span><br><span class="line">       ./redis-server /etc/redis/6379.conf</span><br><span class="line">       ./redis-server --port 7777</span><br><span class="line">       ./redis-server --port 7777 --slaveof 127.0.0.1 8888</span><br><span class="line">       ./redis-server /etc/myredis.conf --loglevel verbose</span><br><span class="line"></span><br><span class="line">Sentinel mode:</span><br><span class="line">       ./redis-server /etc/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure><h3 id="1-3-客户端测试"><a href="#1-3-客户端测试" class="headerlink" title="1.3 客户端测试"></a>1.3 客户端测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> src/redis-cli</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> <span class="built_in">set</span> foo bar</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> get foo</span></span><br><span class="line">"bar"</span><br></pre></td></tr></table></figure><h2 id="2-Redis集群部署"><a href="#2-Redis集群部署" class="headerlink" title="2. Redis集群部署"></a>2. Redis集群部署</h2><p>Redis的集群部署需要在每台集群部署的机器上安装Redis（可参考上述的[Redis安装] ），然后修改配置以集群的方式启动。</p><h3 id="2-1-手动部署集群"><a href="#2-1-手动部署集群" class="headerlink" title="2.1 手动部署集群"></a>2.1 手动部署集群</h3><h4 id="2-1-1-设置配置文件及启动实例"><a href="#2-1-1-设置配置文件及启动实例" class="headerlink" title="2.1.1 设置配置文件及启动实例"></a>2.1.1 设置配置文件及启动实例</h4><p>修改配置文件redis.conf，集群模式的最小化配置文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">可选操作，该项设置后台方式运行，</span></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">port 7000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><blockquote><p>更多集群配置参数可参考默认配置文件redis.conf中<code>Cluster</code>模块的说明</p></blockquote><p>最小集群模式需要三个master实例，一般建议起六个实例，即三主三从。因此我们创建6个以端口号命名的目录存放实例的配置文件和其他信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir cluster-test</span><br><span class="line">cd cluster-test</span><br><span class="line">mkdir 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure><p>在对应端口号的目录中创建<code>redis.conf</code>的文件，配置文件的内容可参考上述的集群模式配置。每个配置文件中的端口号<code>port</code>参数改为对应目录的端口号。</p><p>复制<code>redis-server</code>的二进制文件到<code>cluster-test</code>目录中，通过指定配置文件的方式启动<code>redis</code>服务，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 7000</span><br><span class="line">../redis-server ./redis.conf</span><br></pre></td></tr></table></figure><p>如果是以前台方式运行，则会在控制台输出以下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I'm 97a3a64667477371c4479320d683e4c8db5858b1</span><br></pre></td></tr></table></figure><p>每个实例都会生成一个<code>Node ID</code>，类似<code>97a3a64667477371c4479320d683e4c8db5858b1</code>，用来作为Redis实例在集群中的唯一标识，而不是通过IP和Port，IP和Port可能会改变，该<code>Node ID</code>不会改变。</p><p>目录结构可参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cluster-test/</span><br><span class="line">├── 7000</span><br><span class="line">│   ├── appendonly.aof</span><br><span class="line">│   ├── dump.rdb</span><br><span class="line">│   ├── nodes.conf</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7001</span><br><span class="line">│   ├── appendonly.aof</span><br><span class="line">│   ├── dump.rdb</span><br><span class="line">│   ├── nodes.conf</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7002</span><br><span class="line">│   ├── appendonly.aof</span><br><span class="line">│   ├── dump.rdb</span><br><span class="line">│   ├── nodes.conf</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7003</span><br><span class="line">│   ├── appendonly.aof</span><br><span class="line">│   ├── dump.rdb</span><br><span class="line">│   ├── nodes.conf</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7004</span><br><span class="line">│   ├── appendonly.aof</span><br><span class="line">│   ├── dump.rdb</span><br><span class="line">│   ├── nodes.conf</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── 7005</span><br><span class="line">│   ├── appendonly.aof</span><br><span class="line">│   ├── dump.rdb</span><br><span class="line">│   ├── nodes.conf</span><br><span class="line">│   └── redis.conf</span><br><span class="line">├── redis-cli</span><br><span class="line">└── redis-server</span><br></pre></td></tr></table></figure><h4 id="2-1-2-redis-trib创建集群"><a href="#2-1-2-redis-trib创建集群" class="headerlink" title="2.1.2 redis-trib创建集群"></a>2.1.2 redis-trib创建集群</h4><p>Redis的实例全部运行之后，还需要<code>redis-trib.rb</code>工具来完成集群的创建，<code>redis-trib.rb</code>二进制文件在Redis包主目录下的<code>src</code>目录中，运行该工具依赖<code>Ruby</code>环境和<code>gem</code>，因此需要提前安装。</p><p><strong>1、安装Ruby</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ruby rubygems</span><br></pre></td></tr></table></figure><p>查看Ruby版本信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 src]# ruby --version</span><br><span class="line">ruby 2.0.0p648 (2015-12-16) [x86_64-linux]</span><br></pre></td></tr></table></figure><p>由于<code>centos</code>系统默认支持Ruby版本为<code>2.0.0</code>，因此执行<code>gem install redis</code>命令时会报以下错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 src]# gem install redis</span><br><span class="line">Fetching: redis-4.0.1.gem (100%)</span><br><span class="line">ERROR:  Error installing redis:</span><br><span class="line">redis requires Ruby version &gt;= 2.2.2.</span><br></pre></td></tr></table></figure><p>解决方法是先安装<code>rvm</code>，再升级<code>ruby</code>版本。</p><p><strong>2、安装rvm</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure><p>如果遇到以下报错，则执行报错中的<code>gpg2 --recv-keys</code>的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 ~]# curl -L get.rvm.io | bash -s stable</span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   194  100   194    0     0    335      0 --:--:-- --:--:-- --:--:--   335</span><br><span class="line">100 24090  100 24090    0     0  17421      0  0:00:01  0:00:01 --:--:-- 44446</span><br><span class="line">Downloading https://github.com/rvm/rvm/archive/1.29.3.tar.gz</span><br><span class="line">Downloading https://github.com/rvm/rvm/releases/download/1.29.3/1.29.3.tar.gz.asc</span><br><span class="line">gpg: 于 2017年09月11日 星期一 04时59分21秒 CST 创建的签名，使用 RSA，钥匙号 BF04FF17</span><br><span class="line">gpg: 无法检查签名：没有公钥</span><br><span class="line">Warning, RVM 1.26.0 introduces signed releases and automated check of signatures when GPG software found. Assuming you trust Michal Papis import the mpapis public key (downloading the signatures).</span><br><span class="line"></span><br><span class="line">GPG signature verification failed for '/usr/local/rvm/archives/rvm-1.29.3.tgz' - 'https://github.com/rvm/rvm/releases/download/1.29.3/1.29.3.tar.gz.asc'! Try to install GPG v2 and then fetch the public key:</span><br><span class="line"></span><br><span class="line">    gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3</span><br><span class="line"></span><br><span class="line">or if it fails:</span><br><span class="line"></span><br><span class="line">    command curl -sSL https://rvm.io/mpapis.asc | gpg2 --import -</span><br><span class="line"></span><br><span class="line">the key can be compared with:</span><br><span class="line"></span><br><span class="line">    https://rvm.io/mpapis.asc</span><br><span class="line">    https://keybase.io/mpapis</span><br><span class="line"></span><br><span class="line">NOTE: GPG version 2.1.17 have a bug which cause failures during fetching keys from remote server. Please downgrade or upgrade to newer version (if available) or use the second method described above.</span><br></pre></td></tr></table></figure><p>执行报错中的<code>gpg2 --recv-keys</code>的命令。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 ~]# gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3</span><br><span class="line">gpg: 钥匙环‘/root/.gnupg/secring.gpg’已建立</span><br><span class="line">gpg: 下载密钥‘D39DC0E3’，从 hkp 服务器 keys.gnupg.net</span><br><span class="line">gpg: /root/.gnupg/trustdb.gpg：建立了信任度数据库</span><br><span class="line">gpg: 密钥 D39DC0E3：公钥“Michal Papis (RVM signing) &lt;mpapis@gmail.com&gt;”已导入</span><br><span class="line">gpg: 没有找到任何绝对信任的密钥</span><br><span class="line">gpg: 合计被处理的数量：1</span><br><span class="line">gpg:           已导入：1  (RSA: 1)</span><br></pre></td></tr></table></figure><p>再次执行命令<code>curl -L get.rvm.io | bash -s stable</code>。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 ~]# curl -L get.rvm.io | bash -s stable</span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   194  100   194    0     0    310      0 --:--:-- --:--:-- --:--:--   309</span><br><span class="line">100 24090  100 24090    0     0  18230      0  0:00:01  0:00:01 --:--:--  103k</span><br><span class="line">Downloading https://github.com/rvm/rvm/archive/1.29.3.tar.gz</span><br><span class="line">Downloading https://github.com/rvm/rvm/releases/download/1.29.3/1.29.3.tar.gz.asc</span><br><span class="line">gpg: 于 2017年09月11日 星期一 04时59分21秒 CST 创建的签名，使用 RSA，钥匙号 BF04FF17</span><br><span class="line">gpg: 完好的签名，来自于“Michal Papis (RVM signing) &lt;mpapis@gmail.com&gt;”</span><br><span class="line">gpg:               亦即“Michal Papis &lt;michal.papis@toptal.com&gt;”</span><br><span class="line">gpg:               亦即“[jpeg image of size 5015]”</span><br><span class="line">gpg: 警告：这把密钥未经受信任的签名认证！</span><br><span class="line">gpg:       没有证据表明这个签名属于它所声称的持有者。</span><br><span class="line">主钥指纹： 409B 6B17 96C2 7546 2A17  0311 3804 BB82 D39D C0E3</span><br><span class="line">子钥指纹： 62C9 E5F4 DA30 0D94 AC36  166B E206 C29F BF04 FF17</span><br><span class="line">GPG verified '/usr/local/rvm/archives/rvm-1.29.3.tgz'</span><br><span class="line">Creating group 'rvm'</span><br><span class="line"></span><br><span class="line">Installing RVM to /usr/local/rvm/</span><br><span class="line">Installation of RVM in /usr/local/rvm/ is almost complete:</span><br><span class="line"></span><br><span class="line">  * First you need to add all users that will be using rvm to 'rvm' group,</span><br><span class="line">    and logout - login again, anyone using rvm will be operating with `umask u=rwx,g=rwx,o=rx`.</span><br><span class="line"></span><br><span class="line">  * To start using RVM you need to run `source /etc/profile.d/rvm.sh`</span><br><span class="line">    in all your open shell windows, in rare cases you need to reopen all shell windows.</span><br></pre></td></tr></table></figure><p>以上表示执行成功，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /usr/local/rvm/scripts/rvm</span><br></pre></td></tr></table></figure><p>查看rvm库中已知的ruby版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm list known</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 ~]# rvm list known</span><br><span class="line"><span class="meta">#</span><span class="bash"> MRI Rubies</span></span><br><span class="line">[ruby-]1.8.6[-p420]</span><br><span class="line">[ruby-]1.8.7[-head] # security released on head</span><br><span class="line">[ruby-]1.9.1[-p431]</span><br><span class="line">[ruby-]1.9.2[-p330]</span><br><span class="line">[ruby-]1.9.3[-p551]</span><br><span class="line">[ruby-]2.0.0[-p648]</span><br><span class="line">[ruby-]2.1[.10]</span><br><span class="line">[ruby-]2.2[.7]</span><br><span class="line">[ruby-]2.3[.4]</span><br><span class="line">[ruby-]2.4[.1]</span><br><span class="line">ruby-head</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>3、升级Ruby</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装ruby</span></span><br><span class="line">rvm install  2.4.0</span><br><span class="line"><span class="meta">#</span><span class="bash">使用新版本</span></span><br><span class="line">rvm use  2.4.0</span><br><span class="line"><span class="meta">#</span><span class="bash">移除旧版本</span></span><br><span class="line">rvm remove 2.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看当前版本</span></span><br><span class="line">ruby --version</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 ~]# rvm install  2.4.0</span><br><span class="line">Searching for binary rubies, this might take some time.</span><br><span class="line">Found remote file https://rvm_io.global.ssl.fastly.net/binaries/centos/7/x86_64/ruby-2.4.0.tar.bz2</span><br><span class="line">Checking requirements for centos.</span><br><span class="line">Installing requirements for centos.</span><br><span class="line">Installing required packages: autoconf, automake, bison, bzip2, gcc-c++, libffi-devel, libtool, readline-devel, sqlite-devel, zlib-devel, libyaml-devel, openssl-devel................................</span><br><span class="line">Requirements installation successful.</span><br><span class="line">ruby-2.4.0 - #configure</span><br><span class="line">ruby-2.4.0 - #download</span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 14.0M  100 14.0M    0     0   852k      0  0:00:16  0:00:16 --:--:--  980k</span><br><span class="line">No checksum for downloaded archive, recording checksum in user configuration.</span><br><span class="line">ruby-2.4.0 - #validate archive</span><br><span class="line">ruby-2.4.0 - #extract</span><br><span class="line">ruby-2.4.0 - #validate binary</span><br><span class="line">ruby-2.4.0 - #setup</span><br><span class="line">ruby-2.4.0 - #gemset created /usr/local/rvm/gems/ruby-2.4.0@global</span><br><span class="line">ruby-2.4.0 - #importing gemset /usr/local/rvm/gemsets/global.gems..............................</span><br><span class="line">ruby-2.4.0 - #generating global wrappers........</span><br><span class="line">ruby-2.4.0 - #gemset created /usr/local/rvm/gems/ruby-2.4.0</span><br><span class="line">ruby-2.4.0 - #importing gemsetfile /usr/local/rvm/gemsets/default.gems evaluated to empty gem list</span><br><span class="line">ruby-2.4.0 - #generating default wrappers........</span><br><span class="line"></span><br><span class="line">[root@kube-node-1 ~]# rvm use  2.4.0</span><br><span class="line">Using /usr/local/rvm/gems/ruby-2.4.0</span><br><span class="line"></span><br><span class="line">[root@kube-node-1 ~]# rvm remove 2.0.0</span><br><span class="line">ruby-2.0.0-p648 - #already gone</span><br><span class="line">Using /usr/local/rvm/gems/ruby-2.4.0</span><br><span class="line"></span><br><span class="line">[root@kube-node-1 ~]# ruby --version</span><br><span class="line">ruby 2.4.0p0 (2016-12-24 revision 57164) [x86_64-linux]</span><br></pre></td></tr></table></figure><p><strong>4、安装gem</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install redis</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 ~]# gem install redis</span><br><span class="line"></span><br><span class="line">Fetching: redis-4.0.1.gem (100%)</span><br><span class="line">Successfully installed redis-4.0.1</span><br><span class="line">Parsing documentation for redis-4.0.1</span><br><span class="line">Installing ri documentation for redis-4.0.1</span><br><span class="line">Done installing documentation for redis after 2 seconds</span><br><span class="line">1 gem installed</span><br></pre></td></tr></table></figure><p><strong>5、执行redis-trib.rb命令</strong></p><p>以上表示安装成功，可以执行<code>redis-trib.rb</code>命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd src </span><br><span class="line"><span class="meta">#</span><span class="bash">执行redis-trib.rb命令</span></span><br><span class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span></span><br></pre></td></tr></table></figure><p>参数<code>create</code>表示创建一个新的集群，<code>--replicas 1</code>表示为每个master创建一个slave。</p><p>如果创建成功会显示以下信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[OK] All 16384 slots covered</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 src]# ./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Creating cluster</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Using 3 masters:</span><br><span class="line">127.0.0.1:7000</span><br><span class="line">127.0.0.1:7001</span><br><span class="line">127.0.0.1:7002</span><br><span class="line">Adding replica 127.0.0.1:7004 to 127.0.0.1:7000</span><br><span class="line">Adding replica 127.0.0.1:7005 to 127.0.0.1:7001</span><br><span class="line">Adding replica 127.0.0.1:7003 to 127.0.0.1:7002</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Trying to optimize slaves allocation <span class="keyword">for</span> anti-affinity</span></span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: d5a834d075fd93eefab877c6ebb86efff680650f 127.0.0.1:7000</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: 13d0c397604a0b2644244c37b666fce83f29faa8 127.0.0.1:7001</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: be2718476eba4e56f696e56b75e67df720b7fc24 127.0.0.1:7002</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">S: 3d02f59b34047486faecc023685379de7b38076c 127.0.0.1:7003</span><br><span class="line">   replicates 13d0c397604a0b2644244c37b666fce83f29faa8</span><br><span class="line">S: dedf672f0a75faf37407ac4edd5da23bc4651e25 127.0.0.1:7004</span><br><span class="line">   replicates be2718476eba4e56f696e56b75e67df720b7fc24</span><br><span class="line">S: 99c07119a449a703583019f7699e15afa0e41952 127.0.0.1:7005</span><br><span class="line">   replicates d5a834d075fd93eefab877c6ebb86efff680650f</span><br><span class="line">Can I set the above configuration? (type 'yes' to accept): yes</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join....</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span></span><br><span class="line">M: d5a834d075fd93eefab877c6ebb86efff680650f 127.0.0.1:7000</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: be2718476eba4e56f696e56b75e67df720b7fc24 127.0.0.1:7002</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 13d0c397604a0b2644244c37b666fce83f29faa8 127.0.0.1:7001</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 3d02f59b34047486faecc023685379de7b38076c 127.0.0.1:7003</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 13d0c397604a0b2644244c37b666fce83f29faa8</span><br><span class="line">S: 99c07119a449a703583019f7699e15afa0e41952 127.0.0.1:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates d5a834d075fd93eefab877c6ebb86efff680650f</span><br><span class="line">S: dedf672f0a75faf37407ac4edd5da23bc4651e25 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates be2718476eba4e56f696e56b75e67df720b7fc24</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><h4 id="2-1-3-部署结果验证"><a href="#2-1-3-部署结果验证" class="headerlink" title="2.1.3 部署结果验证"></a>2.1.3 部署结果验证</h4><p><strong>1、客户端访问</strong></p><p>使用客户端<code>redis-cli</code>二进制访问某个实例，执行<code>set</code>和<code>get</code>的测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -c -p 7000</span></span><br><span class="line">redis 127.0.0.1:7000&gt; set foo bar</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [12182] located at 127.0.0.1:7002</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7002&gt; set hello world</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [866] located at 127.0.0.1:7000</span></span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7000&gt; get foo</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [12182] located at 127.0.0.1:7002</span></span><br><span class="line">"bar"</span><br><span class="line">redis 127.0.0.1:7000&gt; get hello</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [866] located at 127.0.0.1:7000</span></span><br><span class="line">"world"</span><br></pre></td></tr></table></figure><p><strong>2、查看集群状态</strong></p><p>使用<code>cluster info</code>命令查看集群状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7000&gt; cluster info</span><br><span class="line">cluster_state:ok                       #集群状态</span><br><span class="line">cluster_slots_assigned:16384           #被分配的槽位数</span><br><span class="line">cluster_slots_ok:16384                 #正确分配的槽位</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6                  #当前节点</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:48273</span><br><span class="line">cluster_stats_messages_pong_sent:49884</span><br><span class="line">cluster_stats_messages_sent:98157</span><br><span class="line">cluster_stats_messages_ping_received:49879</span><br><span class="line">cluster_stats_messages_pong_received:48273</span><br><span class="line">cluster_stats_messages_meet_received:5</span><br><span class="line">cluster_stats_messages_received:98157</span><br></pre></td></tr></table></figure><p><strong>3、查看节点状态</strong></p><p>使用<code>cluster nodes</code>命令查看节点状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7000&gt; cluster nodes</span><br><span class="line">be2718476eba4e56f696e56b75e67df720b7fc24 127.0.0.1:7002@17002 master - 0 1517303607000 3 connected 10923-16383</span><br><span class="line">13d0c397604a0b2644244c37b666fce83f29faa8 127.0.0.1:7001@17001 master - 0 1517303606000 2 connected 5461-10922</span><br><span class="line">3d02f59b34047486faecc023685379de7b38076c 127.0.0.1:7003@17003 slave 13d0c397604a0b2644244c37b666fce83f29faa8 0 1517303606030 4 connected</span><br><span class="line">d5a834d075fd93eefab877c6ebb86efff680650f 127.0.0.1:7000@17000 myself,master - 0 1517303604000 1 connected 0-5460</span><br><span class="line">99c07119a449a703583019f7699e15afa0e41952 127.0.0.1:7005@17005 slave d5a834d075fd93eefab877c6ebb86efff680650f 0 1517303607060 6 connected</span><br><span class="line">dedf672f0a75faf37407ac4edd5da23bc4651e25 127.0.0.1:7004@17004 slave be2718476eba4e56f696e56b75e67df720b7fc24 0 1517303608082 5 connected</span><br></pre></td></tr></table></figure><p> 参考文章：</p><p><a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a></p><p><a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">https://redis.io/topics/cluster-tutorial</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Redis] Redis哨兵模式部署</title>
      <link href="/2018/04/17/redis/redis-sentinel/"/>
      <url>/2018/04/17/redis/redis-sentinel/</url>
      
        <content type="html"><![CDATA[<h2 id="1-部署Redis集群"><a href="#1-部署Redis集群" class="headerlink" title="1. 部署Redis集群"></a>1. 部署Redis集群</h2><p>redis的安装及配置参考[redis部署]</p><a id="more"></a><blockquote><p>本文以创建一主二从的集群为例。</p></blockquote><h3 id="1-1-部署与配置"><a href="#1-1-部署与配置" class="headerlink" title="1.1 部署与配置"></a>1.1 部署与配置</h3><p>先创建<code>sentinel</code>目录，在该目录下创建<code>8000</code>，<code>8001</code>，<code>8002</code>三个以端口号命名的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir sentinel</span><br><span class="line">cd sentinel</span><br><span class="line">mkdir 8000 8001 8002</span><br></pre></td></tr></table></figure><p>在对应端口号目录中创建<code>redis.conf</code>的文件，配置文件中的端口号<code>port</code>参数改为对应目录的端口号。配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 守护进程模式</span></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> pid file</span></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 监听端口</span></span><br><span class="line">port 8000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> TCP接收队列长度，受/proc/sys/net/core/somaxconn和tcp_max_syn_backlog这两个内核参数的影响</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个客户端空闲多少秒后关闭连接(0代表禁用，永不关闭)</span></span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK</span></span><br><span class="line">tcp-keepalive 60</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定服务器调试等级</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能值：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> debug （大量信息，对开发/测试有用）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> verbose （很多精简的有用信息，但是不像debug等级那么多）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> notice （适量的信息，基本上是你生产环境中需要的）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> warning （只有很重要/严重的信息会记录下来）</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指明日志文件名</span></span><br><span class="line">logfile "./redis8000.log"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置数据库个数</span></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 会在指定秒数和数据变化次数之后把数据库写到磁盘上</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 900秒（15分钟）之后，且至少1次变更</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 300秒（5分钟）之后，且至少10次变更</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 60秒之后，且至少10000次变更</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认如果开启RDB快照(至少一条save指令)并且最新的后台保存失败，Redis将会停止接受写操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这将使用户知道数据没有正确的持久化到硬盘，否则可能没人注意到并且造成一些灾难</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当导出到 .rdb 数据库时是否用LZF压缩字符串对象</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 版本5的RDB有一个CRC64算法的校验和放在了文件的最后。这将使文件格式更加可靠。</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 持久化数据库的文件名</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作目录</span></span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当master服务设置了密码保护时，slave服务连接master的密码</span></span><br><span class="line">masterauth 0234kz9*l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当一个slave失去和master的连接，或者同步正在进行中，slave的行为可以有两种：</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1) 如果 slave-serve-stale-data 设置为 <span class="string">"yes"</span> (默认值)，slave会继续响应客户端请求，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能是正常数据，或者是过时了的数据，也可能是还没获得值的空数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) 如果 slave-serve-stale-data 设置为 <span class="string">"no"</span>，slave会回复<span class="string">"正在从master同步</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> （SYNC with master <span class="keyword">in</span> progress）<span class="string">"来处理各种请求，除了 INFO 和 SLAVEOF 命令。</span></span></span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 你可以配置salve实例是否接受写操作。可写的slave实例可能对存储临时数据比较有用(因为写入salve</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 的数据在同master同步之后将很容易被删除</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否在slave套接字发送SYNC之后禁用 TCP_NODELAY？</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你选择“yes”Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上有延迟，Linux内核的默认配置会达到40毫秒</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你选择了 <span class="string">"no"</span> 数据传输到salve的延迟将会减少但要使用更多的带宽</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> slave的优先级是一个整数展示在Redis的Info输出中。如果master不再正常工作了，哨兵将用它来</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个slave提升=升为master。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 优先级数字小的salve会优先考虑提升为master，所以例如有三个slave优先级分别为10，100，25，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 哨兵将挑选优先级最小数字为10的slave。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0作为一个特殊的优先级，标识这个slave不能作为master，所以一个优先级为0的slave永远不会被</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 哨兵挑选提升为master</span></span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 密码验证</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 警告：因为Redis太快了，所以外面的人可以尝试每秒150k的密码来试图破解密码。这意味着你需要</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个高强度的密码，否则破解太容易了</span></span><br><span class="line">requirepass 0234kz9*l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis实例最大占用内存，不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> maxmemmory-policy）删除key</span></span><br><span class="line">maxmemory 3gb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最大内存策略：如果达到内存限制了，Redis如何选择删除key。你可以在下面五个行为里选：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> volatile-lru -&gt; 根据LRU算法删除带有过期时间的key。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> allkeys-lru -&gt; 根据LRU算法删除任何key。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> volatile-random -&gt; 根据过期设置来随机删除key, 具备过期时间的key。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> allkeys-&gt;random -&gt; 无差别随机删, 任何一个key。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL）, 这是对于有过期时间的key</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> noeviction -&gt; 谁也不删，直接在写操作时返回错误。</span></span><br><span class="line">maxmemory-policy volatile-lru</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下，Redis是异步的把数据导出到磁盘上。这种模式在很多应用里已经足够好，但Redis进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出问题或断电时可能造成一段时间的写操作丢失(这取决于配置的save指令)。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> AOF是一种提供了更可靠的替代持久化模式，例如使用默认的数据写入文件策略（参见后面的配置）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在遇到像服务器断电或单写情况下Redis自身进程出问题但操作系统仍正常运行等突发事件时，Redis</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 能只丢失1秒的写操作。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> AOF和RDB持久化能同时启动并且不会有问题。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果AOF开启，那么在启动时Redis将加载AOF文件，它更能保证数据的可靠性。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> aof文件名</span></span><br><span class="line">appendfilename "appendonly.aof"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> fsync() 系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis支持三种不同的模式：</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> always：每次写操作都立刻写入到aof文件。慢，但是最安全。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> everysec：每秒写一次。折中方案。</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果AOF的同步策略设置成 <span class="string">"always"</span> 或者 <span class="string">"everysec"</span>，并且后台的存储进程（后台存储或写入AOF</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志）会产生很多磁盘I/O开销。某些Linux的配置下会使Redis因为 fsync()系统调用而阻塞很久。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的write(2)调用。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止主进程进行fsync()。</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这就意味着如果有子进程在进行保存操作，那么Redis就处于<span class="string">"不可同步"</span>的状态。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你有延时问题把这个设置成<span class="string">"yes"</span>，否则就保持<span class="string">"no"</span>，这是保存持久数据的最安全的方式。</span></span><br><span class="line">no-appendfsync-on-rewrite yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动重写AOF文件</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> AOF文件可能在尾部是不完整的（这跟system关闭有问题，尤其是mount ext4文件系统时</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有加上data=ordered选项。只会发生在os死时，redis自己死不会不完整）。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 那redis重启时load进内存的时候就有问题了。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发生的时候，可以选择redis启动报错，并且通知用户和写日志，或者load尽量多正常的数据。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果aof-load-truncated是yes，会自动发布一个<span class="built_in">log</span>给客户端然后load（默认）。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意，如果在读取的过程中，发现这个aof是损坏的，服务器也是会退出的，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个选项仅仅用于当服务器尝试读取更多的数据但又找不到相应的数据时。</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Lua 脚本的最大执行时间，毫秒为单位</span></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis慢查询日志可以记录超过指定时间的查询</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个长度没有限制。只是要主要会消耗内存。你可以通过 SLOWLOG RESET 来回收内存。</span></span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis延时监控系统在运行时会采样一些操作，以便收集可能导致延时的数据根源。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 LATENCY命令 可以打印一些图样和获取一些报告，方便监控</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个系统仅仅记录那个执行时间大于或等于预定时间（毫秒）的操作,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个预定时间是通过latency-monitor-threshold配置来指定的，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当设置为0时，这个监控系统处于停止状态</span></span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis能通知 Pub/Sub 客户端关于键空间发生的事件，默认关闭</span></span><br><span class="line">notify-keyspace-events ""</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当<span class="built_in">hash</span>只有少量的entry时，并且最大的entry所占空间没有超过指定的限制时，会用一种节省内存的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据结构来编码。可以通过下面的指令来设定限制</span></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 与<span class="built_in">hash</span>似，数据元素较少的list，可以用另一种方式来编码从而节省大量空间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这种特殊的方式只有在符合下面限制时才可以用</span></span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span>有一种特殊编码的情况：当<span class="built_in">set</span>数据全是十进制64位有符号整型数字构成的字符串时。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面这个配置项就是用来设置<span class="built_in">set</span>使用这种编码来节省内存的最大长度。</span></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 与<span class="built_in">hash</span>和list相似，有序集合也可以用一种特别的编码方式来节省大量空间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这种编码只适合长度和元素都小于下面限制的有序集合</span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> HyperLogLog稀疏结构表示字节的限制。该限制包括</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 16个字节的头。当HyperLogLog使用稀疏结构表示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这些限制，它会被转换成密度表示。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 值大于16000是完全没用的，因为在该点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 密集的表示是更多的内存效率。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议值是3000左右，以便具有的内存好处, 减少内存的消耗</span></span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启用哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表（顶级键值映射表）</span></span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端的输出缓冲区的限制，可用于强制断开那些因为某种原因从服务器读取数据的速度不够快的客户端</span></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下，“hz”的被设定为10。提高该值将在Redis空闲时使用更多的CPU时，但同时当有多个key</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同时到期会使Redis的反应更灵敏，以及超时可以更精确地处理</span></span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当一个子进程重写AOF文件时，如果启用下面的选项，则文件每生成32M数据会被同步</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><h3 id="1-2-配置主从关系"><a href="#1-2-配置主从关系" class="headerlink" title="1.2 配置主从关系"></a>1.2 配置主从关系</h3><p><strong>1、启动实例</strong></p><p>三个Redis实例配置相同，分别启动三个Redis实例。建议将<code>redis-server</code>、<code>redis-cli</code>、<code>redis-sentinel</code>的二进制复制到<code>/usr/local/bin</code>的目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 8000</span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p><strong>2、配置主从关系</strong></p><p>例如，将8000端口实例设为主，8001和8002端口的实例设为从。</p><p>则分别登录8001和8002的实例，执行<code>slaveof &lt;MASTER_IP&gt; &lt;MASTER_PORT&gt;</code>命令。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 8000]# redis-cli -c -p 8001 -a 0234kz9*l</span><br><span class="line">127.0.0.1:8001&gt; slaveof 127.0.0.1 8000</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><strong>3、检查集群状态</strong></p><p>登录master和slave实例，执行<code>info replication</code>查看集群状态。</p><p>Master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 8000]# redis-cli -c -p 8000 -a 0234kz9*l</span><br><span class="line">127.0.0.1:8000&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=8001,state=online,offset=2853,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=8002,state=online,offset=2853,lag=0</span><br><span class="line">master_replid:4f8331d5f180a4669241ab0dd97e43508abd6d8f</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:2853</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:2853</span><br></pre></td></tr></table></figure><p>Slave</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 8000]# redis-cli -c -p 8001 -a 0234kz9*l</span><br><span class="line">127.0.0.1:8001&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:8000</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:2909</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:4f8331d5f180a4669241ab0dd97e43508abd6d8f</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:2909</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:2909</span><br></pre></td></tr></table></figure><p>也可以往master写数据，从slave读取数据来验证。</p><h2 id="2-部署sentinel集群"><a href="#2-部署sentinel集群" class="headerlink" title="2. 部署sentinel集群"></a>2. 部署sentinel集群</h2><h3 id="2-1-部署与配置"><a href="#2-1-部署与配置" class="headerlink" title="2.1 部署与配置"></a>2.1 部署与配置</h3><p>在之前创建的<code>sentinel</code>目录中场景sentinel端口号命名的目录<code>28000</code>，<code>28001</code>，<code>28002</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd sentinel</span><br><span class="line">mkdir 28000 28001 28002</span><br></pre></td></tr></table></figure><p>在对应端口号目录中创建<code>redis.conf</code>的文件，配置文件中的端口号<code>port</code>参数改为对应目录的端口号。配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 28000</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 8000 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure><h3 id="2-2-启动sentinel实例"><a href="#2-2-启动sentinel实例" class="headerlink" title="2.2 启动sentinel实例"></a>2.2 启动sentinel实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&amp; 表示后台运行的方式</span></span><br><span class="line">redis-sentinel sentinel.conf &amp;</span><br></pre></td></tr></table></figure><h3 id="2-3-查看状态"><a href="#2-3-查看状态" class="headerlink" title="2.3 查看状态"></a>2.3 查看状态</h3><p>使用<code>sentinel masters</code>命令查看监控的master节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[root@kube-node-1 28000]# redis-cli -c -p 28000 -a 0234kz9*l</span><br><span class="line">127.0.0.1:28000&gt;</span><br><span class="line">127.0.0.1:28000&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:28000&gt;</span><br><span class="line">127.0.0.1:28000&gt; sentinel masters</span><br><span class="line">1)  1) "name"</span><br><span class="line">    2) "mymaster"</span><br><span class="line">    3) "ip"</span><br><span class="line">    4) "127.0.0.1"</span><br><span class="line">    5) "port"</span><br><span class="line">    6) "8000"</span><br><span class="line">    7) "runid"</span><br><span class="line">    8) ""</span><br><span class="line">    9) "flags"</span><br><span class="line">   10) "s_down,master,disconnected"</span><br><span class="line">   11) "link-pending-commands"</span><br><span class="line">   12) "0"</span><br><span class="line">   13) "link-refcount"</span><br><span class="line">   14) "1"</span><br><span class="line">   15) "last-ping-sent"</span><br><span class="line">   16) "187539"</span><br><span class="line">   17) "last-ok-ping-reply"</span><br><span class="line">   18) "187539"</span><br><span class="line">   19) "last-ping-reply"</span><br><span class="line">   20) "3943"</span><br><span class="line">   21) "s-down-time"</span><br><span class="line">   22) "127491"</span><br><span class="line">   23) "down-after-milliseconds"</span><br><span class="line">   24) "60000"</span><br><span class="line">   25) "info-refresh"</span><br><span class="line">   26) "1517346914642"</span><br><span class="line">   27) "role-reported"</span><br><span class="line">   28) "master"</span><br><span class="line">   29) "role-reported-time"</span><br><span class="line">   30) "187539"</span><br><span class="line">   31) "config-epoch"</span><br><span class="line">   32) "0"</span><br><span class="line">   33) "num-slaves"</span><br><span class="line">   34) "0"</span><br><span class="line">   35) "num-other-sentinels"</span><br><span class="line">   36) "0"</span><br><span class="line">   37) "quorum"</span><br><span class="line">   38) "2"</span><br><span class="line">   39) "failover-timeout"</span><br><span class="line">   40) "180000"</span><br><span class="line">   41) "parallel-syncs"</span><br><span class="line">   42) "1"</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">https://redis.io/topics/sentinel</a></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Nginx] Nginx的部署与配置</title>
      <link href="/2017/09/13/nginx/nginx-deploy&amp;config/"/>
      <url>/2017/09/13/nginx/nginx-deploy&amp;config/</url>
      
        <content type="html"><![CDATA[<h2 id="1-部署"><a href="#1-部署" class="headerlink" title="1. 部署"></a>1. 部署</h2><a id="more"></a><h3 id="1-1-使用安装包的方式"><a href="#1-1-使用安装包的方式" class="headerlink" title="1.1. 使用安装包的方式"></a>1.1. 使用安装包的方式</h3><p>rpm -ivh nginx-xxx.rpm</p><h3 id="1-2-使用源代码安装"><a href="#1-2-使用源代码安装" class="headerlink" title="1.2. 使用源代码安装"></a>1.2. 使用源代码安装</h3><h4 id="1-2-1-下载源码包"><a href="#1-2-1-下载源码包" class="headerlink" title="1.2.1. 下载源码包"></a>1.2.1. 下载源码包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.9.13.tar.gz</span><br></pre></td></tr></table></figure><h3 id="1-2-2-创建临时目录并解压源码包"><a href="#1-2-2-创建临时目录并解压源码包" class="headerlink" title="1.2.2. 创建临时目录并解压源码包"></a>1.2.2. 创建临时目录并解压源码包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir $HOME/build</span><br><span class="line">cd $HOME/build &amp;&amp; tar zxvf nginx-`version-number`.tar.gz</span><br></pre></td></tr></table></figure><h4 id="1-2-3-编译并安装"><a href="#1-2-3-编译并安装" class="headerlink" title="1.2.3. 编译并安装"></a>1.2.3. 编译并安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> cd $HOME/build/nginx-`version-number`</span><br><span class="line"> </span><br><span class="line">./configure \</span><br><span class="line">--prefix=/etc/nginx \</span><br><span class="line">--sbin-path=/usr/sbin/nginx \</span><br><span class="line">--conf-path=/etc/nginx/nginx.conf \</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash">`更多配置项见以下说明`</span></span><br><span class="line"> </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="1-2-4-配置项"><a href="#1-2-4-配置项" class="headerlink" title="1.2.4. 配置项"></a>1.2.4. 配置项</h4><h5 id="1-2-4-1-通用配置项"><a href="#1-2-4-1-通用配置项" class="headerlink" title="1.2.4.1. 通用配置项"></a>1.2.4.1. 通用配置项</h5><table><thead><tr><th>配置选项</th><th>说明</th></tr></thead><tbody><tr><td>–prefix=<code>path</code></td><td>nginx安装的根路径，所有其他的路径都要依赖与该选项</td></tr><tr><td>–sbin-path=<code>path</code></td><td>nginx二进制文件的路径，如果没有指定则会依赖于–prefix</td></tr><tr><td>–conf-path=<code>path</code></td><td>如果在命令行中没有指定配置文件，则通过该配置项去查找配置文件</td></tr><tr><td>–error-log-path=<code>path</code></td><td>指定错误文件的路径</td></tr><tr><td>–pid-path=<code>path</code></td><td>指定的文件将会写入nginx master进程的pid，通常在/var/run下</td></tr><tr><td>–lock-path=<code>path</code></td><td>共享存储器互斥锁文件的路径</td></tr><tr><td>–user=<code>user</code></td><td>worker进程运行的用户</td></tr><tr><td>–group=<code>group</code></td><td>worker进程运行的组</td></tr><tr><td>–with-file-aio</td><td>启动异步I/O</td></tr><tr><td>–with-debug</td><td>启用调试日志，生产环境不推荐配置</td></tr></tbody></table><h5 id="1-2-4-2-优化配置项"><a href="#1-2-4-2-优化配置项" class="headerlink" title="1.2.4.2. 优化配置项"></a>1.2.4.2. 优化配置项</h5><table><thead><tr><th>配置选项</th><th>说明</th></tr></thead><tbody><tr><td>–with-cc=<code>path</code></td><td>如果想设置一个不在默认PATH下的C编译器</td></tr><tr><td>–with-cpp=<code>path</code></td><td>设置C预处理器的相应路径</td></tr><tr><td>–with-cc-opt=<code>options</code></td><td>指定必要的include文件路径</td></tr><tr><td>–with-ld-opt=<code>options</code></td><td>包含连接器库的路径和运行路径</td></tr><tr><td>–with-cpu-opt=<code>cpu</code></td><td>通过该选项为特定的CPU构建nginx</td></tr></tbody></table><h5 id="1-2-4-3-http模块的配置项"><a href="#1-2-4-3-http模块的配置项" class="headerlink" title="1.2.4.3. http模块的配置项"></a>1.2.4.3. http模块的配置项</h5><table><thead><tr><th>配置选项</th><th>说明</th></tr></thead><tbody><tr><td>–without-http-cache</td><td>在使用upstream模块时，nginx能够配置本地缓存内容，该选项可以禁用缓存</td></tr><tr><td>–with-http_perl_module</td><td>nginx配置能够扩展使用perl代码。该项启用这个模块，但会降低性能</td></tr><tr><td>–with-perl_modules_path=<code>path</code></td><td>对于额外嵌入的perl模块，该选项指定该perl解析器的路径</td></tr><tr><td>–with-perl=<code>path</code></td><td>如果在默认的路径中找不到perl则指定perl（5.6版本以上）的路径</td></tr><tr><td>–http-log-path=<code>path</code></td><td>http访问日志的默认路径</td></tr><tr><td>–http-client-body-temp-path=<code>path</code></td><td>从客户端收到请求后，该项用于作为请求体临时存放的目录</td></tr><tr><td>–http-proxy-temp-path=<code>path</code></td><td>在使用代理后，通过该项设置存放临时文件路径</td></tr><tr><td>–http-fastcgi-temp-path=<code>path</code></td><td>设置FastCGI临时文件的目录</td></tr><tr><td>–http-uwsgi-temp-path=<code>path</code></td><td>设置uWSGI临时文件的目录</td></tr><tr><td>–http-scgi-temp-path=<code>path</code></td><td>设置SCGI临时文件的目录</td></tr></tbody></table><h5 id="1-2-4-4-其他模块额外配置项"><a href="#1-2-4-4-其他模块额外配置项" class="headerlink" title="1.2.4.4. 其他模块额外配置项"></a>1.2.4.4. 其他模块额外配置项</h5><p>默认没有安装这些模块，可以通过–with-<code>module-name</code>_module来启用相应的模块功能。</p><table><thead><tr><th>配置选项</th><th>说明</th></tr></thead><tbody><tr><td>–with-http_ssl_module</td><td>如果需要对流量进行加密，可以使用该选项，再URLs中开始部分将会是https(需要OpenSSL库)</td></tr><tr><td>–with-http_realip_module</td><td>如果nginx在七层负载均衡器或者其他设备之后，它们将Http头中的客户端IP地址传递，则需要启用该模块，再多个客户处于一个IP地址的情况下使用</td></tr><tr><td>–with-http_addition_module</td><td>该模块作为输出过滤器，使能够在请求经过一个location前或后时在该location本身添加内容</td></tr><tr><td>–with-http_xslt_module</td><td>该模块用于处理XML响应转换，基于一个或多个XSLT格式</td></tr><tr><td>–with-http_image_filter_module</td><td>该模块被作为图像过滤器使用，在将图像投递到客户之前进行处理（需要libgd库）</td></tr><tr><td>–with-http_geoip_module</td><td>使用该模块，能够设置各种变量以便在配置文件中的区段使用，基于地理位置查找客户端IP地址</td></tr><tr><td>–with-http_sub_module</td><td>该模块实现替代过滤，在响应中用一个字符串替代另一个字符串</td></tr><tr><td>–with-heep_dav_module</td><td>启用这个模块将激活使用WebDAV的配置指令。</td></tr><tr><td>–with-http_flv_module</td><td>如果需要提供Flash流媒体视频文件，那么该模块将会提供伪流媒体</td></tr><tr><td>–with-http_mp4_module</td><td>这个模块支持H.264/AAC文件伪流媒体</td></tr><tr><td>–with-http_gzip_static_module</td><td>当被调用的资源没有.gz结尾格式的文件时，如果想支持发送预压缩版本的静态文件，那么使用该模块</td></tr><tr><td>–with-http_gunzip_module</td><td>对于不支持gzip编码的客户，该模块用于为客户解压缩预压缩内容</td></tr><tr><td>–with-http_random_index_module</td><td>如果你想提供从一个目录中随机选择文件的索引文件，那么该模块需要激活</td></tr><tr><td>–with-http_secure_link_module</td><td>该模块提供一种机制，它会将一个哈希值链接到一个URL中，因此只有那些使用正确密码能够计算链接</td></tr><tr><td>–with-http_stub_status_module</td><td>启用这个模块后会收集Nginx自身的状态信息。输出的状态信息可以使用RRDtool或类似的东西绘制成图</td></tr></tbody></table><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>配置文件一般为/etc/nginx/nginx.conf或/usr/local/nginx/conf/nginx.conf。</p><h3 id="2-1-基本配置格式"><a href="#2-1-基本配置格式" class="headerlink" title="2.1. 基本配置格式"></a>2.1. 基本配置格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`section`&#123;</span><br><span class="line">    `directive` `parameters`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个指令行由分号结束，大括号{}表示一个新的上下文。</p><h3 id="2-2-Nginx全局配置参数"><a href="#2-2-Nginx全局配置参数" class="headerlink" title="2.2. Nginx全局配置参数"></a>2.2. Nginx全局配置参数</h3><p>全局配置指令</p><table><thead><tr><th>模块</th><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>main模块</td><td>user</td><td>配置worker进程的用户和组，如果忽略group，则group等于指定的用户的所属组</td></tr><tr><td>worker_processes</td><td>指定worker进程的启动数量，可将其设置为可用的CPU内核数，若为auto为自动检测</td><td></td></tr><tr><td>error_log</td><td>所有错误的写入文件，第二个参数指定错误的级别（debug，info，notice，warn，error，crit，alert，emerg）</td><td></td></tr><tr><td>pid</td><td>设置主进程IP的文件</td><td></td></tr><tr><td>events模块</td><td>use</td><td>用于设置使用什么样的连接方法</td></tr><tr><td>worker_connections</td><td>用于配置一个工作进程能够接受的并发连接最大数。包括客户连接和向上游服务器的连接。</td><td></td></tr></tbody></table><h3 id="2-3-使用include文件"><a href="#2-3-使用include文件" class="headerlink" title="2.3. 使用include文件"></a>2.3. 使用include文件</h3><p>include文件可以在任何地方以增强配置文件的可读性，使用include文件要确保被包含文件自身正确的nginx语法，即配置指令和块，然后指定这些文件的路径。</p><p>include /etc/nginx/mime.types;</p><p>若使用通配符则表示通配的多个文件，若没有给定全路径则依据主配置文件路径进行搜索。</p><p>include /etc/nginx/conf.d/*.conf</p><p>测试配置文件(包括include的配置文件)语法：</p><p>nginx -t -c path-to-nginx.conf</p><h3 id="2-4-配置说明"><a href="#2-4-配置说明" class="headerlink" title="2.4. 配置说明"></a>2.4. 配置说明</h3><h4 id="2-4-1-main模块"><a href="#2-4-1-main模块" class="headerlink" title="2.4.1. main模块"></a>2.4.1. main模块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">main模块类似main函数包含其他子模块，非模块配置项(包括模块内)分号结尾，子模块配置花括号结尾</span></span><br><span class="line">user nobady;   #一般按默认设置</span><br><span class="line">pid /var/run/nginx.pid;   #进程标识符存放路径，一般按默认设置</span><br><span class="line">worker_processes auto;   #nginx对外提供web服务时的worder进程数，可将其设置为可用的CPU内核数，auto为自动检测</span><br><span class="line">worker_rlimit_nofile 100000;  # 更改worker进程的最大打开文件数限制</span><br><span class="line">error_log logs/error.log  info;   #错误日志存放路径</span><br><span class="line">keepalive_timeout 60;  #keepalive_timeout 60;</span><br><span class="line">events&#123;</span><br><span class="line"><span class="meta">  #</span><span class="bash">见events模块</span></span><br><span class="line">&#125;</span><br><span class="line">http&#123;  #见http模块</span><br><span class="line">  server&#123; </span><br><span class="line">    ...</span><br><span class="line">    location /&#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">mail&#123;</span><br><span class="line"><span class="meta">  #</span><span class="bash">见mail模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-events模块"><a href="#2-4-2-events模块" class="headerlink" title="2.4.2. events模块"></a>2.4.2. events模块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">  worker_connections 2048;    #设置可由一个worker进程同时打开的最大连接数</span><br><span class="line">  multi_accept on;   #告诉nginx收到一个新连接通知后接受尽可能多的连接</span><br><span class="line">  use epoll; #设置用于复用客户端线程的轮询方法。Linux 2.6+：使用epoll；*BSD：使用kqueue。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-http模块"><a href="#2-4-3-http模块" class="headerlink" title="2.4.3. http模块"></a>2.4.3. http模块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">http &#123;  #http模块</span><br><span class="line">    server &#123;  #server模块，http服务上的虚拟主机， server 当做对应一个域名进行的配置</span><br><span class="line">        listen          80;  #配置监听端口</span><br><span class="line">        server_name     www.linuxidc.com; #配置访问域名</span><br><span class="line">        access_log      logs/linuxidc.access.log main;  #指定日志文件的存放路径</span><br><span class="line">        index index.html;    #默认访问页面</span><br><span class="line">        root  /var/www/androidj.com/htdocs;  # root 是指将本地的一个文件夹作为所有 url 请求的根路径</span><br><span class="line">        upstream backend &#123;   #反向代理的后端机器，实现负载均衡</span><br><span class="line">            ip_hash;    #指明了我们均衡的方式是按照用户的 ip 地址进行分配</span><br><span class="line">            server backend1.example.com;</span><br><span class="line">            server backend2.example.com;</span><br><span class="line">            server backend3.example.com;</span><br><span class="line">            server backend4.example.com;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;  #location 是在一个域名下对更精细的路径进行配置</span><br><span class="line">            proxy_pass http://backend;  #反向代理到后端机器</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line">        listen          80;</span><br><span class="line">        server_name     www.Androidj.com;</span><br><span class="line">        access_log      logs/androidj.access.log main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            index index.html;</span><br><span class="line">            root  /var/www/androidj.com/htdocs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-mail模块"><a href="#2-4-4-mail模块" class="headerlink" title="2.4.4. mail模块"></a>2.4.4. mail模块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mail &#123;</span><br><span class="line">    auth_http  127.0.0.1:80/auth.php;</span><br><span class="line">    pop3_capabilities  "TOP"  "USER";</span><br><span class="line">    imap_capabilities  "IMAP4rev1"  "UIDPLUS";</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line">        listen     110;</span><br><span class="line">        protocol   pop3;</span><br><span class="line">        proxy      on;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      25;</span><br><span class="line">        protocol    smtp;</span><br><span class="line">        proxy       on;</span><br><span class="line">        smtp_auth   login plain;</span><br><span class="line">        xclient     off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Redis] Redis介绍</title>
      <link href="/2017/07/15/redis/redis-introduction/"/>
      <url>/2017/07/15/redis/redis-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="一、redis是什么？（what）"><a href="#一、redis是什么？（what）" class="headerlink" title="一、redis是什么？（what）"></a>一、redis是什么？（what）</h2><p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><a id="more"></a><h2 id="二、为什么使用redis？（why）"><a href="#二、为什么使用redis？（why）" class="headerlink" title="二、为什么使用redis？（why）"></a>二、为什么使用redis？（why）</h2><h3 id="（一）redis的特点"><a href="#（一）redis的特点" class="headerlink" title="（一）redis的特点"></a>（一）redis的特点</h3><ol><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ol><h3 id="（二）redis的优势"><a href="#（二）redis的优势" class="headerlink" title="（二）redis的优势"></a>（二）redis的优势</h3><ol><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ol><h3 id="（三）redis与其他key-value存储有什么不同"><a href="#（三）redis与其他key-value存储有什么不同" class="headerlink" title="（三）redis与其他key-value存储有什么不同"></a>（三）redis与其他key-value存储有什么不同</h3><ol><li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</li><li>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，应为数据量不能大于硬件内存。</li><li>相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。</li><li>在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</li></ol><h2 id="三、如何使用redis？（how）"><a href="#三、如何使用redis？（how）" class="headerlink" title="三、如何使用redis？（how）"></a>三、如何使用redis？（how）</h2><h3 id="（一）redis的数据类型"><a href="#（一）redis的数据类型" class="headerlink" title="（一）redis的数据类型"></a>（一）redis的数据类型</h3><table><thead><tr><th>数据类型</th><th>概念</th><th>常用命令</th></tr></thead><tbody><tr><td>String(字符串)</td><td>key-value型</td><td>SET ，GET</td></tr><tr><td>Hash(哈希)</td><td>field-value,适用于存储对象类型（对象名-对象属性值）</td><td>HMSET，HEGTALL</td></tr><tr><td>List(列表)</td><td>string类型的有序列表，按照插入顺序排序</td><td>lpush，lrange</td></tr><tr><td>Set(集合)</td><td>string类型的无序集合</td><td>sadd，smembers</td></tr><tr><td>zset(sorted set：有序集合)</td><td>string类型元素的集合,且不允许重复的成员。每个元素关联一个double值来进行排序，double值可以重复但元素不能重复。</td><td>zadd，ZRANGEBYSCORE</td></tr></tbody></table><h3 id="（二）redis常用命令"><a href="#（二）redis常用命令" class="headerlink" title="（二）redis常用命令"></a>（二）redis常用命令</h3>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Docker] Dockerfile使用说明</title>
      <link href="/2017/07/09/docker/dockerfile-usage/"/>
      <url>/2017/07/09/docker/dockerfile-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Dockerfile的说明"><a href="#一、Dockerfile的说明" class="headerlink" title="一、Dockerfile的说明"></a>一、Dockerfile的说明</h2><a id="more"></a><p>dockerfile指令忽略大小写，建议大写，#作为注释，每行只支持一条指令，指令可以带多个参数。</p><p>dockerfile指令分为构建指令和设置指令。</p><ol><li>构建指令：用于构建image，其指定的操作不会在运行image的容器中执行。</li><li>设置指令：用于设置image的属性，其指定的操作会在运行image的容器中执行。</li></ol><h2 id="二、Dockerfile指令说明"><a href="#二、Dockerfile指令说明" class="headerlink" title="二、Dockerfile指令说明"></a>二、Dockerfile指令说明</h2><h3 id="1、FROM（指定基础镜像）-构建指令"><a href="#1、FROM（指定基础镜像）-构建指令" class="headerlink" title="1、FROM（指定基础镜像）[构建指令]"></a>1、FROM（指定基础镜像）[构建指令]</h3><p>该命令用来指定基础镜像，在基础镜像的基础上修改数据从而构建新的镜像。基础镜像可以是本地仓库也可以是远程仓库。</p><p>指令有两种格式：</p><ol><li>FROM <code>image</code>   【默认为latest版本】</li><li>FROM <code>image</code>:<code>tag</code>     【指定版本】</li></ol><h3 id="2、MAINTAINER（镜像创建者信息）-构建指令"><a href="#2、MAINTAINER（镜像创建者信息）-构建指令" class="headerlink" title="2、MAINTAINER（镜像创建者信息）[构建指令]"></a>2、MAINTAINER（镜像创建者信息）[构建指令]</h3><p>将镜像制作者（维护者）的信息写入image中，执行docker inspect时会输出该信息。</p><p>格式：MAINTAINER <code>name</code></p><h3 id="3、RUN（安装软件用）-构建指令"><a href="#3、RUN（安装软件用）-构建指令" class="headerlink" title="3、RUN（安装软件用）[构建指令]"></a>3、RUN（安装软件用）[构建指令]</h3><p>RUN可以运行任何被基础镜像支持的命令（即在基础镜像上执行一个进程），可以使用多条RUN指令，指令较长可以使用\来换行。</p><p>指令有两种格式：</p><ol><li>RUN <code>command</code> (the command is run in a shell - <code>/bin/sh -c</code>)</li><li>RUN [“executable”, “param1”, “param2” … ] (exec form) <ul><li>指定使用其他终端实现，使用exec执行。</li><li>例子：RUN[“/bin/bash”,”-c”,”echo hello”]</li></ul></li></ol><h3 id="4、CMD（设置container启动时执行的操作）-设置指令"><a href="#4、CMD（设置container启动时执行的操作）-设置指令" class="headerlink" title="4、CMD（设置container启动时执行的操作）[设置指令]"></a>4、CMD（设置container启动时执行的操作）[设置指令]</h3><p>用于容器启动时的指定操作，可以是自定义脚本或命令，只执行一次，多个默认执行最后一个。</p><p>指令有三种格式：</p><ol><li>CMD [“executable”,”param1”,”param2”] (like an exec, this is the preferred form) <ul><li>运行一个可执行文件并提供参数。</li></ul></li><li>CMD command param1 param2 (as a shell) <ul><li>直接执行shell命令，默认以/bin/sh -c执行。</li></ul></li><li>CMD [“param1”,”param2”] (as default parameters to ENTRYPOINT) <ul><li>和ENTRYPOINT配合使用，只作为完整命令的参数部分。</li></ul></li></ol><h3 id="5、ENTRYPOINT（设置container启动时执行的操作）-设置指令"><a href="#5、ENTRYPOINT（设置container启动时执行的操作）-设置指令" class="headerlink" title="5、ENTRYPOINT（设置container启动时执行的操作）[设置指令]"></a>5、ENTRYPOINT（设置container启动时执行的操作）[设置指令]</h3><p>指定容器启动时执行的命令，若多次设置只执行最后一次。</p><p>ENTRYPOINT翻译为“进入点”，它的功能可以让容器表现得像一个可执行程序一样。</p><p>例子：ENTRYPOINT [“/bin/echo”] ，那么docker build出来的镜像以后的容器功能就像一个/bin/echo程序，docker run -it imageecho “this is a test”，就会输出对应的字符串。这个imageecho镜像对应的容器表现出来的功能就像一个echo程序一样。</p><p>指令有两种格式：</p><ol><li><p>ENTRYPOINT [“executable”, “param1”, “param2”] (like an exec, the preferred form)</p><ul><li><p>和CMD配合使用，CMD则作为完整命令的参数部分，ENTRYPOINT以JSON格式指定执行的命令部分。CMD可以为ENTRYPOINT提供可变参数，不需要变动的参数可以写在ENTRYPOINT里面。</p></li><li><p>例子：</p><p>ENTRYPOINT [“/usr/bin/ls”,”-a”]</p><p>CMD [“-l”] </p></li></ul></li><li><p>ENTRYPOINT command param1 param2 (as a shell)</p><ul><li>独自使用，即和CMD类似，如果CMD也是个完整命令[CMD command param1 param2 (as a shell) ]，那么会相互覆盖，只执行最后一个CMD或ENTRYPOINT。</li><li>例子：ENTRYPOINT ls -l</li></ul></li></ol><h3 id="6、USER（设置container容器启动的登录用户）-设置指令"><a href="#6、USER（设置container容器启动的登录用户）-设置指令" class="headerlink" title="6、USER（设置container容器启动的登录用户）[设置指令]"></a>6、USER（设置container容器启动的登录用户）[设置指令]</h3><p>设置启动容器的用户，默认为root用户。</p><p>格式：USER daemon</p><h3 id="7、EXPOSE（指定容器需要映射到宿主机的端口）-设置指令"><a href="#7、EXPOSE（指定容器需要映射到宿主机的端口）-设置指令" class="headerlink" title="7、EXPOSE（指定容器需要映射到宿主机的端口）[设置指令]"></a>7、EXPOSE（指定容器需要映射到宿主机的端口）[设置指令]</h3><p>该指令会将容器中的端口映射为宿主机中的端口[确保宿主机的端口号没有被使用]。通过宿主机IP和映射后的端口即可访问容器[避免每次运行容器时IP随机生成不固定的问题]。前提是EXPOSE设置映射端口，运行容器时加上-p参数指定EXPOSE设置的端口。EXPOSE可以设置多个端口号，相应地运行容器配套多次使用-p参数。可以通过docker port +容器需要映射的端口号和容器ID来参考宿主机的映射端口。</p><p>格式：EXPOSE <code>port</code> [<code>port</code>…]</p><h3 id="8、ENV（用于设置环境变量）-构建指令"><a href="#8、ENV（用于设置环境变量）-构建指令" class="headerlink" title="8、ENV（用于设置环境变量）[构建指令]"></a>8、ENV（用于设置环境变量）[构建指令]</h3><p>在image中设置环境变量[以键值对的形式]，设置之后RUN命令可以使用该环境变量，在容器启动后也可以通过docker inspect查看环境变量或者通过 docker run –env key=value设置或修改环境变量。</p><p>格式：ENV <code>key</code> <code>value</code> </p><p>例子：ENV JAVA_HOME /path/to/java/dirent</p><h3 id="9、ADD（从src复制文件到container的dest路径）-构建指令"><a href="#9、ADD（从src复制文件到container的dest路径）-构建指令" class="headerlink" title="9、ADD（从src复制文件到container的dest路径）[构建指令]"></a>9、ADD（从src复制文件到container的dest路径）[构建指令]</h3><p>复制指定的src到容器中的dest，其中src是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url。<code>dest</code> 是container中的绝对路径。所有拷贝到container中的文件和文件夹权限为0755，uid和gid为0。</p><ul><li>如果src是一个目录，那么会将该目录下的所有文件添加到container中，不包括目录；</li><li>如果src文件是可识别的压缩格式，则docker会帮忙解压缩（注意压缩格式）；</li><li>如果<code>src</code>是文件且<code>dest</code>中不使用斜杠结束，则会将<code>dest</code>视为文件，<code>src</code>的内容会写入<code>dest</code>；</li><li>如果<code>src</code>是文件且<code>dest</code>中使用斜杠结束，则会<code>src</code>文件拷贝到<code>dest</code>目录下。</li></ul><p>格式：ADD <code>src</code> <code>dest</code> </p><h3 id="10、COPY（复制文件）"><a href="#10、COPY（复制文件）" class="headerlink" title="10、COPY（复制文件）"></a>10、COPY（复制文件）</h3><p>复制本地主机的src为容器中的dest，目标路径不存在时会自动创建。</p><p>格式：COPY <code>src</code> <code>dest</code></p><h3 id="11、VOLUME（指定挂载点）-设置指令"><a href="#11、VOLUME（指定挂载点）-设置指令" class="headerlink" title="11、VOLUME（指定挂载点）[设置指令]"></a>11、VOLUME（指定挂载点）[设置指令]</h3><p>创建一个可以从本地主机或其他容器挂载的挂载点，使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用也可以被其他容器使用。</p><p>格式：VOLUME [“<code>mountpoint</code>“] </p><p>其他容器使用共享数据卷：docker run -t -i -rm -volumes-from container1 image2 bash [container1为第一个容器的ID，image2为第二个容器运行image的名字。]</p><h3 id="12、WORKDIR（切换目录）-设置指令"><a href="#12、WORKDIR（切换目录）-设置指令" class="headerlink" title="12、WORKDIR（切换目录）[设置指令]"></a>12、WORKDIR（切换目录）[设置指令]</h3><p>相当于cd命令，可以多次切换目录，为RUN,CMD,ENTRYPOINT配置工作目录。可以使用多个WORKDIR的命令，后续命令如果是相对路径则是在上一级路径的基础上执行[类似cd的功能]。</p><p>格式：WORKDIR /path/to/workdir</p><h3 id="13、ONBUILD（在子镜像中执行）"><a href="#13、ONBUILD（在子镜像中执行）" class="headerlink" title="13、ONBUILD（在子镜像中执行）"></a>13、ONBUILD（在子镜像中执行）</h3><p>当所创建的镜像作为其他新创建镜像的基础镜像时执行的操作命令，即在创建本镜像时不运行，当作为别人的基础镜像时再在构建时运行（可认为基础镜像为父镜像，而该命令即在它的子镜像构建时运行，相当于在子镜像构建时多加了一些命令）。</p><p>格式：ONBUILD <code>Dockerfile关键字</code> </p><h2 id="三、docker-build"><a href="#三、docker-build" class="headerlink" title="三、docker build"></a>三、docker build</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Usage: docker build [OPTIONS] PATH | URL | -</span><br><span class="line"></span><br><span class="line">Build a new image from the source code at PATH</span><br><span class="line"></span><br><span class="line">-c, --cpu-shares=0                      CPU shares (relative weight)</span><br><span class="line"></span><br><span class="line">--cgroup-parent=                       Optional parent cgroup for the container</span><br><span class="line"></span><br><span class="line">--cpu-period=0                           Limit the CPU CFS (Completely Fair Scheduler) period</span><br><span class="line"></span><br><span class="line">--cpu-quota=0                            Limit the CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line"></span><br><span class="line">--cpuset-cpus=                           CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line"></span><br><span class="line">--cpuset-mems=                         MEMs in which to allow execution (0-3, 0,1)</span><br><span class="line"></span><br><span class="line">--disable-content-trust=true       Skip image verification</span><br><span class="line"></span><br><span class="line">-f, --file=                                     Name of the Dockerfile (Default is 'PATH/Dockerfile')</span><br><span class="line"></span><br><span class="line">--force-rm=false                          Always remove intermediate containers</span><br><span class="line"></span><br><span class="line">--help=false                                 Print usage</span><br><span class="line"></span><br><span class="line">-m, --memory=                          Memory limit</span><br><span class="line"></span><br><span class="line">--memory-swap=                       Total memory (memory + swap), '-1' to disable swap</span><br><span class="line"></span><br><span class="line">--no-cache=false                        Do not use cache when building the image</span><br><span class="line"></span><br><span class="line">--pull=false                                 Always attempt to pull a newer version of the image</span><br><span class="line"></span><br><span class="line">-q, --quiet=false                         Suppress the verbose output generated by the containers</span><br><span class="line"></span><br><span class="line">--rm=true                                  Remove intermediate containers after a successful build</span><br><span class="line"></span><br><span class="line">-t, --tag=                                   Repository name (and optionally a tag) for the image</span><br><span class="line"></span><br><span class="line">--ulimit=[] Ulimit options</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Docker] Docker整体架构图</title>
      <link href="/2017/07/09/docker/docker-architecture/"/>
      <url>/2017/07/09/docker/docker-architecture/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Docker的总架构图"><a href="#一、Docker的总架构图" class="headerlink" title="一、Docker的总架构图"></a>一、Docker的总架构图</h2><a id="more"></a><img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510577966/article/docker/dockerArch/docker-architecture.jpg" width="60%"/><p>docker是一个C/S模式的架构，后端是一个松耦合架构，模块各司其职。</p><ol><li>用户是使用Docker Client与Docker Daemon建立通信，并发送请求给后者。</li><li>Docker Daemon作为Docker架构中的主体部分，首先提供Server的功能使其可以接受Docker Client的请求；</li><li>Engine执行Docker内部的一系列工作，每一项工作都是以一个Job的形式的存在。</li><li>Job的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动graphdriver将下载镜像以Graph的形式存储；</li><li>当需要为Docker创建网络环境时，通过网络管理驱动networkdriver创建并配置Docker容器网络环境；</li><li>当需要限制Docker容器运行资源或执行用户指令等操作时，则通过execdriver来完成。</li><li>libcontainer是一项独立的容器管理包，networkdriver以及execdriver都是通过libcontainer来实现具体对容器进行的操作。</li></ol><h2 id="二、Docker各模块组件分析"><a href="#二、Docker各模块组件分析" class="headerlink" title="二、Docker各模块组件分析"></a>二、Docker各模块组件分析</h2><h3 id="（一）Docker-Client-发起请求"><a href="#（一）Docker-Client-发起请求" class="headerlink" title="（一）Docker Client[发起请求]"></a>（一）Docker Client[发起请求]</h3><ol><li>Docker Client是和Docker Daemon建立通信的客户端。用户使用的可执行文件为docker（类似可执行脚本的命令），docker命令后接参数的形式来实现一个完整的请求命令（例如docker images，docker为命令不可变，images为参数可变）。</li><li>Docker Client可以通过以下三种方式和Docker Daemon建立通信：<a href="">tcp://host:port，unix://path_to_socket和fd://socketfd。</a></li><li>Docker Client发送容器管理请求后，由Docker Daemon接受并处理请求，当Docker Client接收到返回的请求相应并简单处理后，Docker Client一次完整的生命周期就结束了。[一次完整的请求：发送请求→处理请求→返回结果]，与传统的C/S架构请求流程并无不同。</li></ol><h3 id="（二）Docker-Daemon-后台守护进程"><a href="#（二）Docker-Daemon-后台守护进程" class="headerlink" title="（二）Docker Daemon[后台守护进程]"></a>（二）Docker Daemon[后台守护进程]</h3><ul><li><p>Docker Daemon的架构图</p><img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510577967/article/docker/dockerArch/docker-daemon.jpg" width="60%"/></li></ul><ol><li><h4 id="Docker-Server-调度分发请求"><a href="#Docker-Server-调度分发请求" class="headerlink" title="Docker Server[调度分发请求]"></a>Docker Server[调度分发请求]</h4><ul><li>Docker Server的架构图</li></ul><img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510577967/article/docker/dockerArch/docker-server.jpg" width="60%"/><ol><li>Docker Server相当于C/S架构的服务端。功能为接受并调度分发Docker Client发送的请求。接受请求后，Server通过路由与分发调度，找到相应的Handler来执行请求。</li><li>在Docker的启动过程中，通过包gorilla/mux，创建了一个mux.Router，提供请求的路由功能。在Golang中，gorilla/mux是一个强大的URL路由器以及调度分发器。该mux.Router中添加了众多的路由项，每一个路由项由HTTP请求方法（PUT、POST、GET或DELETE）、URL、Handler三部分组成。</li><li>创建完mux.Router之后，Docker将Server的监听地址以及mux.Router作为参数，创建一个httpSrv=http.Server{}，最终执行httpSrv.Serve()为请求服务。</li><li>在Server的服务过程中，Server在listener上接受Docker Client的访问请求，并创建一个全新的goroutine来服务该请求。在goroutine中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的Handler来处理该请求，最后Handler处理完请求之后回复该请求。</li></ol></li><li><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><ol><li>Engine是Docker架构中的运行引擎，同时也Docker运行的核心模块。它扮演Docker container存储仓库的角色，并且通过执行job的方式来操纵管理这些容器。</li><li>在Engine数据结构的设计与实现过程中，有一个handler对象。该handler对象存储的都是关于众多特定job的handler处理访问。举例说明，Engine的handler对象中有一项为：{“create”: daemon.ContainerCreate,}，则说明当名为”create”的job在运行时，执行的是daemon.ContainerCreate的handler。</li></ol></li><li><h4 id="job"><a href="#job" class="headerlink" title="job"></a>job</h4><ol><li>一个Job可以认为是Docker架构中Engine内部最基本的工作执行单元。Docker可以做的每一项工作，都可以抽象为一个job。例如：在容器内部运行一个进程，这是一个job；创建一个新的容器，这是一个job。Docker Server的运行过程也是一个job，名为serveapi。</li><li>Job的设计者，把Job设计得与Unix进程相仿。比如说：Job有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</li></ol></li></ol><h3 id="（三）Docker-Registry-镜像注册中心"><a href="#（三）Docker-Registry-镜像注册中心" class="headerlink" title="（三）Docker Registry[镜像注册中心]"></a>（三）Docker Registry[镜像注册中心]</h3><ol><li>Docker Registry是一个存储容器镜像的仓库（注册中心），可理解为云端镜像仓库，按repository来分类，docker pull 按照[repository]:[tag]来精确定义一个image。</li><li>在Docker的运行过程中，Docker Daemon会与Docker Registry通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的job名称分别为”search”，”pull” 与 “push”。</li><li>可分为公有仓库（docker hub）和私有仓库。</li></ol><h3 id="（四）Graph-docker内部数据库"><a href="#（四）Graph-docker内部数据库" class="headerlink" title="（四）Graph[docker内部数据库]"></a>（四）Graph[docker内部数据库]</h3><ul><li><p>Graph的架构图</p><img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510577968/article/docker/dockerArch/graph-architecture.jpg" width="60%"/></li></ul><ol><li><h4 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h4><ol><li>已下载镜像的保管者（包括下载镜像和dockerfile构建的镜像）。</li><li>一个repository表示某类镜像的仓库（例如Ubuntu），同一个repository内的镜像用tag来区分（表示同一类镜像的不同标签或版本）。一个registry包含多个repository，一个repository包含同类型的多个image。</li><li>镜像的存储类型有aufs，devicemapper,Btrfs，Vfs等。其中centos系统使用devicemapper的存储类型。</li><li>同时在Graph的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体rootfs。</li></ol></li><li><h4 id="GraphDB"><a href="#GraphDB" class="headerlink" title="GraphDB"></a>GraphDB</h4><ol><li>已下载容器镜像之间关系的记录者。</li><li>GraphDB是一个构建在SQLite之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录</li></ol></li></ol><h3 id="（五）Driver-执行部分"><a href="#（五）Driver-执行部分" class="headerlink" title="（五）Driver[执行部分]"></a>（五）Driver[执行部分]</h3><p>Driver是Docker架构中的驱动模块。通过Driver驱动，Docker可以实现对Docker容器执行环境的定制。即Graph负责镜像的存储，Driver负责容器的执行。</p><ol><li><h4 id="graphdriver"><a href="#graphdriver" class="headerlink" title="graphdriver"></a>graphdriver</h4><ul><li><p>graphdriver架构图</p> <img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510577968/article/docker/dockerArch/graphdriver.jpg" width="60%"/></li></ul><ol><li>graphdriver主要用于完成容器镜像的管理，包括存储与获取。</li><li>存储：docker pull下载的镜像由graphdriver存储到本地的指定目录（Graph中）。</li><li>获取：docker run（create）用镜像来创建容器的时候由graphdriver到本地Graph中获取镜像。</li></ol></li></ol><ol><li><h4 id="networkdriver"><a href="#networkdriver" class="headerlink" title="networkdriver"></a>networkdriver</h4><ul><li><p>networkdriver的架构图</p> <img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510577968/article/docker/dockerArch/networkdriver.jpg" width="60%"/></li></ul><ol><li>networkdriver的用途是完成Docker容器网络环境的配置，其中包括<ul><li>Docker启动时为Docker环境创建网桥；</li><li>Docker容器创建时为其创建专属虚拟网卡设备；</li><li>Docker容器分配IP、端口并与宿主机做端口映射，设置容器防火墙策略等。</li></ul></li></ol></li><li><h4 id="execdriver"><a href="#execdriver" class="headerlink" title="execdriver"></a>execdriver</h4><ul><li><p>execdriver的架构图</p> <img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510577967/article/docker/dockerArch/execdriver.jpg" width="55%"/></li></ul><ol><li>execdriver作为Docker容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。</li><li>现在execdriver默认使用native驱动，不依赖于LXC。</li></ol></li></ol><h3 id="（六）libcontainer-函数库"><a href="#（六）libcontainer-函数库" class="headerlink" title="（六）libcontainer[函数库]"></a>（六）libcontainer[函数库]</h3><ul><li><p>libcontainer的架构图</p> <img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510577967/article/docker/dockerArch/libcontainer.jpg" width="60%"/></li></ul><ol><li>libcontainer是Docker架构中一个使用Go语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的API。</li><li>Docker可以直接调用libcontainer，而最终操纵容器的namespace、cgroups、apparmor、网络设备以及防火墙规则等。</li><li>libcontainer提供了一整套标准的接口来满足上层对容器管理的需求。或者说，libcontainer屏蔽了Docker上层对容器的直接管理。</li></ol><h3 id="（七）docker-container-服务交付的最终形式"><a href="#（七）docker-container-服务交付的最终形式" class="headerlink" title="（七）docker container[服务交付的最终形式]"></a>（七）docker container[服务交付的最终形式]</h3><ul><li><p>container架构</p><img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510577966/article/docker/dockerArch/container.jpg" width="60%"/></li></ul><ol><li><p>Docker container（Docker容器）是Docker架构中服务交付的最终体现形式。</p></li><li><p>Docker按照用户的需求与指令，订制相应的Docker容器：</p></li><li><ul><li>用户通过指定容器镜像，使得Docker容器可以自定义rootfs等文件系统；</li><li>用户通过指定计算资源的配额，使得Docker容器使用指定的计算资源；</li><li>用户通过配置网络及其安全策略，使得Docker容器拥有独立且安全的网络环境；</li><li>用户通过指定运行的命令，使得Docker容器执行指定的工作。</li></ul></li></ol><p>附：本文在《docker源码分析》基础上进行整理。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Docker] Docker常用命令原理图</title>
      <link href="/2017/07/09/docker/docker-commands-principle/"/>
      <url>/2017/07/09/docker/docker-commands-principle/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><a id="more"></a><h2 id="1-1-image-layer（镜像层）"><a href="#1-1-image-layer（镜像层）" class="headerlink" title="1.1. image layer（镜像层）"></a>1.1. image layer（镜像层）</h2><p>镜像可以看成是由多个镜像层叠加起来的一个文件系统，镜像层也可以简单理解为一个基本的镜像，而每个镜像层之间通过指针的形式进行叠加。</p><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578327/article/docker/commands/1.png" alt="1"></p><p>根据上图，镜像层的主要组成部分包括镜像层id，镜像层指针【指向父层】，元数据【layer metadata】包含了docker构建和运行的信息还有父层的层次信息。</p><p>只读层和读写层【top layer】的组成部分基本一致。同时读写层可以转换成只读层【docker commit操作实现】</p><h2 id="1-2-image（镜像）—【只读层的集合】"><a href="#1-2-image（镜像）—【只读层的集合】" class="headerlink" title="1.2. image（镜像）—【只读层的集合】"></a>1.2. image（镜像）—【只读层的集合】</h2><p>1、镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层，统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。而每一层都是不可写的，就是只读层。</p><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578328/article/docker/commands/2.1.png" alt="2.1"></p><h2 id="1-3-container（容器）—【一层读写层-多层只读层】"><a href="#1-3-container（容器）—【一层读写层-多层只读层】" class="headerlink" title="1.3. container（容器）—【一层读写层+多层只读层】"></a>1.3. container（容器）—【一层读写层+多层只读层】</h2><p>1、容器和镜像的区别在于容器的最上面一层是读写层【top layer】，而这边并没有区分容器是否在运行。运行状态的容器【running container】即一个可读写的文件系统【静态容器】+隔离的进程空间和其中的进程。</p><p> <img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578329/article/docker/commands/3.1.png" alt="3.1"></p><p>隔离的进程空间中的进程可以对该读写层进行增删改，其运行状态容器的进程操作都作用在该读写层上。每个容器只能有一个进程隔离空间。</p><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578328/article/docker/commands/3.2.png" alt="3.2"></p><h1 id="2-Docker常用命令原理图概览："><a href="#2-Docker常用命令原理图概览：" class="headerlink" title="2. Docker常用命令原理图概览："></a>2. Docker常用命令原理图概览：</h1><img src="http://res.cloudinary.com/dqxtn0ick/image/upload/v1510578333/article/docker/commands/dockerCommands.jpg" width="70%"><h1 id="3-Docker常用命令说明"><a href="#3-Docker常用命令说明" class="headerlink" title="3.  Docker常用命令说明"></a>3.  Docker常用命令说明</h1><h2 id="3-1-标识说明"><a href="#3-1-标识说明" class="headerlink" title="3.1. 标识说明"></a>3.1. 标识说明</h2><h3 id="3-1-1-image—（统一只读文件系统）"><a href="#3-1-1-image—（统一只读文件系统）" class="headerlink" title="3.1.1. image—（统一只读文件系统）"></a>3.1.1. image—（统一只读文件系统）</h3><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578329/article/docker/commands/4.1.1.png" alt="4.1.1"></p><h3 id="3-1-2-静态容器【未运行的容器】—（统一可读写文件系统）"><a href="#3-1-2-静态容器【未运行的容器】—（统一可读写文件系统）" class="headerlink" title="3.1.2. 静态容器【未运行的容器】—（统一可读写文件系统）"></a>3.1.2. 静态容器【未运行的容器】—（统一可读写文件系统）</h3><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578329/article/docker/commands/4.1.2.png" alt="4.1.2"></p><h3 id="3-1-3-动态容器【running-container】—（进程空间（包括进程）-统一可读写文件系统）"><a href="#3-1-3-动态容器【running-container】—（进程空间（包括进程）-统一可读写文件系统）" class="headerlink" title="3.1.3. 动态容器【running container】—（进程空间（包括进程）+统一可读写文件系统）"></a>3.1.3. 动态容器【running container】—（进程空间（包括进程）+统一可读写文件系统）</h3><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578330/article/docker/commands/4.1.3.png" alt="4.1.3"></p><h2 id="3-2-命令说明"><a href="#3-2-命令说明" class="headerlink" title="3.2. 命令说明"></a>3.2. 命令说明</h2><h3 id="3-2-1-docker生命周期相关命令"><a href="#3-2-1-docker生命周期相关命令" class="headerlink" title="3.2.1. docker生命周期相关命令:"></a>3.2.1. docker生命周期相关命令:</h3><h4 id="3-2-1-1-docker-create-image-id"><a href="#3-2-1-1-docker-create-image-id" class="headerlink" title="3.2.1.1. docker create {image-id}"></a>3.2.1.1. docker create {image-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578330/article/docker/commands/4.2.1.1.png" alt="4.2.1.1"></p><p>即为只读文件系统添加一层可读写层【top layer】，生成可读写文件系统，该命令状态下容器为静态容器，并没有运行。</p><h4 id="3-2-1-2-docker-start（restart）-container-id"><a href="#3-2-1-2-docker-start（restart）-container-id" class="headerlink" title="3.2.1.2. docker start（restart） {container-id}"></a>3.2.1.2. docker start（restart） {container-id}</h4><p>docker stop即为docker start的逆过程</p><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578330/article/docker/commands/4.2.1.2.png" alt="4.2.1.2"></p><p>即为可读写文件系统添加一个进程空间【包括进程】，生成动态容器【running container】</p><h4 id="3-2-1-3-docker-run-image-id"><a href="#3-2-1-3-docker-run-image-id" class="headerlink" title="3.2.1.3. docker run {image-id}"></a>3.2.1.3. docker run {image-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578330/article/docker/commands/4.2.1.3.png" alt="4.2.1.3"></p><p>docker run=docker create+docker start</p><p>类似流程如下 ：</p><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578329/article/docker/commands/4.2.1.3.1.png" alt="4.2.1.3.1"></p><h4 id="3-2-1-4-docker-stop-container-id"><a href="#3-2-1-4-docker-stop-container-id" class="headerlink" title="3.2.1.4. docker stop {container-id}"></a>3.2.1.4. docker stop {container-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578330/article/docker/commands/4.2.1.4.png" alt="4.2.1.4"></p><p>向运行的容器中发一个SIGTERM的信号，然后停止所有的进程。即为docker start的逆过程。</p><h4 id="3-2-1-5-docker-kill-container-id"><a href="#3-2-1-5-docker-kill-container-id" class="headerlink" title="3.2.1.5. docker kill {container-id}"></a>3.2.1.5. docker kill {container-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578331/article/docker/commands/4.2.1.5.png" alt="4.2.1.5"></p><p>docker kill向容器发送不友好的SIGKILL的信号，相当于快速强制关闭容器，与docker stop的区别在于docker stop是正常关闭，先发SIGTERM信号，清理进程，再发SIGKILL信号退出。</p><h4 id="3-2-1-6-docker-pause-container-id"><a href="#3-2-1-6-docker-pause-container-id" class="headerlink" title="3.2.1.6. docker pause {container-id}"></a>3.2.1.6. docker pause {container-id}</h4><p>docker unpause为逆过程—比较少使用</p><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578330/article/docker/commands/4.2.1.6.png" alt="4.2.1.6"></p><p>暂停容器中的所有进程，使用cgroup的freezer顺序暂停容器里的所有进程，docker unpause为逆过程即恢复所有进程。比较少使用。</p><h4 id="3-2-1-7-docker-commit-container-id"><a href="#3-2-1-7-docker-commit-container-id" class="headerlink" title="3.2.1.7. docker commit {container-id}"></a>3.2.1.7. docker commit {container-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578331/article/docker/commands/4.2.1.7.png" alt="4.2.1.7"></p><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578331/article/docker/commands/4.2.1.7.2.png" alt="4.2.1.7.2"></p><p>把容器的可读写层转化成只读层，即从容器状态【可读写文件系统】变为镜像状态【只读文件系统】，可理解为【固化】。</p><h4 id="3-2-1-8-docker-build"><a href="#3-2-1-8-docker-build" class="headerlink" title="3.2.1.8. docker build"></a>3.2.1.8. docker build</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578331/article/docker/commands/4.2.1.8.1.png" alt="4.2.1.8.1"></p><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578331/article/docker/commands/4.2.1.8.2.png" alt="4.2.1.8.2"></p><p><strong>docker build=docker run【运行容器】+【进程修改数据】+docker commit【固化数据】，不断循环直至生成所需镜像。</strong></p><p>循环一次便会形成新的层（镜像）【原镜像层+已固化的可读写层】</p><p>docker build 一般作用在dockerfile文件上。</p><h3 id="3-2-2-docker查询类命令"><a href="#3-2-2-docker查询类命令" class="headerlink" title="3.2.2. docker查询类命令"></a>3.2.2. docker查询类命令</h3><p>查询对象：①image，②container，③image/container中的数据，④系统信息[容器数，镜像数及其他]</p><h4 id="3-2-2-1-Image"><a href="#3-2-2-1-Image" class="headerlink" title="3.2.2.1. Image"></a>3.2.2.1. Image</h4><h4 id="1、docker-images"><a href="#1、docker-images" class="headerlink" title="1、docker images"></a>1、docker images</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578331/article/docker/commands/4.2.2.1.1.png" alt="4.2.2.1.1"></p><p>docker images 列出当前镜像【以顶层镜像id来表示整个完整镜像】，每个顶层镜像下面隐藏多个镜像层。</p><h4 id="2、docker-images-a"><a href="#2、docker-images-a" class="headerlink" title="2、docker images -a"></a>2、docker images -a</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578332/article/docker/commands/4.2.2.1.2.png" alt="4.2.2.1.2"></p><p>docker images -a列出所有镜像层【排序以每个顶层镜像id为首后接该镜像下的所有镜像层】，依次列出每个镜像的所有镜像层。</p><h4 id="3、docker-history-image-id"><a href="#3、docker-history-image-id" class="headerlink" title="3、docker history {image-id}"></a>3、docker history {image-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578331/article/docker/commands/4.2.2.1.3.png" alt="4.2.2.1.3"></p><p>docker history 列出该镜像id下的所有历史镜像。</p><h4 id="3-2-2-2-Container"><a href="#3-2-2-2-Container" class="headerlink" title="3.2.2.2. Container"></a>3.2.2.2. Container</h4><h4 id="1、docker-ps"><a href="#1、docker-ps" class="headerlink" title="1、docker ps"></a>1、docker ps</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578331/article/docker/commands/4.2.2.2.1.png" alt="4.2.2.2.1"></p><p>列出所有运行的容器【running container】</p><h4 id="2、docker-ps-a"><a href="#2、docker-ps-a" class="headerlink" title="2、docker ps -a"></a>2、docker ps -a</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578332/article/docker/commands/4.2.2.2.2.png" alt="4.2.2.2.2"></p><p>列出所有容器，包括静态容器【未运行的容器】和动态容器【running container】</p><h4 id="3-2-2-3-Info"><a href="#3-2-2-3-Info" class="headerlink" title="3.2.2.3. Info"></a>3.2.2.3. Info</h4><h4 id="1、docker-inspect-container-id-or-image-id"><a href="#1、docker-inspect-container-id-or-image-id" class="headerlink" title="1、docker inspect {container-id} or {image-id}"></a>1、docker inspect {container-id} or {image-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578332/article/docker/commands/4.2.2.3.1.png" alt="4.2.2.3.1"></p><p>提取出容器或镜像最顶层的元数据。</p><h4 id="2、docker-info"><a href="#2、docker-info" class="headerlink" title="2、docker info"></a>2、docker info</h4><p>显示 Docker 系统信息，包括镜像和容器数。</p><h3 id="3-2-3-docker操作类命令："><a href="#3-2-3-docker操作类命令：" class="headerlink" title="3.2.3. docker操作类命令："></a>3.2.3. docker操作类命令：</h3><h4 id="3-2-3-1-docker-rm-container-id"><a href="#3-2-3-1-docker-rm-container-id" class="headerlink" title="3.2.3.1. docker rm {container-id}"></a>3.2.3.1. docker rm {container-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578332/article/docker/commands/4.2.3.1.png" alt="4.2.3.1"></p><p>docker rm会移除镜像，该命令只能对静态容器【非运行状态】进行操作。</p><p>通过docker rm -f {container-id}的-f （force）参数可以强制删除运行状态的容器【running container】。</p><h4 id="3-2-3-2-docker-rmi-image-id"><a href="#3-2-3-2-docker-rmi-image-id" class="headerlink" title="3.2.3.2. docker rmi {image-id}"></a>3.2.3.2. docker rmi {image-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578332/article/docker/commands/4.2.3.2.png" alt="4.2.3.2"></p><h4 id="3-2-3-3-docker-exec-running-container-id"><a href="#3-2-3-3-docker-exec-running-container-id" class="headerlink" title="3.2.3.3. docker exec {running-container-id}"></a>3.2.3.3. docker exec {running-container-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578332/article/docker/commands/4.2.3.3.png" alt="4.2.3.3"></p><p>docker exec会在运行状态的容器中执行一个新的进程。</p><h4 id="3-2-3-4-docker-export-container-id"><a href="#3-2-3-4-docker-export-container-id" class="headerlink" title="3.2.3.4. docker export {container-id}"></a>3.2.3.4. docker export {container-id}</h4><p><img src="https://res.cloudinary.com/dqxtn0ick/image/upload/v1510578333/article/docker/commands/4.2.3.4.png" alt="4.2.3.4"></p><p>docker export命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容。</p><p>参考文章：</p><ul><li><a href="http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html" target="_blank" rel="noopener">http://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
